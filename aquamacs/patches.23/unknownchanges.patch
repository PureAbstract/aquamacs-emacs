*** nextstep/Cocoa/Emacs.base/Contents/Resources/English.lproj/InfoPlist.strings	26 Feb 2009 01:06:53 -0000	1.6
--- nextstep/Cocoa/Emacs.base/Contents/Resources/English.lproj/InfoPlist.strings	15 Mar 2009 20:38:45 -0000
***************
*** 1,6 ****
- /* Localized versions of Info.plist keys */
  
- CFBundleName = "Emacs";
- CFBundleShortVersionString = "Version 23.0.91";
- CFBundleGetInfoString = "Emacs version 23.0.91, NS Windowing";
- NSHumanReadableCopyright = "Copyright (C) 2009 Free Software Foundation, Inc.";
--- 1 ----
*** src/frame.c	11 Mar 2009 07:53:37 -0000	1.411
--- src/frame.c	15 Mar 2009 20:40:16 -0000
***************
*** 3315,3322 ****
  {
    if (NILP (new_value))
      f->extra_line_spacing = 0;
!   else if (NATNUMP (new_value))
!     f->extra_line_spacing = XFASTINT (new_value);
    else
      signal_error ("Invalid line-spacing", new_value);
    if (FRAME_VISIBLE_P (f))
--- 3315,3322 ----
  {
    if (NILP (new_value))
      f->extra_line_spacing = 0;
!   else if (INTEGERP (new_value))
!     f->extra_line_spacing = XINT (new_value);
    else
      signal_error ("Invalid line-spacing", new_value);
    if (FRAME_VISIBLE_P (f))
*** lisp/loadup.el	5 Jan 2009 03:19:29 -0000	1.179
--- lisp/loadup.el	15 Mar 2009 20:27:46 -0000
***************
*** 181,187 ****
        (load "international/fontset")
        (load "dnd")
        (load "mwheel")
!       (load "tool-bar")))
  (if (featurep 'x)
      (progn
        (load "x-dnd")
--- 181,188 ----
        (load "international/fontset")
        (load "dnd")
        (load "mwheel")
!        (load "tool-bar")
! ))
  (if (featurep 'x)
      (progn
        (load "x-dnd")
*** lisp/mwheel.el	5 Jan 2009 03:19:36 -0000	1.52
--- lisp/mwheel.el	15 Mar 2009 20:27:53 -0000
***************
*** 1,3 ****
--- 1,4 ----
+ (defvar mouse-wheel-mode nil)
  ;;; mwheel.el --- Wheel mouse support
  
  ;; Copyright (C) 1998, 2000, 2001, 2002, 2002, 2004, 2005, 2006, 2007,
*** src/nsfont.m	14 Mar 2009 21:20:07 -0000	1.20
--- src/nsfont.m	15 Mar 2009 20:40:40 -0000
***************
*** 661,690 ****
      expand = 0.0; 
      shrink = 1.0;
      hshrink = 1.0;
- 
      /*
      if (expand < 0.0)
        {
!         shrink = 1 + expand;
!         hshrink = 1 + expand / 2.0;
!         expand = 0.0;
        }
!     else
        shrink = hshrink = 1.0;
      */
  
      font_info->underpos = 2; /*[sfont underlinePosition] is often clipped out */
      font_info->underwidth = [sfont underlineThickness];
      font_info->size = font->pixel_size;
!     font_info->voffset = lrint (hshrink * [sfont ascender] + expand * hd / 2);
  
      /* max bounds */
      font_info->max_bounds.ascent =
        lrint (hshrink * [sfont ascender] + expand * hd/2);
      font_info->max_bounds.descent =
!       -lrint (hshrink* [sfont descender] - expand*hd/2);
!     font_info->height =
        font_info->max_bounds.ascent + font_info->max_bounds.descent;
      font_info->max_bounds.width = lrint (font_info->width);
      font_info->max_bounds.lbearing = lrint (brect.origin.x);
      font_info->max_bounds.rbearing =
--- 661,694 ----
      expand = 0.0; 
      shrink = 1.0;
      hshrink = 1.0;
      /*
      if (expand < 0.0)
        {
!       shrink = 1 + expand;
!       hshrink = 1 + expand / 2.0;
!       expand = 0.0;
        }
!       else
        shrink = hshrink = 1.0;
      */
  
      font_info->underpos = 2; /*[sfont underlinePosition] is often clipped out */
      font_info->underwidth = [sfont underlineThickness];
      font_info->size = font->pixel_size;
!     font_info->voffset = lrint ( hshrink * [sfont ascender] + expand*hd/2);
  
      /* max bounds */
      font_info->max_bounds.ascent =
        lrint (hshrink * [sfont ascender] + expand * hd/2);
      font_info->max_bounds.descent =
!       -lrint (hshrink* [sfont descender] - expand * hd/2);
! 
! //     font_info->max_bounds.ascent =  lrint ( [sfont ascender] );
! //     font_info->max_bounds.descent = -lrint ( [sfont descender] );
! 
!     font_info->height = 
        font_info->max_bounds.ascent + font_info->max_bounds.descent;
+     
      font_info->max_bounds.width = lrint (font_info->width);
      font_info->max_bounds.lbearing = lrint (brect.origin.x);
      font_info->max_bounds.rbearing =
*** src/nsmenu.m	6 Mar 2009 19:06:45 -0000	1.21
--- src/nsmenu.m	15 Mar 2009 20:40:40 -0000
***************
*** 1187,1192 ****
--- 1191,1199 ----
  {
    int i;
    EmacsToolbar *toolbar = [FRAME_NS_VIEW (f) toolbar];
+ #ifdef NS_IMPL_COCOA
+   NSDisableScreenUpdates ();
+ #endif
  
    [toolbar clearActive];
  
***************
*** 1270,1275 ****
--- 1303,1311 ----
        [toolbar setConfigurationFromDictionary: newDict];
        [newDict release];
      }
+ #ifdef NS_IMPL_COCOA
+   NSEnableScreenUpdates ();
+ #endif
  
  }
  
***************
*** 1882,1891 ****
    int ret;
  
    /* initiate a session that will be ended by pop_down_menu */
!   popupSession = [NSApp beginModalSessionForWindow: self];
!   while (popup_activated_flag
!          && (ret = [NSApp runModalSession: popupSession])
!               == NSRunContinuesResponse)
      {
        /* Run this for timers.el, indep of atimers; might not return.
           TODO: use return value to avoid calling every iteration. */
--- 1954,1973 ----
    int ret;
  
    /* initiate a session that will be ended by pop_down_menu */
!    popupSession = [NSApp beginModalSessionForWindow: self];
! // [NSApp beginSheet:self modalForWindow:self
! //        modalDelegate:self didEndSelector:NULL contextInfo:nil];
! 
! //   while (popup_activated_flag
!             
! // 	 )
! /* need to get window - perhaps simply window under p?
!    ideally just change this method signature so we get a real
!    window (or frame) from teh caller */
! 
!    while (popup_activated_flag
! 	  && (ret = [NSApp runModalSession: popupSession])
! 	  == NSRunContinuesResponse)
      {
        /* Run this for timers.el, indep of atimers; might not return.
           TODO: use return value to avoid calling every iteration. */
*** src/nsterm.m	14 Mar 2009 21:20:09 -0000	1.67
--- src/nsterm.m	15 Mar 2009 20:40:43 -0000
***************
*** 543,548 ****
--- 546,555 ----
    NSView *view = FRAME_NS_VIEW (f);
    NSTRACE (ns_update_begin);
  
+ #ifdef NS_IMPL_COCOA
+   NSDisableScreenUpdates ();
+ #endif
+ 
    ns_updating_frame = f;
    [view lockFocus];
  
***************
*** 563,578 ****
--- 570,592 ----
    struct ns_display_info *dpyinfo = FRAME_NS_DISPLAY_INFO (f);
    NSTRACE (ns_update_window_begin);
  
+ #ifdef NS_IMPL_COCOA
+   NSDisableScreenUpdates ();
+ #endif
+ 
+ 
    updated_window = w;
    set_output_cursor (&w->cursor);
  
    BLOCK_INPUT;
  
+   printf("upd window begin \n");
    if (f == dpyinfo->mouse_face_mouse_frame)
      {
        /* Don't do highlighting for mouse motion during the update.  */
        dpyinfo->mouse_face_defer = 1;
  
+       printf("MDF! \n");
          /* If the frame needs to be redrawn,
             simply forget about any prior mouse highlighting.  */
        if (FRAME_GARBAGED_P (f))
***************
*** 595,600 ****
--- 609,619 ----
  {
    struct ns_display_info *dpyinfo = FRAME_NS_DISPLAY_INFO (XFRAME (w->frame));
  
+ #ifdef NS_IMPL_COCOA
+   NSEnableScreenUpdates ();
+ #endif
+ 
+ 
    /* note: this fn is nearly identical in all terms */
    if (!w->pseudo_window_p)
      {
***************
*** 633,640 ****
     -------------------------------------------------------------------------- */
  {
    NSView *view = FRAME_NS_VIEW (f);
  
! /*   if (f == FRAME_NS_DISPLAY_INFO (f)->mouse_face_mouse_frame) */
      FRAME_NS_DISPLAY_INFO (f)->mouse_face_defer = 0;
  
    BLOCK_INPUT;
--- 652,664 ----
     -------------------------------------------------------------------------- */
  {
    NSView *view = FRAME_NS_VIEW (f);
+ #ifdef NS_IMPL_COCOA
+   NSEnableScreenUpdates ();
+ #endif
+   
  
!   if (f == FRAME_NS_DISPLAY_INFO (f)->mouse_face_mouse_frame) 
!     /* Mouse highlight may be displayed again.  */
      FRAME_NS_DISPLAY_INFO (f)->mouse_face_defer = 0;
  
    BLOCK_INPUT;
***************
*** 649,654 ****
--- 673,679 ----
    [view unlockFocus];
    [[view window] flushWindow];
  
+ 
    UNBLOCK_INPUT;
    ns_updating_frame = NULL;
    NSTRACE (ns_update_end);
***************
*** 678,683 ****
--- 703,709 ----
     -------------------------------------------------------------------------- */
  {
  //  NSTRACE (ns_focus);
+  
  #ifdef NS_IMPL_GNUSTEP
    NSRect u;
      if (n == 2)
***************
*** 690,695 ****
--- 716,722 ----
     if (r) fprintf (stderr, " (%.0f, %.0f : %.0f x %.0f)", r->origin.x, r->origin.y, r->size.width, r->size.height);
     fprintf (stderr, "\n"); */
  
+ 
    if (f != ns_updating_frame)
      {
        NSView *view = FRAME_NS_VIEW (f);
***************
*** 731,736 ****
--- 758,764 ----
      }
  #endif
  
+ 
    /* clipping */
    if (r)
      {
***************
*** 751,757 ****
     -------------------------------------------------------------------------- */
  {
  //  NSTRACE (ns_unfocus);
- 
    if (gsaved)
      {
        [[NSGraphicsContext currentContext] restoreGraphicsState];
--- 779,784 ----
***************
*** 762,769 ****
      {
        if (focus_view != NULL)
          {
!           [focus_view unlockFocus];
!           [[focus_view window] flushWindow];
            focus_view = NULL;
  /*debug_lock--; */
          }
--- 789,796 ----
      {
        if (focus_view != NULL)
          {
! 	  [focus_view unlockFocus];
! 	  [[focus_view window] flushWindow];
            focus_view = NULL;
  /*debug_lock--; */
          }
***************
*** 1123,1133 ****
         && oldTB == tb))
      return;
  
! /*fprintf (stderr, "\tsetWindowSize: %d x %d, font size %d x %d\n", cols, rows, FRAME_COLUMN_WIDTH (f), FRAME_LINE_HEIGHT (f)); */
  
    BLOCK_INPUT;
  
    check_frame_size (f, &rows, &cols);
    oldF = f;
    oldRows = rows;
    oldCols = cols;
--- 1150,1162 ----
         && oldTB == tb))
      return;
  
! fprintf (stderr, "\tsetWindowSize: %d x %d, font size %d x %d\n", cols, rows, FRAME_COLUMN_WIDTH (f), FRAME_LINE_HEIGHT (f)); 
  
    BLOCK_INPUT;
  
    check_frame_size (f, &rows, &cols);
+ 
+ 
    oldF = f;
    oldRows = rows;
    oldCols = cols;
***************
*** 1843,1849 ****
    if (FRAME_NS_P (f))
      {
        struct ns_display_info *dpyinfo = FRAME_NS_DISPLAY_INFO (f);
!       if ((dpyinfo->mouse_face_deferred_gc||f ==dpyinfo->mouse_face_mouse_frame)
        /*&& dpyinfo->mouse_face_mouse_frame*/)
          {
            BLOCK_INPUT;
--- 1878,1884 ----
    if (FRAME_NS_P (f))
      {
        struct ns_display_info *dpyinfo = FRAME_NS_DISPLAY_INFO (f);
!       if ((dpyinfo->mouse_face_deferred_gc  ||f ==dpyinfo->mouse_face_mouse_frame)
        /*&& dpyinfo->mouse_face_mouse_frame*/)
          {
            BLOCK_INPUT;
***************
*** 1965,1974 ****
    r = [view bounds];
  
    BLOCK_INPUT;
!   ns_focus (f, &r, 1);
    [ns_lookup_indexed_color (NS_FACE_BACKGROUND (FRAME_DEFAULT_FACE (f)), f) set];
    NSRectFill (r);
!   ns_unfocus (f);
  
  #ifdef NS_IMPL_COCOA
    [[view window] display];  /* redraw resize handle */
--- 2000,2009 ----
    r = [view bounds];
  
    BLOCK_INPUT;
!   //  ns_focus (f, &r, 1);
    [ns_lookup_indexed_color (NS_FACE_BACKGROUND (FRAME_DEFAULT_FACE (f)), f) set];
    NSRectFill (r);
!   //ns_unfocus (f);
  
  #ifdef NS_IMPL_COCOA
    [[view window] display];  /* redraw resize handle */
***************
*** 2028,2034 ****
    }
  #endif
  
!   ns_unfocus (f);
    return;
  }
  
--- 2071,2077 ----
    }
  #endif
  
!   // ns_unfocus (f);
    return;
  }
  
***************
*** 4964,4970 ****
  /* normalize frame to gridded text size */
  {
    NSTRACE (windowWillResize);
! /*fprintf (stderr,"Window will resize: %.0f x %.0f\n",frameSize.width,frameSize.height); */
  
    cols = FRAME_PIXEL_WIDTH_TO_TEXT_COLS (emacsframe,
  #ifdef NS_IMPL_GNUSTEP
--- 5062,5072 ----
  /* normalize frame to gridded text size */
  {
    NSTRACE (windowWillResize);
! fprintf (stderr,"Windoaw will resize: %.0f x %.0f\n",frameSize.width,frameSize.height); 
! 
! #ifdef NS_IMPL_COCOA
!   NSDisableScreenUpdates ();
! #endif
  
    cols = FRAME_PIXEL_WIDTH_TO_TEXT_COLS (emacsframe,
  #ifdef NS_IMPL_GNUSTEP
***************
*** 4989,4994 ****
--- 5091,5097 ----
    frameSize.height = FRAME_TEXT_LINES_TO_PIXEL_HEIGHT (emacsframe, rows)
                         + FRAME_NS_TITLEBAR_HEIGHT (emacsframe)
                         + FRAME_NS_TOOLBAR_HEIGHT (emacsframe);
+ #if 0
  #ifdef NS_IMPL_COCOA
    {
      /* this sets window title to have size in it; the wm does this under GS */
***************
*** 5022,5028 ****
        }
    }
  #endif /* NS_IMPL_COCOA */
! /*fprintf (stderr,"    ...size became %.0f x %.0f  (%d x %d)\n",frameSize.width,frameSize.height,cols,rows); */
  
    return frameSize;
  }
--- 5125,5132 ----
        }
    }
  #endif /* NS_IMPL_COCOA */
! #endif /* if 0 */
! fprintf (stderr,"    ...size became %.0f x %.0f  (%d x %d)\n",frameSize.width,frameSize.height,cols,rows); 
  
    return frameSize;
  }
***************
*** 5031,5037 ****
  - (void)windowDidResize: (NSNotification *)notification
  {
    NSWindow *theWindow = [notification object];
- 
  #ifdef NS_IMPL_GNUSTEP
     /* in GNUstep, at least currently, it's possible to get a didResize
        without getting a willResize.. therefore we need to act as if we got
--- 5135,5140 ----
***************
*** 5043,5060 ****
    NSTRACE (windowDidResize);
  /*fprintf (stderr,"windowDidResize: %.0f\n",[theWindow frame].size.height); */
  
- #ifdef NS_IMPL_COCOA
-   if (old_title != 0)
-     {
-       xfree (old_title);
-       old_title = 0;
-     }
- #endif /* NS_IMPL_COCOA */
- 
    if (cols > 0 && rows > 0)
      x_set_window_size (emacsframe, 0, cols, rows);
  
    ns_send_appdefined (-1);
  }
  
  
--- 5146,5159 ----
    NSTRACE (windowDidResize);
  /*fprintf (stderr,"windowDidResize: %.0f\n",[theWindow frame].size.height); */
  
    if (cols > 0 && rows > 0)
      x_set_window_size (emacsframe, 0, cols, rows);
  
    ns_send_appdefined (-1);
+ 
+ #ifdef NS_IMPL_COCOA
+   NSEnableScreenUpdates ();
+ #endif
  }
  
  
***************
*** 6089,6094 ****
--- 6188,6381 ----
  
  
  
+ #if 0
+ /* ==========================================================================
+ 
+     EmacsPrefsController implementation
+ 
+    ========================================================================== */
+ 
+ 
+ @implementation EmacsPrefsController
+ 
+ /* in Tiger+, can just do [popup selectItemWithTag: tag]; */
+ static void selectItemWithTag (NSPopUpButton *popup, int tag)
+ {
+   NSEnumerator *items = [[popup itemArray] objectEnumerator];
+   NSMenuItem *item;
+   while (item = [items nextObject])
+     {
+       if ([item tag] == tag)
+         {
+           [popup selectItem: item];
+           return;
+         }
+     }
+ }
+ 
+ - init
+ {
+   [NSBundle loadNibNamed: @"preferences" owner: self];
+   return self;
+ }
+ 
+ 
+ - (void) showForFrame: (struct frame *)f
+ {
+   frame = f;
+   [self setPanelFromValues];
+   [prefsWindow makeKeyAndOrderFront: self];
+   [prefsWindow display];
+ }
+ 
+ 
+ /* If you change this, change setPanelFromDefaultValues too. */
+ - (void) setPanelFromValues
+ {
+   int cursorType
+     = ns_lisp_to_cursor_type (get_frame_param (frame, Qcursor_type));
+ 
+ #ifdef NS_IMPL_COCOA
+   prevUseHighlightColor = ns_use_system_highlight_color;
+ #endif
+ 
+   [expandSpaceSlider setFloatValue: 0.0];
+   [cursorTypeMatrix selectCellWithTag: (cursorType == FILLED_BOX_CURSOR ? 1 :
+                                         (cursorType == BAR_CURSOR ? 2 :
+                                          (cursorType == HBAR_CURSOR ? 3 : 4)))];
+   selectItemWithTag (alternateModMenu,
+ 		     parse_solitary_modifier (ns_alternate_modifier));
+   selectItemWithTag (commandModMenu,
+ 		     parse_solitary_modifier (ns_command_modifier));
+ #ifdef NS_IMPL_COCOA
+   selectItemWithTag (controlModMenu,
+ 		     parse_solitary_modifier (ns_control_modifier));
+   selectItemWithTag (functionModMenu,
+ 		     parse_solitary_modifier (ns_function_modifier));
+   [smoothFontsCheck setState: (NILP (ns_antialias_text) ? NO : YES)];
+   [useQuickdrawCheck setState: (NILP (ns_use_qd_smoothing) ? NO : YES)];
+   [useSysHiliteCheck setState: (NILP (prevUseHighlightColor) ? NO : YES)];
+   [confirmQuitCheck setState: (NILP (ns_confirm_quit) ? NO : YES)];
+ #endif
+ }
+ 
+ 
+ /* This and ns_set_default_prefs should be changed together. */
+ - (void) setPanelFromDefaultValues
+ {
+   [expandSpaceSlider setFloatValue: 0.0];
+   [cursorTypeMatrix selectCellWithTag: 1]; /* filled box */
+   selectItemWithTag (alternateModMenu, meta_modifier);
+   selectItemWithTag (commandModMenu, super_modifier);
+ #ifdef NS_IMPL_COCOA
+   selectItemWithTag (controlModMenu, ctrl_modifier);
+   selectItemWithTag (functionModMenu, 0); /* none */
+   [smoothFontsCheck setState: YES];
+   [useQuickdrawCheck setState: NO];
+   [useSysHiliteCheck setState: YES];
+ #endif
+ }
+ 
+ 
+ - (void) setValuesFromPanel
+ {
+   int altTag = [[alternateModMenu selectedItem] tag];
+   int cmdTag = [[commandModMenu selectedItem] tag];
+ #ifdef NS_IMPL_COCOA
+   int ctrlTag = [[controlModMenu selectedItem] tag];
+   int fnTag = [[functionModMenu selectedItem] tag];
+ #endif
+   float expandSpace = [expandSpaceSlider floatValue];
+   int cursorTag = [[cursorTypeMatrix selectedCell] tag];
+   Lisp_Object cursor_type = ns_cursor_type_to_lisp
+        ( cursorTag == 1 ? FILLED_BOX_CURSOR
+        : cursorTag == 2 ? BAR_CURSOR
+        : cursorTag == 3 ? HBAR_CURSOR : HOLLOW_BOX_CURSOR);
+ 
+   store_frame_param (frame, Qcursor_type, cursor_type);
+   x_set_cursor_type (frame, cursor_type, Qnil);  /* FIXME: do only if changed */
+ 
+   ns_alternate_modifier = ns_mod_to_lisp (altTag);
+   ns_command_modifier = ns_mod_to_lisp (cmdTag);
+ #ifdef NS_IMPL_COCOA
+   ns_control_modifier = ns_mod_to_lisp (ctrlTag);
+   ns_function_modifier = ns_mod_to_lisp (fnTag);
+   ns_antialias_text = [smoothFontsCheck state] ? Qt : Qnil;
+   ns_use_qd_smoothing = [useQuickdrawCheck state] ? Qt : Qnil;
+   ns_use_system_highlight_color = [useSysHiliteCheck state] ? Qt : Qnil;
+   ns_confirm_quit = [confirmQuitCheck state] ? Qt : Qnil;
+   if (! EQ (ns_use_system_highlight_color, prevUseHighlightColor))
+     {
+       prevUseHighlightColor = ns_use_system_highlight_color;
+       if (EQ (ns_use_system_highlight_color, Qt))
+         {
+           ns_selection_color = [[NSUserDefaults standardUserDefaults]
+                                  stringForKey: @"AppleHighlightColor"];
+           if (ns_selection_color == nil)
+             ns_selection_color = NS_SELECTION_COLOR_DEFAULT;
+         }
+       else
+         ns_selection_color = NS_SELECTION_COLOR_DEFAULT;
+     }
+ #endif /* NS_IMPL_COCOA */
+   Fcall_interactively (intern ("ns-save-preferences"), Qnil, Qnil);
+ }
+ 
+ 
+ /* buttons */
+ - (IBAction)cancel: (id)sender
+ {
+   [prefsWindow close];
+ }
+ 
+ 
+ - (IBAction)ok: (id)sender
+ {
+   [self setValuesFromPanel];
+   [prefsWindow close];
+ }
+ 
+ 
+ - (IBAction)resetToDefaults: (id)sender
+ {
+   [self setPanelFromDefaultValues];
+ }
+ 
+ 
+ - (IBAction)runHelp: (id)sender
+ {
+   struct frame *emacsframe = frame;
+   if (!emacs_event)
+     return;
+   ns_raise_frame(frame);
+   emacs_event->kind = NS_NONKEY_EVENT;
+   emacs_event->code = KEY_NS_INFO_PREFS;
+   EV_TRAILER ((id)nil);
+ }
+ 
+ 
+ - (IBAction)setColors: (id)sender
+ {
+   Lisp_Object lispFrame;
+   XSETFRAME (lispFrame, frame);
+   ns_raise_frame(frame);
+   Fns_popup_color_panel (lispFrame);
+ }
+ 
+ 
+ - (IBAction)setDefaultFont: (id)sender
+ {
+   Lisp_Object lispFrame;
+   XSETFRAME (lispFrame, frame);
+   ns_raise_frame(frame);
+   Fns_popup_font_panel (lispFrame);
+ }
+ 
+ @end  /* EmacsPrefsController */
+ 
+ #endif /* if 0 */
+ 
+ 
  /* ==========================================================================
  
     Font-related functions; these used to be in nsfaces.m
***************
*** 6253,6258 ****
--- 6540,6548 ----
    DEFVAR_LISP ("ns-antialias-text", &ns_antialias_text,
                 "Non-nil (the default) means to render text antialiased. Only has an effect on OS X Panther and above.");
  
+ //   DEFVAR_LISP ("ns-antialias-threshold", &ns_antialias_threshold,
+ //                "Minimum font size for antialiasing. Only has an effect on OS X Panther and above.");
+ 
    DEFVAR_LISP ("ns-use-qd-smoothing", &ns_use_qd_smoothing,
                 "Whether to render text using QuickDraw (less heavy) antialiasing. Only has an effect on OS X Panther and above.  Default is nil (use Quartz smoothing).");
  
