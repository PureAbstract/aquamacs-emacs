ensures that only the right window is deleted.
this way it interacts better with other code that
deletes the window as well (from kill-buffer-hook)
*** lisp/window.el	06 Apr 2008 12:51:37 +0100	1.120.2.5
--- lisp/window.el	21 May 2008 18:57:42 +0100	
***************
*** 716,744 ****
  	(fit-window-to-buffer window (window-height window)))))
  
  (defun kill-buffer-and-window ()
!   "Kill the current buffer and delete the selected window."
!   (interactive)
!   (let ((window-to-delete (selected-window))
  	(buffer-to-kill (current-buffer))
  	(delete-window-hook (lambda ()
  			      (condition-case nil
! 				  (delete-window)
  				(error nil)))))
!     (unwind-protect
  	(progn
  	  (add-hook 'kill-buffer-hook delete-window-hook t t)
  	  (if (kill-buffer (current-buffer))
  	      ;; If `delete-window' failed before, we rerun it to regenerate
  	      ;; the error so it can be seen in the echo area.
  	      (when (eq (selected-window) window-to-delete)
! 		(delete-window))))
!       ;; If the buffer is not dead for some reason (probably because
!       ;; of a `quit' signal), remove the hook again.
!       (condition-case nil
  	  (with-current-buffer buffer-to-kill
  	    (remove-hook 'kill-buffer-hook delete-window-hook t))
  	(error nil)))))
  
  (defun quit-window (&optional kill window)
    "Quit the current buffer.  Bury it, and maybe delete the selected frame.
  \(The frame is deleted if it contains a dedicated window for the buffer.)
--- 716,747 ----
  	(fit-window-to-buffer window (window-height window)))))
  
  (defun kill-buffer-and-window ()
!  "Kill the current buffer and delete the selected window."
!  (interactive)
!  (let ((window-to-delete (selected-window))
  	(buffer-to-kill (current-buffer))
  	(delete-window-hook (lambda ()
  			      (condition-case nil
! 				  (if (eq (window-buffer) buffer-to-kill)
! 				      (delete-window))
  				(error nil)))))
!    (unwind-protect
  	(progn
  	  (add-hook 'kill-buffer-hook delete-window-hook t t)
  	  (if (kill-buffer (current-buffer))
  	      ;; If `delete-window' failed before, we rerun it to regenerate
  	      ;; the error so it can be seen in the echo area.
  	      (when (eq (selected-window) window-to-delete)
! 		(if (eq (window-buffer) buffer-to-kill)
! 		    (delete-window)))))
!      ;; If the buffer is not dead for some reason (probably because
!      ;; of a `quit' signal), remove the hook again.
!      (condition-case nil
  	  (with-current-buffer buffer-to-kill
  	    (remove-hook 'kill-buffer-hook delete-window-hook t))
  	(error nil)))))
  
+ 
  (defun quit-window (&optional kill window)
    "Quit the current buffer.  Bury it, and maybe delete the selected frame.
  \(The frame is deleted if it contains a dedicated window for the buffer.)
