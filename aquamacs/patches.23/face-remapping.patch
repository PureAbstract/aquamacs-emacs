*** src/xfaces.c	24 Feb 2009 03:39:58 -0000	1.431
--- src/xfaces.c	15 Mar 2009 20:41:25 -0000
***************
*** 444,449 ****
--- 444,466 ----
  
  Lisp_Object Vface_remapping_alist;
  
+ /* Alist of face remappings.  Each element is of the form:
+    (FACE REPLACEMENT...) which causes display of the face FACE to use
+    REPLACEMENT... instead.  REPLACEMENT... is interpreted the same way
+    the value of a `face' text property is: it may be (1) A face name,
+    (2) A list of face names, (3) A property-list of face attribute/value
+    pairs, or (4) A list of face names intermixed with lists containing
+    face attribute/value pairs.
+ 
+    Multiple entries in REPLACEMENT... are merged together to form the final
+    result, with faces or attributes earlier in the list taking precedence
+    over those that are later.
+ 
+    Face-name remapping cycles are suppressed; recursive references use
+    the underlying face instead of the remapped face.  */
+ 
+ Lisp_Object Vface_remapping_alist;
+ 
  /* The next ID to assign to Lisp faces.  */
  
  static int next_lface_id;
***************
*** 2852,2857 ****
--- 2869,2875 ----
  
    xassert (LFACEP (lface));
    check_lface (lface);
+ 
    return lface;
  }
  
***************
*** 4828,4833 ****
--- 4846,4907 ----
    return remapped_face_id;
  }
  
+ int
+ lookup_basic_face_for_buffer (f, face_id, buffer)
+      struct frame *f;
+      int face_id;
+      Lisp_Object buffer;
+ {
+   Lisp_Object name, mapping;
+   int remapped_face_id;
+ 
+   Lisp_Object Vlocal_remapping_alist = Fbuffer_local_value (intern("face-remapping-alist"), buffer);
+ 
+ 
+   if (NILP (Vlocal_remapping_alist))
+     return face_id;		/* Nothing to do.  */
+ 
+   switch (face_id)
+     {
+     case DEFAULT_FACE_ID:		name = Qdefault;		break;
+     case MODE_LINE_FACE_ID:		name = Qmode_line;		break;
+     case MODE_LINE_INACTIVE_FACE_ID:	name = Qmode_line_inactive;	break;
+     case HEADER_LINE_FACE_ID:		name = Qheader_line;		break;
+     case TOOL_BAR_FACE_ID:		name = Qtool_bar;		break;
+     case FRINGE_FACE_ID:		name = Qfringe;			break;
+     case SCROLL_BAR_FACE_ID:		name = Qscroll_bar;		break;
+     case BORDER_FACE_ID:		name = Qborder;			break;
+     case CURSOR_FACE_ID:		name = Qcursor;			break;
+     case MOUSE_FACE_ID:			name = Qmouse;			break;
+     case MENU_FACE_ID:			name = Qmenu;			break;
+ 
+     default:
+       abort ();	    /* the caller is supposed to pass us a basic face id */
+     }
+ 
+   /* Do a quick scan through Vface_remapping_alist, and return immediately
+      if there is no remapping for face NAME.  This is just an optimization
+      for the very common no-remapping case.  */
+   mapping = assq_no_quit (name, Vlocal_remapping_alist);
+   if (NILP (mapping))
+     return face_id;		/* Give up.  */
+ 
+   /* If there is a remapping entry, lookup the face using NAME, which will
+      handle the remapping too. 
+      Avoid setting current buffer (slow).
+   */
+   Lisp_Object old_face_remapping_alist = Vface_remapping_alist;
+   Vface_remapping_alist = Vlocal_remapping_alist;
+ 
+   remapped_face_id = lookup_named_face (f, name, 0);
+   Vface_remapping_alist = old_face_remapping_alist;
+ 
+   if (remapped_face_id < 0)
+     return face_id;		/* Give up. */
+ 
+   return remapped_face_id;
+ }
+ 
  
  /* Return the ID of the realized ASCII face of Lisp face with ID
     LFACE_ID on frame F.  Value is -1 if LFACE_ID isn't valid.  */
***************
*** 6982,6987 ****
--- 7056,7098 ----
          '((default my-mode-default)))).  */);
    Vface_remapping_alist = Qnil;
  
+   DEFVAR_LISP ("face-remapping-alist", &Vface_remapping_alist,
+ 	       doc: /* Alist of face remappings.
+ Each element is of the form:
+ 
+    (FACE REPLACEMENT...),
+ 
+ which causes display of the face FACE to use REPLACEMENT... instead.
+ REPLACEMENT... is interpreted the same way the value of a `face' text
+ property is: it may be (1) A face name, (2) A list of face names, (3) A
+ property-list of face attribute/value pairs, or (4) A list of face names
+ intermixed with lists containing face attribute/value pairs.
+ 
+ Multiple entries in REPLACEMENT... are merged together to form the final
+ result, with faces or attributes earlier in the list taking precedence
+ over those that are later.
+ 
+ Face-name remapping cycles are suppressed; recursive references use the
+ underlying face instead of the remapped face.  So a remapping of the form:
+ 
+    (FACE EXTRA-FACE... FACE)
+ 
+ or:
+ 
+    (FACE (FACE-ATTR VAL ...) FACE)
+ 
+ will cause EXTRA-FACE... or (FACE-ATTR VAL ...) to be _merged_ with the
+ existing definition of FACE.  Note that for the default face, this isn't
+ necessary, as every face inherits from the default face.
+ 
+ Making this variable buffer-local is a good way to allow buffer-specific
+ face definitions.  For instance, the mode my-mode could define a face
+ `my-mode-default', and then in the mode setup function, do:
+ 
+    (set (make-local-variable 'face-remapping-alist)
+         '((default my-mode-default)))).  */);
+   Vface_remapping_alist = Qnil;
+ 
    DEFVAR_LISP ("face-font-rescale-alist", &Vface_font_rescale_alist,
  	       doc: /* Alist of fonts vs the rescaling factors.
  Each element is a cons (FONT-PATTERN . RESCALE-RATIO), where
*** src/fringe.c	8 Jan 2009 03:15:40 -0000	1.55
--- src/fringe.c	15 Mar 2009 20:40:17 -0000
***************
*** 589,594 ****
--- 589,598 ----
  	face_id = FRINGE_FACE_ID;
      }
  
+   /* Perhaps remap BASE_FACE_ID to a user-specified alternative.  */
+   if (face_id == FRINGE_FACE_ID || face_id == DEFAULT_FACE_ID)
+     face_id = lookup_basic_face_for_buffer (XFRAME (w->frame), face_id, w->buffer);
+ 
    fb = fringe_bitmaps[which];
    if (fb == NULL)
      fb = &standard_bitmaps[which < MAX_STANDARD_FRINGE_BITMAPS
***************
*** 884,894 ****
    if (row->visible_height <= 0)
      return;
  
!   if (WINDOW_LEFT_FRINGE_WIDTH (w) != 0)
      draw_fringe_bitmap (w, row, 1);
  
!   if (WINDOW_RIGHT_FRINGE_WIDTH (w) != 0)
!     draw_fringe_bitmap (w, row, 0);
  }
  
  /* Draw the fringes of window W.  Only fringes for rows marked for
--- 888,902 ----
    if (row->visible_height <= 0)
      return;
  
!   if (WINDOW_LEFT_FRINGE_WIDTH (w) != 0) /* keep, due to C-x 3 w/o scroll-b and fringe bug*/
      draw_fringe_bitmap (w, row, 1);
  
!   /* always draw the fringe, even if it is turned off:
!      this will fill an otherwise empty (background) between
!      window and scrollbar */
!   /*  if (WINDOW_RIGHT_FRINGE_WIDTH (w) != 0) */
! 
!   draw_fringe_bitmap (w, row, 0);
  }
  
  /* Draw the fringes of window W.  Only fringes for rows marked for
***************
*** 1071,1077 ****
        if (!row->enabled_p)
  	row = cur;
  
!       left_face_id = right_face_id = DEFAULT_FACE_ID;
  
        /* Decide which bitmap to draw in the left fringe.  */
        if (WINDOW_LEFT_FRINGE_WIDTH (w) == 0)
--- 1079,1085 ----
        if (!row->enabled_p)
  	row = cur;
  
!       left_face_id = right_face_id = FRINGE_FACE_ID; /* takes priority if customized */
  
        /* Decide which bitmap to draw in the left fringe.  */
        if (WINDOW_LEFT_FRINGE_WIDTH (w) == 0)
***************
*** 1127,1132 ****
--- 1135,1146 ----
        else
  	right = NO_FRINGE_BITMAP;
  
+       /* Perhaps remap BASE_FACE_ID to a user-specified alternative.  */
+       if (left_face_id == FRINGE_FACE_ID || left_face_id == DEFAULT_FACE_ID)
+ 	left_face_id = lookup_basic_face_for_buffer (XFRAME (w->frame), left_face_id, w->buffer);
+       if (right_face_id == FRINGE_FACE_ID || right_face_id == DEFAULT_FACE_ID)
+ 	right_face_id = lookup_basic_face_for_buffer (XFRAME (w->frame), right_face_id, w->buffer);
+ 	
        if (row->y != cur->y
  	  || row->visible_height != cur->visible_height
  	  || row->ends_at_zv_p != cur->ends_at_zv_p
*** src/dispnew.c	30 Jan 2009 23:45:29 -0000	1.427
--- src/dispnew.c	15 Mar 2009 20:40:03 -0000
***************
*** 4428,4437 ****
    /* Let functions in xterm.c know what area subsequent X positions
       will be relative to.  */
    updated_area = TEXT_AREA;
- 
    /* If rows are at different X or Y, or rows have different height,
       or the current row is marked invalid, write the entire line.  */
!   if (!current_row->enabled_p
        || desired_row->y != current_row->y
        || desired_row->ascent != current_row->ascent
        || desired_row->phys_ascent != current_row->phys_ascent
--- 4428,4439 ----
    /* Let functions in xterm.c know what area subsequent X positions
       will be relative to.  */
    updated_area = TEXT_AREA;
    /* If rows are at different X or Y, or rows have different height,
       or the current row is marked invalid, write the entire line.  */
!   if (!desired_row->displays_text_p   
! 	    /* window background needs to be drawn using    
! 	     clear_end_of_line, under the visible buffer text.   */
!       ||  !current_row->enabled_p
        || desired_row->y != current_row->y
        || desired_row->ascent != current_row->ascent
        || desired_row->phys_ascent != current_row->phys_ascent
*** src/xdisp.c	14 Feb 2009 17:28:08 -0000	1.1277
--- src/xdisp.c	15 Mar 2009 20:41:22 -0000
***************
*** 2610,2621 ****
    if (base_face_id == DEFAULT_FACE_ID
        && FRAME_WINDOW_P (it->f))
      {
!       if (NATNUMP (current_buffer->extra_line_spacing))
  	it->extra_line_spacing = XFASTINT (current_buffer->extra_line_spacing);
        else if (FLOATP (current_buffer->extra_line_spacing))
  	it->extra_line_spacing = (XFLOAT_DATA (current_buffer->extra_line_spacing)
  				  * FRAME_LINE_HEIGHT (it->f));
!       else if (it->f->extra_line_spacing > 0)
  	it->extra_line_spacing = it->f->extra_line_spacing;
        it->max_extra_line_spacing = 0;
      }
--- 2610,2621 ----
    if (base_face_id == DEFAULT_FACE_ID
        && FRAME_WINDOW_P (it->f))
      {
!       if (INTEGERP (current_buffer->extra_line_spacing))
  	it->extra_line_spacing = XFASTINT (current_buffer->extra_line_spacing);
        else if (FLOATP (current_buffer->extra_line_spacing))
  	it->extra_line_spacing = (XFLOAT_DATA (current_buffer->extra_line_spacing)
  				  * FRAME_LINE_HEIGHT (it->f));
!       else if (it->f->extra_line_spacing != 0)
  	it->extra_line_spacing = it->f->extra_line_spacing;
        it->max_extra_line_spacing = 0;
      }
***************
*** 16166,16172 ****
  	  it->len = 1;
  
  	  if (default_face_p)
! 	    it->face_id = DEFAULT_FACE_ID;
  	  else if (it->face_before_selective_p)
  	    it->face_id = it->saved_face_id;
  	  face = FACE_FROM_ID (it->f, it->face_id);
--- 16166,16172 ----
  	  it->len = 1;
  
  	  if (default_face_p)
! 	    it->face_id = lookup_basic_face (it->f, DEFAULT_FACE_ID); 
  	  else if (it->face_before_selective_p)
  	    it->face_id = it->saved_face_id;
  	  face = FACE_FROM_ID (it->f, it->face_id);
***************
*** 23651,23661 ****
    if (NILP (Vmouse_highlight)
        || !f->glyphs_initialized_p)
      return;
- 
    dpyinfo->mouse_face_mouse_x = x;
    dpyinfo->mouse_face_mouse_y = y;
    dpyinfo->mouse_face_mouse_frame = f;
  
    if (dpyinfo->mouse_face_defer)
      return;
  
--- 23651,23662 ----
    if (NILP (Vmouse_highlight)
        || !f->glyphs_initialized_p)
      return;
    dpyinfo->mouse_face_mouse_x = x;
    dpyinfo->mouse_face_mouse_y = y;
    dpyinfo->mouse_face_mouse_frame = f;
  
+   // printf("note_mouse_highlight %d\n", dpyinfo->mouse_face_defer);
+ 
    if (dpyinfo->mouse_face_defer)
      return;
  
*** src/nsterm.m	14 Mar 2009 21:20:09 -0000	1.67
--- src/nsterm.m	15 Mar 2009 20:40:43 -0000
***************
*** 1979,1984 ****
--- 2014,2020 ----
    UNBLOCK_INPUT;
  }
  
+ extern struct buffer *current_buffer;
  
  void
  ns_clear_frame_area (struct frame *f, int x, int y, int width, int height)
***************
*** 1992,2002 ****
  
    if (!view || !face)
      return;
- 
    NSTRACE (ns_clear_frame_area);
  
    r = NSIntersectionRect (r, [view frame]);
!   ns_focus (f, &r, 1);
    [ns_lookup_indexed_color (NS_FACE_BACKGROUND (face), f) set];
  
  #ifdef NS_IMPL_COCOA
--- 2028,2045 ----
  
    if (!view || !face)
      return;
    NSTRACE (ns_clear_frame_area);
  
+   if (updated_window)
+     if (current_buffer && XBUFFER (updated_window->buffer) != current_buffer)
+       face = FACE_FROM_ID 
+ 	(f, lookup_basic_face_for_buffer (f, DEFAULT_FACE_ID, 
+ 					  updated_window->buffer) );
+     else
+       face = FACE_FROM_ID (f, lookup_basic_face (f, DEFAULT_FACE_ID) );
+ 
    r = NSIntersectionRect (r, [view frame]);
!   // ns_focus (f, &r, 1);
    [ns_lookup_indexed_color (NS_FACE_BACKGROUND (face), f) set];
  
  #ifdef NS_IMPL_COCOA
