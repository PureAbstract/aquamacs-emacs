This patch adds face-remapping support for fringe faces and colors portions of windows not previously drawn in the "default" face background color.


Index: xfaces.c
===================================================================
RCS file: /sources/emacs/emacs/src/xfaces.c,v
retrieving revision 1.431
diff -c -r1.431 xfaces.c
*** src/xfaces.c	24 Feb 2009 03:39:58 -0000	1.431
--- src/xfaces.c	8 Mar 2009 21:44:43 -0000
***************
*** 444,449 ****
--- 444,466 ----
  
  Lisp_Object Vface_remapping_alist;
  
+ /* Alist of face remappings.  Each element is of the form:
+    (FACE REPLACEMENT...) which causes display of the face FACE to use
+    REPLACEMENT... instead.  REPLACEMENT... is interpreted the same way
+    the value of a `face' text property is: it may be (1) A face name,
+    (2) A list of face names, (3) A property-list of face attribute/value
+    pairs, or (4) A list of face names intermixed with lists containing
+    face attribute/value pairs.
+ 
+    Multiple entries in REPLACEMENT... are merged together to form the final
+    result, with faces or attributes earlier in the list taking precedence
+    over those that are later.
+ 
+    Face-name remapping cycles are suppressed; recursive references use
+    the underlying face instead of the remapped face.  */
+ 
+ Lisp_Object Vface_remapping_alist;
+ 
  /* The next ID to assign to Lisp faces.  */
  
  static int next_lface_id;
***************
*** 2852,2857 ****
--- 2869,2875 ----
  
    xassert (LFACEP (lface));
    check_lface (lface);
+ 
    return lface;
  }
  
***************
*** 4828,4833 ****
--- 4846,4907 ----
    return remapped_face_id;
  }
  
+ int
+ lookup_basic_face_for_buffer (f, face_id, buffer)
+      struct frame *f;
+      int face_id;
+      Lisp_Object buffer;
+ {
+   Lisp_Object name, mapping;
+   int remapped_face_id;
+ 
+   Lisp_Object Vlocal_remapping_alist = Fbuffer_local_value (intern("face-remapping-alist"), buffer);
+ 
+ 
+   if (NILP (Vlocal_remapping_alist))
+     return face_id;		/* Nothing to do.  */
+ 
+   switch (face_id)
+     {
+     case DEFAULT_FACE_ID:		name = Qdefault;		break;
+     case MODE_LINE_FACE_ID:		name = Qmode_line;		break;
+     case MODE_LINE_INACTIVE_FACE_ID:	name = Qmode_line_inactive;	break;
+     case HEADER_LINE_FACE_ID:		name = Qheader_line;		break;
+     case TOOL_BAR_FACE_ID:		name = Qtool_bar;		break;
+     case FRINGE_FACE_ID:		name = Qfringe;			break;
+     case SCROLL_BAR_FACE_ID:		name = Qscroll_bar;		break;
+     case BORDER_FACE_ID:		name = Qborder;			break;
+     case CURSOR_FACE_ID:		name = Qcursor;			break;
+     case MOUSE_FACE_ID:			name = Qmouse;			break;
+     case MENU_FACE_ID:			name = Qmenu;			break;
+ 
+     default:
+       abort ();	    /* the caller is supposed to pass us a basic face id */
+     }
+ 
+   /* Do a quick scan through Vface_remapping_alist, and return immediately
+      if there is no remapping for face NAME.  This is just an optimization
+      for the very common no-remapping case.  */
+   mapping = assq_no_quit (name, Vlocal_remapping_alist);
+   if (NILP (mapping))
+     return face_id;		/* Give up.  */
+ 
+   /* If there is a remapping entry, lookup the face using NAME, which will
+      handle the remapping too. 
+      Avoid setting current buffer (slow).
+   */
+   Lisp_Object old_face_remapping_alist = Vface_remapping_alist;
+   Vface_remapping_alist = Vlocal_remapping_alist;
+ 
+   remapped_face_id = lookup_named_face (f, name, 0);
+   Vface_remapping_alist = old_face_remapping_alist;
+ 
+   if (remapped_face_id < 0)
+     return face_id;		/* Give up. */
+ 
+   return remapped_face_id;
+ }
+ 
  
  /* Return the ID of the realized ASCII face of Lisp face with ID
     LFACE_ID on frame F.  Value is -1 if LFACE_ID isn't valid.  */
***************
*** 6982,6987 ****
--- 7056,7098 ----
          '((default my-mode-default)))).  */);
    Vface_remapping_alist = Qnil;
  
+   DEFVAR_LISP ("face-remapping-alist", &Vface_remapping_alist,
+ 	       doc: /* Alist of face remappings.
+ Each element is of the form:
+ 
+    (FACE REPLACEMENT...),
+ 
+ which causes display of the face FACE to use REPLACEMENT... instead.
+ REPLACEMENT... is interpreted the same way the value of a `face' text
+ property is: it may be (1) A face name, (2) A list of face names, (3) A
+ property-list of face attribute/value pairs, or (4) A list of face names
+ intermixed with lists containing face attribute/value pairs.
+ 
+ Multiple entries in REPLACEMENT... are merged together to form the final
+ result, with faces or attributes earlier in the list taking precedence
+ over those that are later.
+ 
+ Face-name remapping cycles are suppressed; recursive references use the
+ underlying face instead of the remapped face.  So a remapping of the form:
+ 
+    (FACE EXTRA-FACE... FACE)
+ 
+ or:
+ 
+    (FACE (FACE-ATTR VAL ...) FACE)
+ 
+ will cause EXTRA-FACE... or (FACE-ATTR VAL ...) to be _merged_ with the
+ existing definition of FACE.  Note that for the default face, this isn't
+ necessary, as every face inherits from the default face.
+ 
+ Making this variable buffer-local is a good way to allow buffer-specific
+ face definitions.  For instance, the mode my-mode could define a face
+ `my-mode-default', and then in the mode setup function, do:
+ 
+    (set (make-local-variable 'face-remapping-alist)
+         '((default my-mode-default)))).  */);
+   Vface_remapping_alist = Qnil;
+ 
    DEFVAR_LISP ("face-font-rescale-alist", &Vface_font_rescale_alist,
  	       doc: /* Alist of fonts vs the rescaling factors.
  Each element is a cons (FONT-PATTERN . RESCALE-RATIO), where
*** src/fringe.c	07 Sep 2008 16:16:36 -0400	1.44.2.5
--- src/fringe.c	22 Jan 2009 16:26:27 -0500	
***************
*** 590,595 ****
--- 590,599 ----
  	face_id = FRINGE_FACE_ID;
      }
  
+   /* Perhaps remap BASE_FACE_ID to a user-specified alternative.  */
+   if (face_id == FRINGE_FACE_ID || face_id == DEFAULT_FACE_ID)
+     face_id = lookup_basic_face_for_buffer (XFRAME (w->frame), face_id, w->buffer);
+ 
    fb = fringe_bitmaps[which];
    if (fb == NULL)
      fb = &standard_bitmaps[which < MAX_STANDARD_FRINGE_BITMAPS
***************
*** 885,895 ****
    if (row->visible_height <= 0)
      return;
  
!   if (WINDOW_LEFT_FRINGE_WIDTH (w) != 0)
      draw_fringe_bitmap (w, row, 1);
  
!   if (WINDOW_RIGHT_FRINGE_WIDTH (w) != 0)
!     draw_fringe_bitmap (w, row, 0);
  }
  
  /* Draw the fringes of window W.  Only fringes for rows marked for
--- 889,903 ----
    if (row->visible_height <= 0)
      return;
  
!   if (WINDOW_LEFT_FRINGE_WIDTH (w) != 0) /* keep, due to C-x 3 w/o scroll-b and fringe bug*/
      draw_fringe_bitmap (w, row, 1);
  
!   /* always draw the fringe, even if it is turned off:
!      this will fill an otherwise empty (background) between
!      window and scrollbar */
!   /*  if (WINDOW_RIGHT_FRINGE_WIDTH (w) != 0) */
! 
!   draw_fringe_bitmap (w, row, 0);
  }
  
  /* Draw the fringes of window W.  Only fringes for rows marked for
***************
*** 1072,1078 ****
        if (!row->enabled_p)
  	row = cur;
  
!       left_face_id = right_face_id = DEFAULT_FACE_ID;
  
        /* Decide which bitmap to draw in the left fringe.  */
        if (WINDOW_LEFT_FRINGE_WIDTH (w) == 0)
--- 1080,1086 ----
        if (!row->enabled_p)
  	row = cur;
  
!       left_face_id = right_face_id = FRINGE_FACE_ID; /* takes priority if customized */
  
        /* Decide which bitmap to draw in the left fringe.  */
        if (WINDOW_LEFT_FRINGE_WIDTH (w) == 0)
***************
*** 1128,1133 ****
--- 1136,1147 ----
        else
  	right = NO_FRINGE_BITMAP;
  
+       /* Perhaps remap BASE_FACE_ID to a user-specified alternative.  */
+       if (left_face_id == FRINGE_FACE_ID || left_face_id == DEFAULT_FACE_ID)
+ 	left_face_id = lookup_basic_face_for_buffer (XFRAME (w->frame), left_face_id, w->buffer);
+       if (right_face_id == FRINGE_FACE_ID || right_face_id == DEFAULT_FACE_ID)
+ 	right_face_id = lookup_basic_face_for_buffer (XFRAME (w->frame), right_face_id, w->buffer);
+ 	
        if (row->y != cur->y
  	  || row->visible_height != cur->visible_height
  	  || row->ends_at_zv_p != cur->ends_at_zv_p
*** src/dispnew.c	05 May 2008 18:29:44 -0400	1.392.2.3
--- src/dispnew.c	23 Dec 2008 15:56:08 -0500	
***************
*** 4417,4426 ****
    /* Let functions in xterm.c know what area subsequent X positions
       will be relative to.  */
    updated_area = TEXT_AREA;
- 
    /* If rows are at different X or Y, or rows have different height,
       or the current row is marked invalid, write the entire line.  */
!   if (!current_row->enabled_p
        || desired_row->y != current_row->y
        || desired_row->ascent != current_row->ascent
        || desired_row->phys_ascent != current_row->phys_ascent
--- 4418,4429 ----
    /* Let functions in xterm.c know what area subsequent X positions
       will be relative to.  */
    updated_area = TEXT_AREA;
    /* If rows are at different X or Y, or rows have different height,
       or the current row is marked invalid, write the entire line.  */
!   if (!desired_row->displays_text_p   
! 	    /* window background needs to be drawn using    
! 	     clear_end_of_line, under the visible buffer text.   */
!       ||  !current_row->enabled_p
        || desired_row->y != current_row->y
        || desired_row->ascent != current_row->ascent
        || desired_row->phys_ascent != current_row->phys_ascent
Index: xdisp.c
The following stuff adapts the window background color to match 
the bg color of the default face used in the buffer.
===================================================================
RCS file: /sources/emacs/emacs/src/xdisp.c,v
retrieving revision 1.1149.2.33
diff -c -r1.1149.2.33 xdisp.c
*** src/xdisp.c	26 Aug 2008 11:11:46 -0000	1.1149.2.33
--- src/xdisp.c	22 Dec 2008 00:03:30 -0000
***************
*** 15759,15765 ****
  	  it->len = 1;
  
  	  if (default_face_p)
! 	    it->face_id = DEFAULT_FACE_ID;
  	  else if (it->face_before_selective_p)
  	    it->face_id = it->saved_face_id;
  	  face = FACE_FROM_ID (it->f, it->face_id);
--- 15920,15926 ----
  	  it->len = 1;
  
  	  if (default_face_p)
! 	    it->face_id = lookup_basic_face (it->f, DEFAULT_FACE_ID); 
  	  else if (it->face_before_selective_p)
  	    it->face_id = it->saved_face_id;
  	  face = FACE_FROM_ID (it->f, it->face_id);
*** src/nsterm.m	6 Mar 2009 19:07:00 -0000	1.65
--- src/nsterm.m	8 Mar 2009 21:52:05 -0000
***************
*** 1991,1996 ****
--- 2006,2012 ----
    UNBLOCK_INPUT;
  }
  
+ extern struct buffer *current_buffer;
  
  void
  ns_clear_frame_area (struct frame *f, int x, int y, int width, int height)
***************
*** 2007,2012 ****
--- 2023,2036 ----
  
    NSTRACE (ns_clear_frame_area);
  
+   if (updated_window)
+     if (current_buffer && XBUFFER (updated_window->buffer) != current_buffer)
+       face = FACE_FROM_ID 
+ 	(f, lookup_basic_face_for_buffer (f, DEFAULT_FACE_ID, 
+ 					  updated_window->buffer) );
+     else
+       face = FACE_FROM_ID (f, lookup_basic_face (f, DEFAULT_FACE_ID) );
+ 
    r = NSIntersectionRect (r, [view frame]);
    ns_focus (f, &r, 1);
    [ns_lookup_indexed_color (NS_FACE_BACKGROUND (face), f) set];
