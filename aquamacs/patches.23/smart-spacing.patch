*** lisp/simple.el	14 Mar 2009 17:43:16 -0000	1.976
--- lisp/simple.el	15 Mar 2009 20:28:13 -0000
***************
*** 7,13 ****
  ;; Maintainer: FSF
  ;; Keywords: internal
  
! ;; This file is part of GNU Emacs.
  
  ;; GNU Emacs is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
--- 7,14 ----
  ;; Maintainer: FSF
  ;; Keywords: internal
  
! ;; This file is part of GNU Emacs and Aquamacs Emacs.
! ;; Aquamacs-specific Smart Spacing code included.
  
  ;; GNU Emacs is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
***************
*** 2781,2793 ****
  	(signal 'args-out-of-range
  		(list string "yank-handler specified for empty string"))))
    (if (fboundp 'menu-bar-update-yank-menu)
!       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
    (if (and replace kill-ring)
        (setcar kill-ring string)
      (push string kill-ring)
      (if (> (length kill-ring) kill-ring-max)
! 	(setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
!   (setq kill-ring-yank-pointer kill-ring)
    (if interprogram-cut-function
        (funcall interprogram-cut-function string (not replace))))
  
--- 2782,2794 ----
  	(signal 'args-out-of-range
  		(list string "yank-handler specified for empty string"))))
    (if (fboundp 'menu-bar-update-yank-menu)
!       (menu-bar-update-yank-menu string (and replace (car kill-ring)))) 
    (if (and replace kill-ring)
        (setcar kill-ring string)
      (push string kill-ring)
      (if (> (length kill-ring) kill-ring-max)
! 	(setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))) 
!   (setq kill-ring-yank-pointer kill-ring) 
    (if interprogram-cut-function
        (funcall interprogram-cut-function string (not replace))))
  
***************
*** 2896,2902 ****
    (unless (and beg end)
      (error "The mark is not set now, so there is no region"))
    (condition-case nil
!       (let ((string (filter-buffer-substring beg end t)))
  	(when string			;STRING is nil if BEG = END
  	  ;; Add that string to the kill ring, one way or another.
  	  (if (eq last-command 'kill-region)
--- 2897,2903 ----
    (unless (and beg end)
      (error "The mark is not set now, so there is no region"))
    (condition-case nil
!       (let ((string (smart-spacing-filter-buffer-substring beg end t)))
  	(when string			;STRING is nil if BEG = END
  	  ;; Add that string to the kill ring, one way or another.
  	  (if (eq last-command 'kill-region)
***************
*** 2934,2941 ****
  This command's old key binding has been given to `kill-ring-save'."
    (interactive "r")
    (if (eq last-command 'kill-region)
!       (kill-append (filter-buffer-substring beg end) (< end beg))
!     (kill-new (filter-buffer-substring beg end)))
    (setq deactivate-mark t)
    nil)
  
--- 2935,2942 ----
  This command's old key binding has been given to `kill-ring-save'."
    (interactive "r")
    (if (eq last-command 'kill-region)
!       (kill-append (smart-spacing-filter-buffer-substring beg end) (< end beg))
!     (kill-new (smart-spacing-filter-buffer-substring beg end)))
    (setq deactivate-mark t)
    nil)
  
***************
*** 6395,6400 ****
--- 6396,6554 ----
          (eval-after-load (car elem) `(bad-package-check ',(car elem))))
        bad-packages-alist)
  
+ ;; Smart spacing
+ 
+ ;; Author: David Reitter, david.reitter@gmail.com
+ ;; Maintainer: David Reitter
+ ;; Keywords: aquamacs
+  
+ ;; This code is part of Aquamacs Emacs
+ ;; http://aquamacs.org/
+ ;; Copyright (C) 2009: David Reitter
+ 
+ ;; (defcustom smart-spacing-when-killing-words nil
+ ;;   "Delete extra spaces when killing words.
+ ;; Affects commands `aquamacs-kill-word' and `aquamacs-backwards-kill-word'."
+ ;;   :group 'convenience
+ ;;   :group 'Aquamacs
+ ;;   :type '(choice (const nil) (const t)))
+ 
+ (define-minor-mode smart-spacing-mode
+  "Smart spacing: word-wise kill&yank.
+ When this mode is enabled, kill and yank operations support
+ word-wise editing.  Afer killing (copying) a word or several
+ words, the text will be inserted as a full phrase when
+ yanking. That means that spaces around the word may be inserted
+ during yanking, and spaces and other word delimiters are removed
+ during killing as necessary to leave only one space between
+ words.
+ 
+ During killing, smart-spacing-mode behaves conservatively.  It
+ will never delete more than one extra space at a time.
+ 
+ This feature is part of Aquamacs."
+  :group 'convenience
+  :lighter " Spc")
+ 
+ (defun turn-on-smart-spacing-mode ()
+   (interactive)
+   (smart-spacing-mode 1))
+ 
+ (defun turn-off-smart-spacing-mode ()
+   (interactive)
+   (smart-spacing-mode 0))
+ 
+ (define-globalized-minor-mode 
+   global-smart-spacing-mode smart-spacing-mode
+   turn-on-smart-spacing-mode)
+ 
+ (defvar smart-spacing-rules
+   '(("  " . (bidi . 1))
+     ("--" . 1)
+     (" ." . -1)
+     (" )" . -1)
+     ("( " . 1)
+     (" :" . -1)
+     (" ," . -1)
+     (" ;" . -1)
+     (" \"" . -1)
+     ("\" " . 1) 
+     (" '" . -1)
+     ("\n " . 1)
+     (" " . 1) ; buffer boundary
+     ;; ("\n\n" . "\n")
+     )
+   "Assoc list for smart spacing.
+ If key is at point after killing text, delete |value| chars to
+ the left or the right.  Negative value indicates deletion to the
+ left.  If value is a cons (xxx . num), then num characters will
+ be deleted either to the left or to the right, depending on where
+ the point is when the command is called.")
+ 
+ (defmacro user-buffer-p (buf)
+   "Evaluate to t if buffer BUF is not an internal buffer."
+   `(not (string= (substring (buffer-name ,buf) 0 1) " ")))
+ 
+ (defun smart-spacing-filter-buffer-substring (beg end &optional delete noprops )   
+  "Like `filter-buffer-substring', but add spaces around content if region is a phrase."
+  (let* ((from (min beg end)) (to (max beg end))
+ 	;; (move-point (memq (point) (list beg end))) 
+ 	(point-at-end (eq (point) end))
+ 	(use-smart-string 
+ 	 (and
+ 	  smart-spacing-mode
+ 	  (user-buffer-p (current-buffer))
+ 	  (smart-spacing-char-is-word-boundary (1- from) from)
+ 	  (smart-spacing-char-is-word-boundary to (1+ to))))
+ 	;; the following is destructive (side-effect).  
+ 	;; do after checking for word boundaries.
+ 	(string (filter-buffer-substring beg end delete noprops)))
+    (when use-smart-string
+      (put-text-property 0 (length string)
+ 			'yank-handler 
+ 			'(smart-spacing-yank-handler nil nil nil) 
+ 			string)
+      (when delete (smart-remove-remaining-spaces from point-at-end)))
+     string))
+ 
+ (defun smart-delete-region (from to)
+   (if (and smart-spacing-mode (memq this-command '(cua-delete-region mouse-save-then-kill)))
+       (let* ((from (min from to)) 
+ 	     (to (max from to))
+ 	     ;; (move-point (memq (point) (list beg end))) 
+ 	     (point-at-end (eq (point) to))) 
+ 	     
+ 	     (delete-region from to)
+ 	     (smart-remove-remaining-spaces from point-at-end))
+     (delete-region from to)))
+ 
+ (defun smart-remove-remaining-spaces (pos point-at-end)
+   "Remove remaining spaces.
+ Adheres to `smart-spacing-rules'.
+ If POINT-AT-END, behaves as if point was at then end of
+ a previously deleted region (now at POS)."
+   (let ((del (assoc (buffer-substring-no-properties
+ 		     (max (point-min) (- pos 1)) 
+ 		     (min (1- (point-max)) (1+ pos)))
+ 		    smart-spacing-rules)))
+     (when del
+       (setq del (cdr del))
+       ;; in some cases we want point to end up 
+       ;; further to the left or to the right,
+       ;; depending on whether it was on the left or the right
+       ;; edge of the region
+       (when (consp del)
+ 	(if point-at-end
+ 	    (setq del (cdr del))
+ 	  (setq del (- (cdr del)))))
+       ;; delete either to the left or to the right
+       ;; this deletion will keep point in the right place.
+       (delete-region pos (+ del pos)))))
+ 
+ (defun smart-spacing-char-is-word-boundary (pos &optional side)
+   (or (< pos (point-min))
+       (>= pos (point-max))
+       (not (let ((str (buffer-substring-no-properties pos (1+ pos))))
+ 	     (or (string-match "\\w" str)
+ 		 (if (eq side 'left) (or (equal str ".") (equal str ")")))
+ 		 (if (eq side 'right) (equal str "(")))))))
+ 
+ 
+ (defun smart-spacing-yank-handler (string)
+       (when  (and smart-spacing-mode  
+ 		  major-mode ; paranoia
+ 		  (user-buffer-p (current-buffer)))
+ 	(or (smart-spacing-char-is-word-boundary opoint 'right) ; to the right
+ 	     (setq string (concat string " ")))
+ 	(or (smart-spacing-char-is-word-boundary (1- opoint) 'left) ; to the left
+ 	    (setq string (concat " " string))
+ 	     ))
+       (insert string))
+ 
+ ;; currently not advising backward-delete-char-untabity 
+ ;; or delete-char
+ 
+ 
  
  (provide 'simple)
  
*** lisp/emulation/cua-base.el	5 Jan 2009 03:21:14 -0000	1.100
--- lisp/emulation/cua-base.el	15 Mar 2009 20:29:31 -0000
***************
*** 816,823 ****
      (setq cua--last-deleted-region-text (filter-buffer-substring start end))
      (if cua-delete-copy-to-register-0
  	(set-register ?0 cua--last-deleted-region-text))
!     (delete-region start end)
!     (setq cua--last-deleted-region-pos
  	  (cons (current-buffer)
  		(and (consp buffer-undo-list)
  		     (car buffer-undo-list))))
--- 816,823 ----
      (setq cua--last-deleted-region-text (filter-buffer-substring start end))
      (if cua-delete-copy-to-register-0
  	(set-register ?0 cua--last-deleted-region-text))
!     (smart-delete-region start end)
!    (setq cua--last-deleted-region-pos
  	  (cons (current-buffer)
  		(and (consp buffer-undo-list)
  		     (car buffer-undo-list))))
*** lisp/mouse.el	31 Jan 2009 22:14:56 -0000	1.353
--- lisp/mouse.el	15 Mar 2009 20:27:52 -0000
***************
*** 1472,1478 ****
  		;; We have already put the old region in the kill ring.
  		;; Replace it with the extended region.
  		;; (It would be annoying to make a separate entry.)
! 		(kill-new (buffer-substring (point) (mark t)) t)
  		(mouse-set-region-1)
  		;; Arrange for a repeated mouse-3 to kill this region.
  		(setq mouse-save-then-kill-posn
--- 1473,1479 ----
  		;; We have already put the old region in the kill ring.
  		;; Replace it with the extended region.
  		;; (It would be annoying to make a separate entry.)
! 		(kill-new (smart-spacing-filter-buffer-substring (point) (mark t)) t)
  		(mouse-set-region-1)
  		;; Arrange for a repeated mouse-3 to kill this region.
  		(setq mouse-save-then-kill-posn
***************
*** 1480,1486 ****
  		(mouse-show-mark))
  	    ;; If we click this button again without moving it,
  	    ;; that time kill.
! 	    (mouse-save-then-kill-delete-region (mark) (point))
  	    (setq mouse-selection-click-count 0)
  	    (setq mouse-save-then-kill-posn nil))
  	(if (and (eq last-command 'mouse-save-then-kill)
--- 1481,1487 ----
  		(mouse-show-mark))
  	    ;; If we click this button again without moving it,
  	    ;; that time kill.
! 	    (smart-delete-region (mark) (point))
  	    (setq mouse-selection-click-count 0)
  	    (setq mouse-save-then-kill-posn nil))
  	(if (and (eq last-command 'mouse-save-then-kill)
***************
*** 1490,1496 ****
  	    ;; If this is the second time we've called
  	    ;; mouse-save-then-kill, delete the text from the buffer.
  	    (progn
! 	      (mouse-save-then-kill-delete-region (point) (mark))
  	      ;; After we kill, another click counts as "the first time".
  	      (setq mouse-save-then-kill-posn nil))
  	  ;; This is not a repetition.
--- 1491,1497 ----
  	    ;; If this is the second time we've called
  	    ;; mouse-save-then-kill, delete the text from the buffer.
  	    (progn
! 	      (smart-delete-region (point) (mark))
  	      ;; After we kill, another click counts as "the first time".
  	      (setq mouse-save-then-kill-posn nil))
  	  ;; This is not a repetition.
***************
*** 1514,1526 ****
  			  (goto-char new)
  			(set-mark new))
  		      (setq deactivate-mark nil)))
! 		(kill-new (buffer-substring (point) (mark t)) t))
  	    ;; Set the mark where point is, then move where clicked.
  	    (mouse-set-mark-fast click)
  	    (if before-scroll
  		(goto-char before-scroll))
  	    (exchange-point-and-mark)   ;Why??? --Stef
! 	    (kill-new (buffer-substring (point) (mark t))))
            (mouse-show-mark)
  	  (mouse-set-region-1)
  	  (setq mouse-save-then-kill-posn
--- 1515,1527 ----
  			  (goto-char new)
  			(set-mark new))
  		      (setq deactivate-mark nil)))
! 		(kill-new (smart-spacing-filter-buffer-substring (point) (mark t)) t))
  	    ;; Set the mark where point is, then move where clicked.
  	    (mouse-set-mark-fast click)
  	    (if before-scroll
  		(goto-char before-scroll))
  	    (exchange-point-and-mark)   ;Why??? --Stef
! 	    (kill-new (smart-spacing-filter-buffer-substring (point) (mark t))))
            (mouse-show-mark)
  	  (mouse-set-region-1)
  	  (setq mouse-save-then-kill-posn
