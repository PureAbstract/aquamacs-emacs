*** lisp/textmodes/ispell.el	06 Apr 2008 12:51:35 +0100	1.209.2.8
--- lisp/textmodes/ispell.el	01 May 2008 09:48:16 +0100	
***************
*** 2,18 ****
  
  ;; Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
  ;;   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
  
  ;; Author:           Ken Stevens <k.stevens@ieee.org>
  ;; Maintainer:       Ken Stevens <k.stevens@ieee.org>
! ;; Stevens Mod Date: Mon Jan  7 12:32:44 PST 2003
! ;; Stevens Revision: 3.6
! ;; Status          : Release with 3.1.12+ and 3.2.0+ ispell.
  ;; Bug Reports     : ispell-el-bugs@itcorp.com
  ;; Web Site        : http://kdstevens.com/~stevens/ispell-page.html
  ;; Keywords: unix wp
  
! ;; This file is part of GNU Emacs.
  
  ;; GNU Emacs is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
--- 2,17 ----
  
  ;; Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
  ;;   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+ ;; Copyright (C) 2008 The Aquamacs Project
  
  ;; Author:           Ken Stevens <k.stevens@ieee.org>
  ;; Maintainer:       Ken Stevens <k.stevens@ieee.org>
! ;;                   in Aquamacs: Nathaniel Cunningham <nathaniel.cunningham@gmail.com>
  ;; Bug Reports     : ispell-el-bugs@itcorp.com
  ;; Web Site        : http://kdstevens.com/~stevens/ispell-page.html
  ;; Keywords: unix wp
  
! ;; This file is part of GNU Emacs and of Aquamacs Emacs.
  
  ;; GNU Emacs is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
***************
*** 130,135 ****
--- 129,137 ----
  
  ;; Modifications made in latest versions:
  
+ 
+ ;; Aquamacs: 2008/05/01  aspell support
+ 
  ;; Revision 3.6 2003/01/07 12:32:44	kss
  ;; Removed extra -d LIB in dictionary defs. (Pavel Janik)
  ;; Filtered process calls with duplicate dictionary entries.
***************
*** 227,232 ****
--- 229,463 ----
  (defalias 'check-ispell-version 'ispell-check-version)
  
  ;;; **********************************************************************
+ ;;; new settings to use cocoAspell preferences (from Spelling prefpane)
+ 
+ (require 'aquamacs-tools)
+ 
+ (aquamacs-set-defaults 
+  `((ispell-program-name
+     ,(or (if (locate-file "aspell" exec-path exec-suffixes 'file-executable-p) 
+ 	     "aspell")
+ 	 (if (locate-file "ispell" exec-path exec-suffixes 'file-executable-p)
+ 	     "ispell")))))
+ 
+ ;; Should we use cocoAspell preferences to determine dictionaries for spellchecking?
+ (aquamacs-set-defaults
+  `((ispell-use-cocoaspell
+    ,(and (equal ispell-program-name "aspell")
+ 	 (not (getenv "ASPELL_CONF"))
+ 	 (file-accessible-directory-p
+ 	  (expand-file-name "~/Library/Services/cocoAspell.service/"))))))
+ 
+ ;; ** switch to aquamacs default?**
+ (if ispell-use-cocoaspell
+     (progn 
+       (setq ispell-cocoaspell-prefs-dir
+ 	    (expand-file-name "~/Library/Preferences/cocoAspell/")
+ 	    ispell-cocoaspell-prefpane-plist
+ 	    ;; overall preferences set in Spelling prefpane
+ 	    (expand-file-name
+ 	      "~/Library/Services/cocoAspell.service/Contents/Info.plist"))
+ 
+       (setq ispell-cocoaspell-dict-list
+ 	    (let ((lang-list))
+ 	      (with-temp-buffer
+ 		;; extract language names selected in Spelling prefpane
+ 		(insert-file-contents ispell-cocoaspell-prefpane-plist)
+ 		;; move point to just before first language name
+ 		(re-search-forward "<key>NSLanguages</key>\\s +<array>\\s +<string>")
+ 		(while (progn
+ 			 ;; find each language name, and move point to just before next
+ 			 ;; tag after current string
+ 			 (re-search-forward "\\(.+\\)</string>\\s +<\\([/a-z]+\\)>")
+ 			 ;; tack current language onto lang-list
+ 			 (add-to-list 'lang-list (match-string 1))
+ 			 ;; continue if next tag indicates another language string
+ 			 (equal (match-string 2) "string")))
+ 		;; return the language list
+ 		lang-list)))
+ 
+       ;; now we need an alist or hash table pairing up language names and
+       ;; abbreviations
+       (setq language-abbrev-alist
+ 	    (list
+ 	     (cons "Afrikaans" "af")
+ 	     (cons "Amharic" "am")
+ 	     (cons "Arabic" "ar")
+ 	     (cons "Azerbaijani" "az")
+ 	     (cons "Belarusian" "be")
+ 	     (cons "Bulgarian" "bg")
+ 	     (cons "Bengali" "bn")
+ 	     (cons "Breton" "br")
+ 	     (cons "Catalan" "ca")
+ 	     (cons "Czech" "cs")
+ 	     (cons "Kashubian" "csb")
+ 	     (cons "Welsh" "cy")
+ 	     (cons "Danish" "da")
+ 	     (cons "German" "de")
+ 	     (cons "Greek" "el")
+ 	     (cons "English" "en")
+ 	     (cons "Esperanto" "eo")
+ 	     (cons "Spanish" "es")
+ 	     (cons "Estonian" "et")
+ 	     (cons "Persian" "fa")
+ 	     (cons "Finnish" "fi")
+ 	     (cons "Faroese" "fo")
+ 	     (cons "French" "fr")
+ 	     (cons "Frisian" "fy")
+ 	     (cons "Irish" "ga")
+ 	     (cons "Scottish Gaelic" "gd")
+ 	     (cons "Gallegan" "gl")
+ 	     (cons "Gujarati" "gu")
+ 	     (cons "Manx" "gv")
+ 	     (cons "Hebrew" "he")
+ 	     (cons "Hindi" "hi")
+ 	     (cons "Hiligaynon" "hil")
+ 	     (cons "Croatian" "hr")
+ 	     (cons "Upper Sorbian" "hsb")
+ 	     (cons "Hungarian" "hu")
+ 	     (cons "Armenian" "hy")
+ 	     (cons "Interlingua" "ia")
+ 	     (cons "Indonesian" "id")
+ 	     (cons "Icelandic" "is")
+ 	     (cons "Italian" "it")
+ 	     (cons "Kurdish" "ku")
+ 	     (cons "Latin" "la")
+ 	     (cons "Lithuanian" "lt")
+ 	     (cons "Latvian" "lv")
+ 	     (cons "Malagasy" "mg")
+ 	     (cons "Maori" "mi")
+ 	     (cons "Macedonian" "mk")
+ 	     (cons "Malayalam" "ml")
+ 	     (cons "Mongolian" "mn")
+ 	     (cons "Marathi" "mr")
+ 	     (cons "Malay" "ms")
+ 	     (cons "Maltese" "mt")
+ 	     (cons "Norwegian Bokmål" "nb")
+ 	     (cons "Low German; Low Saxon" "nds")
+ 	     (cons "Dutch" "nl")
+ 	     (cons "Norwegian Nynorsk" "nn")
+ 	     (cons "Nyanja; Chichewa; Chewa" "ny")
+ 	     (cons "Oriya" "or")
+ 	     (cons "Punjabi" "pa")
+ 	     (cons "Polish" "pl")
+ 	     (cons "Portuguese" "pt")
+ 	     (cons "Quechua" "qu")
+ 	     (cons "Romanian" "ro")
+ 	     (cons "Russian" "ru")
+ 	     (cons "Kinyarwanda" "rw")
+ 	     (cons "Sardinian" "sc")
+ 	     (cons "Slovak" "sk")
+ 	     (cons "Slovenian" "sl")
+ 	     (cons "Serbian" "sr")
+ 	     (cons "Swedish" "sv")
+ 	     (cons "Swahili" "sw")
+ 	     (cons "Tamil" "ta")
+ 	     (cons "Telugu" "te")
+ 	     (cons "Tetum" "tet")
+ 	     (cons "Turkmen" "tk")
+ 	     (cons "Tagalog" "tl")
+ 	     (cons "Tswana" "tn")
+ 	     (cons "Turkish" "tr")
+ 	     (cons "Ukrainian" "uk")
+ 	     (cons "Uzbek" "uz")
+ 	     (cons "Vietnamese" "vi")
+ 	     (cons "Walloon" "wa")
+ 	     (cons "Yiddish" "yi")
+ 	     (cons "Zulu" "zu")
+ 	     ))
+ 
+       ;; another alist for language region abbreviations
+       (setq lregion-abbrev-alist
+ 	    (list
+ 	     (cons "United States" "US")
+ 	     (cons "Canada" "CA")
+ 	     (cons "United Kingdom" "GB")
+ 	     (cons "France" "FR")
+ 	     (cons "Switzerland" "CH")
+ 	     (cons "Austria" "AT")
+ 	     (cons "Germany" "DE")
+ 	     (cons "Brazil" "BR")
+ 	     (cons "Portugal" "PT")
+ 	     ))
+ 
+ ;; convert from names e.g. English (United States) to en_US
+ ;; append stuff in brackets
+ ;; also include length if it exists
+       (defun aspell-dict-abbrev (langstring)
+ 	(unless (null langstring)
+ 	  (let* ((lang-elts
+ 		  ;; parse out: language
+ 		  (string-match (concat "\\([[:alpha:]]+;?\\( [[:alpha:]]+;?\\)*\\)"
+ 					;; region
+ 					"\\( (\\([[:alpha:] ]+\\))\\)?"
+ 					 ;; modifiers
+ 					"\\( \\[\\(.+\\)\\]\\)?"
+ 					) langstring))
+ 		 (lang (match-string 1 langstring))
+ 		 (lregion (match-string 4 langstring))
+ 		 (mods (match-string 6 langstring))
+ 		 (lang-abbrev (cdr (assoc lang language-abbrev-alist)))
+ 		 (lregion-abbrev (or (cdr (assoc lregion lregion-abbrev-alist))
+ 				     lregion))) ;; if no abbrev in alist, keep name
+ 	    (if lregion-abbrev (setq lregion-abbrev (concat "_" lregion-abbrev)))
+ 	    (if mods (setq mods (concat "-" mods)))
+ 	    (concat lang-abbrev lregion-abbrev mods)))) ;; generate aspell conf filename
+ 
+       (defun ispell-cocoaspell-dict-dir (dict-abbrev)
+ 	(let ((filename (concat ispell-cocoaspell-prefs-dir dict-abbrev ".conf")))
+ 	  (if (file-readable-p filename)
+ 	      (with-temp-buffer
+ 		(insert-file-contents filename)
+ 		(when (search-forward-regexp "^dict-dir " nil t)
+ 		  (buffer-substring (point) (progn (end-of-line) (point)))))
+ 	    (let* ((dict-abbrev-parts (split-string dict-abbrev "-"))
+ 		   (dict-abbrev-root (car dict-abbrev-parts))
+ 		   (dict-abbrev-mods (nth 1 dict-abbrev-parts))
+ 		   (dict-abbrev-root-parts (split-string dict-abbrev-root "_"))
+ 		   (dict-lang-abbrev (car dict-abbrev-root-parts))
+ 		   (dict-region-abbrev (nth 1 dict-abbrev-root-parts))
+ 		   (dict-parent-dir "/Library/Application Support/cocoAspell/")
+ 		   (dict-dir (car (or (directory-files
+ 				       dict-parent-dir
+ 				       nil
+ 				       (concat "aspell[0-9]?-"
+ 					       dict-lang-abbrev "-"
+ 					       dict-abbrev-mods "-.+"))
+ 				      (directory-files
+ 				       dict-parent-dir
+ 				       nil
+ 				       (concat "aspell[0-9]?-"
+ 					       dict-lang-abbrev "-"
+ 					       dict-region-abbrev "-.+"))
+ 				      (directory-files
+ 				       dict-parent-dir
+ 				       nil
+ 				       (concat "aspell[0-9]?-"
+ 					       dict-lang-abbrev "-.+"))))))
+ 	      (concat dict-parent-dir dict-dir)))))
+       
+       (defun cocoaspell-aspell-args (dict-abbrev)
+ 	(let* ((lang-conf (concat ispell-cocoaspell-prefs-dir dict-abbrev ".conf"))
+ 	       (readable (file-readable-p lang-conf)))
+ 	  (if readable
+ 	      (list (concat "--conf=" ispell-cocoaspell-prefs-dir "filters.conf")
+ 		    (concat "--per-conf=" ispell-cocoaspell-prefs-dir dict-abbrev ".conf")
+ 		    "--encoding=utf-8")
+ 	    (let* ((dict-abbrev-parts (split-string dict-abbrev "-"))
+ 		   (dict-abbrev-root (car dict-abbrev-parts))
+ 		   (dict-abbrev-mods (nth 1 dict-abbrev-parts))
+ 		   (dict-dir (ispell-cocoaspell-dict-dir dict-abbrev)))
+ 	      (list (concat "--dict-dir=" dict-dir)
+ 		    "--encoding=utf-8"
+ 		    (concat "--home-dir=" ispell-cocoaspell-prefs-dir)
+ 		    (concat "--jargon=" dict-abbrev-mods)
+ 		    (concat "--lang=" dict-abbrev-root)
+ ;; 		    (concat "--per-conf=" dict-abbrev-root ".conf")
+ 		    (concat "--personal=" dict-abbrev-root ".pws")
+ 		    (concat "--repl=" dict-abbrev-root ".prepl"))))))
+        ))
+ 
+ ;;; **********************************************************************
  ;;; The following variables should be set according to personal preference
  ;;; and location of binaries:
  ;;; **********************************************************************
***************
*** 520,525 ****
--- 751,757 ----
    :group 'ispell)
  
  
+ 
  ;;; split dictionary so line length is smaller in loaddefs.el
  
  ;;; First part of dictionary, shortened for loaddefs.el
***************
*** 662,668 ****
      "[^A-Za-z\345\344\366\351\340\374\350\346\370\347\305\304\326\311\300\334\310\306\330\307]"
      "[']" nil ("-C") "~list" iso-8859-1)))
  
- 
  ;;;###autoload
  (defvar ispell-dictionary-alist
    (append ispell-dictionary-alist-1 ispell-dictionary-alist-2
--- 894,899 ----
***************
*** 912,941 ****
    (unless ispell-really-aspell
      (error "This function only works with aspell"))
    (let* ((dictionaries
! 	  (split-string
! 	   (with-temp-buffer
! 	     (ispell-call-process ispell-program-name nil t nil "dicts")
! 	     (buffer-string))))
  	 ;; Search for the named dictionaries.
  	 (found
  	  (delq nil
  		(mapcar #'ispell-aspell-find-dictionary dictionaries))))
      ;; Ensure aspell's alias dictionary will override standard
      ;; definitions.
!     (setq found (ispell-aspell-add-aliases found))
      ;; Merge into FOUND any elements from the standard ispell-dictionary-alist
      ;; which have no element in FOUND at all.
!     (dolist (dict ispell-dictionary-alist)
!       (unless (assoc (car dict) found)
! 	(setq found (nconc found (list dict)))))
      (setq ispell-dictionary-alist found)
!     ;; Add a default entry
!     (let* ((english-dict (assoc "en" ispell-dictionary-alist))
  	   (default-dict
! 	     (cons nil (or (cdr english-dict)
! 			   (cdr (car ispell-dictionary-alist-1))))))
        (push default-dict ispell-dictionary-alist))
!     (setq ispell-have-aspell-dictionaries t)))
  
  (defvar ispell-aspell-data-dir nil
    "Data directory of Aspell.")
--- 1143,1197 ----
    (unless ispell-really-aspell
      (error "This function only works with aspell"))
    (let* ((dictionaries
! 	  (cond
! 	   (ispell-use-cocoaspell
! 	    ispell-cocoaspell-dict-list)
! 	   (ispell-use-cocoaspell-dicts
! 	    ispell-cocoaspell-dict-aliases)
! 	   (t (split-string
! 	       (with-temp-buffer
! 		 (ispell-call-process ispell-program-name nil t nil "dicts")
! 		 (buffer-string))))))
  	 ;; Search for the named dictionaries.
  	 (found
  	  (delq nil
  		(mapcar #'ispell-aspell-find-dictionary dictionaries))))
      ;; Ensure aspell's alias dictionary will override standard
      ;; definitions.
! ;;     (if ispell-use-cocoaspell-dicts
! ;; 	(mapcar (lambda (dict-dir)
! ;; 		  (let ((ispell-aspell-dict-dir dict-dir))
! ;; 		    (setq found (ispell-aspell-add-aliases found))))
! ;; 		ispell-cocoaspell-dict-dir-list)
!       (setq found (ispell-aspell-add-aliases found));)
      ;; Merge into FOUND any elements from the standard ispell-dictionary-alist
      ;; which have no element in FOUND at all.
!     ;; ==SKIP this step -- don't add entries corresponding to dicts we don't have!!!==
! ;;         (dolist (dict ispell-dictionary-alist)
! ;;           (unless (assoc (car dict) found)
! ;;     	(setq found (nconc found (list dict)))))
      (setq ispell-dictionary-alist found)
! ;;     (if ispell-use-cocoaspell
! 	;; Add a default entry
!     (let* ((english-dict-cdr
! 	    (if (or ispell-use-cocoaspell ispell-use-cocoaspell-dicts)
! 		(or 
! 		 (assoc-default "^[Ee]nglish$" ispell-dictionary-alist
! 				(lambda (dict-name key)
! 				  (string-match key dict-name)))
! 		 (assoc-default "^[Ee]n$" ispell-dictionary-alist
! 				(lambda (dict-name key)
! 				  (string-match key dict-name)))
! 		 (assoc-default "^[Ee]ngl.*" ispell-dictionary-alist
! 				(lambda (dict-name key)
! 				  (and (string-match key dict-name)
! 				       (not (string-match ".*variant.*" dict-name))))))
! 	      (cdr (assoc "en" ispell-dictionary-alist))))
  	   (default-dict
! 	     (cons nil (or english-dict-cdr
! 			   (cdr (car ispell-dictionary-alist))))))
        (push default-dict ispell-dictionary-alist))
!   (setq ispell-have-aspell-dictionaries t)))
  
  (defvar ispell-aspell-data-dir nil
    "Data directory of Aspell.")
***************
*** 954,993 ****
    ;; This returns nil if the data file does not exist.
    ;; Can someone please explain the return value format when the
    ;; file does exist -- rms?
!   (let* ((lang ;; Strip out region, variant, etc.
! 	  (and (string-match "^[[:alpha:]]+" dict-name)
! 	       (match-string 0 dict-name)))
  	 (data-file
! 	  (concat (or ispell-aspell-data-dir
! 		      (setq ispell-aspell-data-dir
! 			    (ispell-get-aspell-config-value "data-dir")))
! 		  "/" lang ".dat"))
! 	 otherchars)
      (condition-case ()
  	(with-temp-buffer
! 	  (insert-file-contents data-file)
! 	  ;; There is zero or one line with special characters declarations.
! 	  (when (search-forward-regexp "^special" nil t)
! 	    (let ((specials (split-string
! 			     (buffer-substring (point)
! 					       (progn (end-of-line) (point))))))
! 	      ;; The line looks like: special ' -** - -** . -** : -*-
! 	      ;; -** means that this character
! 	      ;;    - doesn't appear at word start
! 	      ;;    * may appear in the middle of a word
! 	      ;;    * may appear at word end
! 	      ;; `otherchars' is about the middle case.
! 	      (while specials
! 		(when (eq (aref (cadr specials) 1) ?*)
! 		  (push (car specials) otherchars))
! 		(setq specials (cddr specials)))))
  	  (list dict-name
  		"[[:alpha:]]"
  		"[^[:alpha:]]"
  		(regexp-opt otherchars)
  		t			     ; We can't tell, so set this to t
! 		(list "-d" dict-name "--encoding=utf-8")
! 		nil				; aspell doesn't support this
  		;; Here we specify the encoding to use while communicating with
  		;; aspell.  This doesn't apply to command line arguments, so
  		;; just don't pass words to spellcheck as arguments...
--- 1210,1267 ----
    ;; This returns nil if the data file does not exist.
    ;; Can someone please explain the return value format when the
    ;; file does exist -- rms?
!   (let* ((dict-abbrev (when ispell-use-cocoaspell
! 			(aspell-dict-abbrev dict-name)))
! 	 (lang ;; Strip out region, variant, etc.
! 	  (and (string-match "^[[:alpha:]]+" (or dict-abbrev dict-name))
! 	       (match-string 0 (or dict-abbrev dict-name))))
! 	 (dict-dir (when ispell-use-cocoaspell
! 		     (ispell-cocoaspell-dict-dir dict-abbrev)))
  	 (data-file
! 	  (if ispell-use-cocoaspell
! 	      (concat dict-dir "/" lang ".dat")
! 	    (concat (or ispell-aspell-data-dir
! 			(setq ispell-aspell-data-dir
! 			      (ispell-get-aspell-config-value "data-dir")))
! 		    "/" lang ".dat")))
! 	 otherchars
! 	 charset)
      (condition-case ()
  	(with-temp-buffer
! 	  (when (file-readable-p data-file)
! 		(insert-file-contents data-file)
! 		;; There is zero or one line with special characters declarations.
! 		(when (search-forward-regexp "^special" nil t)
! 		  (let ((specials (split-string
! 				   (buffer-substring (point)
! 						     (progn (end-of-line) (point))))))
! 		    ;; The line looks like: special ' -** - -** . -** : -*-
! 		    ;; -** means that this character
! 		    ;;    - doesn't appear at word start
! 		    ;;    * may appear in the middle of a word
! 		    ;;    * may appear at word end
! 		    ;; `otherchars' is about the middle case.
! 		    (while specials
! 		      (when (eq (aref (cadr specials) 1) ?*)
! 			(push (car specials) otherchars))
! 		      (setq specials (cddr specials))))))
  	  (list dict-name
  		"[[:alpha:]]"
  		"[^[:alpha:]]"
  		(regexp-opt otherchars)
  		t			     ; We can't tell, so set this to t
! 		;; set arguments for aspell
! 		;; if we use cocoAspell prefs, use conf files associated with language
! 		(cond (ispell-use-cocoaspell
! 		       (cocoaspell-aspell-args dict-abbrev))
! 		    ;; (list (concat "--conf=" ispell-cocoaspell-prefs-dir "filters.conf")
! ;; 		      (concat "--per-conf=" ispell-cocoaspell-prefs-dir dict-abbrev ".conf")
! ;; ;; 		      (concat "--encoding=utf-8")
! ;; )
! 		      (ispell-use-cocoaspell-dicts
! 		       (list "-d" dict-name "--dict-dir" (file-name-directory (car (file-expand-wildcards (concat "/Library/Application Support/cocoAspell/aspell*-*-*/" dict-name ".alias")))) "--encoding=utf-8"))
! 		      (t (list "-d" dict-name "--encoding=utf-8")))
! 		      nil				; aspell doesn't support this
  		;; Here we specify the encoding to use while communicating with
  		;; aspell.  This doesn't apply to command line arguments, so
  		;; just don't pass words to spellcheck as arguments...
***************
*** 1051,1088 ****
  (if ispell-menu-map-needed
      (progn
        (setq ispell-menu-map (make-sparse-keymap "Spell"))
-       (define-key ispell-menu-map [ispell-change-dictionary]
- 	'(menu-item "Change Dictionary..." ispell-change-dictionary
- 		    :help "Supply explicit dictionary file name"))
        (define-key ispell-menu-map [ispell-kill-ispell]
  	'(menu-item "Kill Process" ispell-kill-ispell
  		    :enable (and (boundp 'ispell-process) ispell-process
  				 (eq (ispell-process-status) 'run))
  		    :help "Terminate Ispell subprocess"))
        (define-key ispell-menu-map [ispell-pdict-save]
! 	'(menu-item "Save Dictionary"
  		    (lambda () (interactive) (ispell-pdict-save t t))
  		    :help "Save personal dictionary"))
!       (define-key ispell-menu-map [ispell-customize]
! 	'(menu-item "Customize..."
! 		    (lambda () (interactive) (customize-group 'ispell))
! 		    :help "Customize spell checking options"))
!       (define-key ispell-menu-map [ispell-help]
! 	;; use (x-popup-menu last-nonmenu-event(list "" ispell-help-list)) ?
! 	'(menu-item "Help"
! 		    (lambda () (interactive) (describe-function 'ispell-help))
! 		    :help "Show standard Ispell keybindings and commands"))
!       (define-key ispell-menu-map [flyspell-mode]
! 	'(menu-item "Automatic spell checking (Flyspell)"
! 		    flyspell-mode
! 		    :help "Check spelling while you edit the text"
! 		    :button (:toggle . (bound-and-true-p flyspell-mode))))
        (define-key ispell-menu-map [ispell-complete-word]
  	'(menu-item "Complete Word" ispell-complete-word
  		    :help "Complete word at cursor using dictionary"))
        (define-key ispell-menu-map [ispell-complete-word-interior-frag]
  	'(menu-item "Complete Word Fragment" ispell-complete-word-interior-frag
! 		    :help "Complete word fragment at cursor"))))
  
  ;;;###autoload
  (if ispell-menu-map-needed
--- 1325,1371 ----
  (if ispell-menu-map-needed
      (progn
        (setq ispell-menu-map (make-sparse-keymap "Spell"))
        (define-key ispell-menu-map [ispell-kill-ispell]
  	'(menu-item "Kill Process" ispell-kill-ispell
  		    :enable (and (boundp 'ispell-process) ispell-process
  				 (eq (ispell-process-status) 'run))
  		    :help "Terminate Ispell subprocess"))
+       (define-key ispell-menu-map [ispell-terminate-separator]
+ 	'(menu-item "--"))
+       (define-key ispell-menu-map [ispell-change-dictionary]
+ 	'(menu-item "Change Dictionary..." ispell-change-dictionary
+ 		    :help "Supply explicit dictionary file name"))
        (define-key ispell-menu-map [ispell-pdict-save]
! 	'(menu-item "Save Personal Word List"
  		    (lambda () (interactive) (ispell-pdict-save t t))
  		    :help "Save personal dictionary"))
! ;;       (define-key ispell-menu-map [ispell-customize-separator]
! ;; 	'(menu-item "--"))
! ;;       (define-key ispell-menu-map [ispell-customize]
! ;; 	'(menu-item "Customize..."
! ;; 		    (lambda () (interactive) (customize-group 'ispell))
! ;; 		    :help "Customize spell checking options"))
! ;;       (define-key ispell-menu-map [ispell-help]
! ;; 	;; use (x-popup-menu last-nonmenu-event(list "" ispell-help-list)) ?
! ;; 	'(menu-item "Help"
! ;; 		    (lambda () (interactive) (describe-function 'ispell-help))
! ;; 		    :help "Show standard Ispell keybindings and commands"))
!       (define-key ispell-menu-map [ispell-complete-word-separator]
! 	'(menu-item "--"))
! 
        (define-key ispell-menu-map [ispell-complete-word]
  	'(menu-item "Complete Word" ispell-complete-word
  		    :help "Complete word at cursor using dictionary"))
        (define-key ispell-menu-map [ispell-complete-word-interior-frag]
  	'(menu-item "Complete Word Fragment" ispell-complete-word-interior-frag
! 		    :help "Complete word fragment at cursor"))
!       (define-key ispell-menu-map [flyspell-mode-separator]
! 	'(menu-item "--"))
!       (define-key ispell-menu-map [flyspell-mode]
! 	'(menu-item "Check Spelling as You Type"
! 		    flyspell-mode
! 		    :help "Check spelling while you edit the text"
! 		    :button (:toggle . (bound-and-true-p flyspell-mode))))))
  
  ;;;###autoload
  (if ispell-menu-map-needed
***************
*** 2489,2510 ****
  (defun ispell-start-process ()
    "Start the ispell process, with support for no asynchronous processes.
  Keeps argument list for future ispell invocations for no async support."
!   (let ((default-directory default-directory)
  	args)
      (unless (and (file-directory-p default-directory)
  		 (file-readable-p default-directory))
        ;; Defend against bad `default-directory'.
        (setq default-directory (expand-file-name "~/")))
      ;; Local dictionary becomes the global dictionary in use.
!     (setq ispell-current-dictionary
! 	  (or ispell-local-dictionary ispell-dictionary))
      (setq ispell-current-personal-dictionary
  	  (or ispell-local-pdict ispell-personal-dictionary))
      (setq args (ispell-get-ispell-args))
!     (if (and ispell-current-dictionary	; use specified dictionary
  	     (not (member "-d" args)))	; only define if not overridden
  	(setq args
! 	      (append (list "-d" ispell-current-dictionary) args)))
      (if ispell-current-personal-dictionary	; use specified pers dict
  	(setq args
  	      (append args
--- 2772,2797 ----
  (defun ispell-start-process ()
    "Start the ispell process, with support for no asynchronous processes.
  Keeps argument list for future ispell invocations for no async support."
!   (let* ((default-directory default-directory)
! 	 (current-dict-name (or ispell-local-dictionary ispell-dictionary))
! 	 (current-dict
! 	  (if ispell-use-cocoaspell
! 	      (aspell-dict-abbrev current-dict-name)
! 	    current-dict-name))
  	args)
      (unless (and (file-directory-p default-directory)
  		 (file-readable-p default-directory))
        ;; Defend against bad `default-directory'.
        (setq default-directory (expand-file-name "~/")))
      ;; Local dictionary becomes the global dictionary in use.
!     (setq ispell-current-dictionary current-dict-name)
      (setq ispell-current-personal-dictionary
  	  (or ispell-local-pdict ispell-personal-dictionary))
      (setq args (ispell-get-ispell-args))
!     (if (and current-dict	; use specified dictionary
  	     (not (member "-d" args)))	; only define if not overridden
  	(setq args
! 	      (append (list "-d" current-dict) args)))
      (if ispell-current-personal-dictionary	; use specified pers dict
  	(setq args
  	      (append args
***************
*** 2528,2535 ****
        (ispell-send-string "\032\n")	; so Ispell prints version and exits
        t)))
  
- 
- 
  (defun ispell-init-process ()
    "Check status of Ispell process and start if necessary."
    (if (and ispell-process
--- 2815,2820 ----
***************
*** 2625,2636 ****
  
  By just answering RET you can find out what the current dictionary is."
    (interactive
     (list (completing-read
  	  "Use new dictionary (RET for current, SPC to complete): "
  	  (and (fboundp 'ispell-valid-dictionary-list)
  	       (mapcar 'list (ispell-valid-dictionary-list)))
  	  nil t)
! 	 current-prefix-arg))
    (ispell-maybe-find-aspell-dictionaries)
    (unless arg (ispell-buffer-local-dict 'no-reload))
    (if (equal dict "default") (setq dict nil))
--- 2910,2922 ----
  
  By just answering RET you can find out what the current dictionary is."
    (interactive
+    (let ((completion-ignore-case t))
     (list (completing-read
  	  "Use new dictionary (RET for current, SPC to complete): "
  	  (and (fboundp 'ispell-valid-dictionary-list)
  	       (mapcar 'list (ispell-valid-dictionary-list)))
  	  nil t)
! 	 current-prefix-arg)))
    (ispell-maybe-find-aspell-dictionaries)
    (unless arg (ispell-buffer-local-dict 'no-reload))
    (if (equal dict "default") (setq dict nil))
***************
*** 3799,3804 ****
--- 4085,4158 ----
  
  (add-to-list 'debug-ignored-errors "^No word found to check!$")
  
+ (setq ispell-use-cocoaspell-dicts nil)
+ 
+ (if ispell-use-cocoaspell
+   (ispell-find-aspell-dictionaries)
+ 
+ ;; (and (equal ispell-program-name "aspell")
+ ;; 				       (not (getenv "ASPELL_CONF"))
+ ;; 				       (not ispell-use-cocoaspell)))
+ 
+ ;; if we find aspell but no configuration for it, assume we use cocoAspell
+ ;;  dictionaries, but not cocoaspell configuration.
+ ;; find cocoAspell's directories automatically:
+   ;;otherwise, use previous method to access cocoAspell dictionaries
+ ;;   (defun aquamacs--configure-aspell ()
+ ;;     "Configure Aspell automatically if it hasn't been configured already."
+ ;;     (remove-hook 'ispell-kill-ispell-hook 'aquamacs--configure-aspell) 
+     ;; only once please
+ ;;     (when (and (equal ispell-program-name "aspell")
+ 	       ;;	     (not ispell-dictionary-alist) ;; nothing found yet
+ ;; 	       (not (getenv "ASPELL_CONF")))
+       ;; don't do this - would assume default dirs 	
+       ;;(ispell-maybe-find-aspell-dictionaries) ;; try to find dictionaries
+ ;;       (setq ispell-have-aspell-dictionaries nil)
+       ;; to find out if it's already configured
+ ;;       (unless ispell-dictionary-alist
+ (condition-case nil
+     (if (with-temp-buffer
+ 	  ;; is there a stored cocoaSpell configuration?
+ 	  (ispell-call-process ispell-program-name nil t nil "dicts")
+ 	  (eq (point-min) (point-max))) ;; no output?
+ 	;; OK, aspell has not been configured by user on Unix level
+ 	;; or in Emacs
+ 	(progn
+ 	  (print "no dicts!")
+ 	  (setenv 
+ 	   "ASPELL_CONF"
+ 	   (let ((config-dir (expand-file-name 
+ 			      "~/Library/Preferences/cocoAspell")))
+ 	     ;; 		     (dict-dir 
+ 	     ;; 		      (car ;; use the first subdir in that path
+ 	     ;; 		       (file-expand-wildcards 
+ 	     ;; 			"/Library/Application Support/cocoAspell/aspell*"))))
+ 	     ;; check if the directories are readable
+ 	     (if (file-readable-p config-dir) 
+ 		 (setq config-dir (concat "conf-dir " config-dir))
+ 	       (setq config-dir nil))))
+ 	  (setq ispell-use-cocoaspell-dicts t)
+ 	  (print "just set ispell-use-cocoaspell-dicts to t!")
+ 	  (setq ispell-cocoaspell-dict-dir-list
+ 		(file-expand-wildcards
+ 		 "/Library/Application Support/cocoAspell/aspell*-*-*"))
+ 	  (setq ispell-cocoaspell-dict-aliases
+ 		(mapcar (lambda (dict-alias)
+ 			  (file-name-sans-extension
+ 			   (file-name-nondirectory dict-alias)))
+ 			(file-expand-wildcards
+ 			 "/Library/Application Support/cocoAspell/aspell*-*-*/*.alias")))))
+       ;; 		 (if (file-readable-p dict-dir) 
+       ;; 		     (setq dict-dir (concat ";dict-dir " dict-dir))
+       ;; 		   (setq dict-dir nil))
+       ;; 		 (concat config-dir dict-dir))))
+       (error nil)));)
+ ;;   (add-hook 'ispell-kill-ispell-hook 'aquamacs--configure-aspell)
+ ;; unit test:
+ ;; (setenv "ASPELL_CONF" nil)
+ ;; (aquamacs--configure-aspell) 
+ ;; (getenv "ASPELL_CONF"))
+ 
  (provide 'ispell)
  
  
