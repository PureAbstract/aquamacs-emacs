Transparency4 patch for Carbon Emacs Package
This file can be redistributed and/or modified under the terms of the GNU
General Public License as published by the Free Software Foundation; either
version 3, or (at your option) any later version.
--- ../emacs-22.1.orig/lisp/frame.el	2007-01-20 22:53:11.000000000 -0500
+++ lisp/frame.el	2007-07-01 20:07:53.000000000 -0400
@@ -929,6 +929,17 @@
   (modify-frame-parameters (selected-frame)
 			   (list (cons 'border-color color-name))))
 
+  (defun set-alpha (alpha &optional frame)
+    "Set the opacity of FRAME to ALPHA.  First argument ALPHA 
+should range from 0 (invisible) to 100 (completely opaque).
+You can also use an floating point number 0.0 to 1.0.
+When called interactively, prompt for the value of the opacity to set.
+FRAME defaults to the selected frame.  To get the frame's current
+alpha value state, use `frame-parameters'."
+    (interactive "XWindow Opacity (0-100 or 0.0-1.0) : ")
+    (modify-frame-parameters frame
+                             (list (cons 'alpha alpha))))
+
 (defun auto-raise-mode (arg)
   "Toggle whether or not the selected frame should auto-raise.
 With arg, turn auto-raise mode on if and only if arg is positive.
--- ../emacs-22.1.orig/src/frame.c	2007-02-19 20:56:11.000000000 -0500
+++ src/frame.c	2007-07-01 20:07:53.000000000 -0400
@@ -60,6 +60,12 @@
    Normally "Emacs".  */
 
 Lisp_Object Vx_resource_class;
+
+#if defined (HAVE_X_WINDOWS) || defined (HAVE_CARBON) || defined (WINDOWSNT)
+/* Lower limit value of frame transparency.  */
+
+Lisp_Object Vframe_alpha_lower_limit;
+#endif
 
 #endif
 
@@ -105,6 +105,9 @@
 Lisp_Object Qleft_fringe, Qright_fringe;
 Lisp_Object Qbuffer_predicate, Qbuffer_list;
 Lisp_Object Qtty_color_mode;
+#if defined (HAVE_X_WINDOWS) || defined (HAVE_CARBON) || defined (WINDOWSNT)
+Lisp_Object Qalpha;
+#endif
 
 Lisp_Object Qfullscreen, Qfullwidth, Qfullheight, Qfullboth;
 
@@ -2580,6 +2581,9 @@
   {"right-fringe",		&Qright_fringe},
   {"wait-for-wm",		&Qwait_for_wm},
   {"fullscreen",                &Qfullscreen},
+#if defined (HAVE_X_WINDOWS) || defined (HAVE_CARBON) || defined (WINDOWSNT)
+  {"alpha",			 &Qalpha},
+#endif
 };
 
 #ifdef HAVE_WINDOW_SYSTEM
@@ -4078,6 +4079,12 @@
 but binding this variable locally around a call to `x-get-resource'
 is a reasonable practice.  See also the variable `x-resource-name'.  */);
   Vx_resource_class = build_string (EMACS_CLASS);
+
+#if defined (HAVE_X_WINDOWS) || defined (HAVE_CARBON) || defined (WINDOWSNT)
+  DEFVAR_LISP ("frame-alpha-lower-limit", &Vframe_alpha_lower_limit,
+    doc: /* Lower limit of alpha value of frame.  */);
+  Vframe_alpha_lower_limit = make_number (20);
+#endif
 #endif
 
   DEFVAR_LISP ("default-frame-alist", &Vdefault_frame_alist,
--- ../emacs-22.1.orig/src/frame.h	2007-01-20 23:18:16.000000000 -0500
+++ src/frame.h	2007-07-01 20:07:53.000000000 -0400
@@ -453,6 +453,11 @@
   /* Additional space to put between text lines on this frame.  */
   int extra_line_spacing;
 
+#if defined (HAVE_X_WINDOWS) || defined (HAVE_CARBON) || defined (WINDOWSNT)
+  /* Opacity of the Frame  */
+  double alpha[2];
+#endif
+
   /* Set to non-zero in change_frame_size when size of frame changed
      Clear the frame in clear_garbaged_frames if set.  */
   unsigned resized_p : 1;
@@ -1009,6 +1020,9 @@
 extern Lisp_Object Qline_spacing;
 extern Lisp_Object Qwait_for_wm;
 extern Lisp_Object Qfullscreen;
+#if defined (HAVE_X_WINDOWS) || defined (HAVE_CARBON) || defined (WINDOWSNT)
+extern Lisp_Object Qalpha;
+#endif
 
 extern Lisp_Object Qleft_fringe, Qright_fringe;
 extern Lisp_Object Qheight, Qwidth;
@@ -1054,6 +1065,9 @@
 
 extern Lisp_Object Vx_resource_name;
 extern Lisp_Object Vx_resource_class;
+#if defined (HAVE_X_WINDOWS) || defined (HAVE_CARBON) || defined (WINDOWSNT)
+extern Lisp_Object Vframe_alpha_lower_limit;
+#endif
 
 
 extern Lisp_Object Qface_set_after_frame_default;
--- ../emacs-22.1.orig/src/macfns.c	2007-03-26 22:31:40.000000000 -0400
+++ src/macfns.c	2007-07-01 20:07:53.000000000 -0400
@@ -223,6 +224,8 @@
 
 
 
+extern void x_set_frame_alpha P_ ((struct frame *));
+
 /* Store the screen positions of frame F into XPTR and YPTR.
    These are the positions of the containing window manager window,
    not Emacs's own window.  */
@@ -1886,6 +1889,62 @@
   x_set_name_internal (f, name);
 }
 
+static void
+x_set_alpha (f, arg, oldval)
+     struct frame *f;
+     Lisp_Object arg, oldval;
+{
+  double alpha = 1.0;
+  double newval[2];
+  int i, ialpha;
+  Lisp_Object item;
+
+  for( i=0; i<2; i++ )
+    newval[i] = 1.0;
+
+  for( i=0; i<2; i++ )
+    {
+      if( CONSP (arg) )
+        {
+          item = CAR (arg);
+          arg  = CDR (arg);
+        }
+      else
+        item=arg;
+
+      if( !NILP (item) )
+        {
+          if( FLOATP(item) )
+            {
+              alpha = XFLOAT_DATA (item);
+              if ( alpha < 0.0 || 1.0 < alpha )
+                args_out_of_range (make_float (0.0), make_float (1.0));
+            }
+          else if( INTEGERP(item) )
+            {
+              ialpha = XINT (item);
+              if ( ialpha < 0 || 100 < ialpha )
+                args_out_of_range (make_number (0), make_number (100));
+              else
+                alpha = ialpha / 100.0;
+            }
+          else
+            wrong_type_argument (Qnumberp, item);
+        }
+      newval[i]=alpha;
+    }
+
+  for ( i=0; i<2; i++ )
+    f->alpha[i] = newval[i];
+
+#if TARGET_API_MAC_CARBON
+  BLOCK_INPUT;
+  x_set_frame_alpha (f);
+  UNBLOCK_INPUT;
+#endif
+
+  return;
+}
 void
 x_set_scroll_bar_default_width (f)
      struct frame *f;
@@ -2760,6 +2836,8 @@
   x_default_parameter (f, parms, Qscroll_bar_width, Qnil,
 		       "scrollBarWidth", "ScrollBarWidth",
 		       RES_TYPE_NUMBER);
+  x_default_parameter (f, parms, Qalpha, Qnil,
+		       "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via change_frame_size.
      Change will not be effected unless different from the current
@@ -4677,6 +4755,7 @@
   x_set_fringe_width,
   0, /* x_set_wait_for_wm, */
   x_set_fullscreen,
+  x_set_alpha,
 };
 
 void
--- ../emacs-22.1.orig/src/macterm.c	2007-05-25 08:43:34.000000000 -0400
+++ src/macterm.c	2007-07-01 20:07:53.000000000 -0400
@@ -2540,6 +2540,37 @@
   return FONT_TYPE_UNKNOWN;
 }
 
+void
+x_set_frame_alpha (f)
+     struct frame *f;
+{
+  struct mac_display_info *dpyinfo = FRAME_MAC_DISPLAY_INFO (f);
+  SInt32 response;
+  OSErr err;
+  double alpha = 1.0, alpha_lower_limit = 1.0;
+
+  BLOCK_INPUT;
+  err = Gestalt (gestaltSystemVersion, &response);
+  UNBLOCK_INPUT;
+
+  if (dpyinfo->x_highlight_frame == f)
+    alpha = f->alpha[0];
+  else
+    alpha = f->alpha[1];
+
+  if( FLOATP(Vframe_alpha_lower_limit) )
+    alpha_lower_limit = XFLOAT_DATA (Vframe_alpha_lower_limit);
+  else if( INTEGERP(Vframe_alpha_lower_limit) )
+    alpha_lower_limit = ( XINT (Vframe_alpha_lower_limit) ) / 100.0;
+
+  if( alpha < 0.0 || 1.0 < alpha ) alpha = 1.0;
+  if( 0.0 < alpha && alpha < alpha_lower_limit && alpha_lower_limit < 1.0 )
+    alpha = alpha_lower_limit;
+
+  if ((err == noErr) && (response >= 0x1020)) {
+    SetWindowAlpha (FRAME_MAC_WINDOW(f), alpha );
+  }
+}
 
 
 /***********************************************************************
@@ -4267,6 +4290,7 @@
     ActivateControl (root_control);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 static void
@@ -4282,6 +4306,7 @@
     DeactivateControl (root_control);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 /* The focus has changed.  Update the frames as necessary to reflect
--- ../emacs-22.1.orig/src/xfns.c	2007-06-02 00:00:11.000000000 -0400
+++ src/xfns.c	2007-07-01 20:07:54.000000000 -0400
@@ -565,6 +567,8 @@
 							     Lisp_Object,
 							     char *, char *,
 							     int));
+extern void x_set_frame_alpha P_ ((struct frame *));
+
 
 
 /* Store the screen positions of frame F into XPTR and YPTR.
@@ -1817,6 +1821,61 @@
 #endif
 }
 
+static void
+x_set_alpha (f, arg, oldval)
+     struct frame *f;
+     Lisp_Object arg, oldval;
+{
+  double alpha = 1.0;
+  double newval[2];
+  int i, ialpha;
+  Lisp_Object item;
+
+  for( i=0; i<2; i++ )
+    newval[i] = 1.0;
+
+  for( i=0; i<2; i++ )
+    {
+      if( CONSP (arg) )
+        {
+          item = CAR (arg);
+          arg  = CDR (arg);
+        }
+      else
+        item=arg;
+
+      if( !NILP (item) )
+        {
+          if( FLOATP(item) )
+            {
+              alpha = XFLOAT_DATA (item);
+              if ( alpha < 0.0 || 1.0 < alpha )
+                args_out_of_range (make_float (0.0), make_float (1.0));
+            }
+          else if( INTEGERP(item) )
+            {
+              ialpha = XINT (item);
+              if ( ialpha < 0 || 100 < ialpha )
+                args_out_of_range (make_number (0), make_number (100));
+              else
+                alpha = ialpha / 100.0;
+            }
+          else
+            wrong_type_argument (Qnumberp, item);
+        }
+      newval[i]=alpha;
+    }
+
+  for ( i=0; i<2; i++ )
+    f->alpha[i] = newval[i];
+
+  BLOCK_INPUT;
+  x_set_frame_alpha (f);
+  UNBLOCK_INPUT;
+
+  return;
+}
+
 
 /* Record in frame F the specified or default value according to ALIST
    of the parameter named PROP (a Lisp symbol).  If no value is
@@ -3372,6 +3443,8 @@
   x_default_parameter (f, parms, Qscroll_bar_width, Qnil,
 		       "scrollBarWidth", "ScrollBarWidth",
 		       RES_TYPE_NUMBER);
+  x_default_parameter (f, parms, Qalpha, Qnil,
+		       "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via change_frame_size.
      Change will not be effected unless different from the current
@@ -5755,6 +5828,7 @@
   x_set_fringe_width,
   x_set_wait_for_wm,
   x_set_fullscreen,
+  x_set_alpha,
 };
 
 void
--- ../emacs-22.1.orig/src/xterm.c	2007-05-25 08:43:35.000000000 -0400
+++ src/xterm.c	2007-07-01 20:07:54.000000000 -0400
@@ -954,6 +954,66 @@
   return FONT_TYPE_UNKNOWN;
 }
 
+#define OPAQUE  0xffffffff
+#define OPACITY "_NET_WM_WINDOW_OPACITY"
+
+void
+x_set_frame_alpha (f)
+     struct frame *f;
+{
+  struct x_display_info *dpyinfo = FRAME_X_DISPLAY_INFO (f);
+  Display *dpy = FRAME_X_DISPLAY (f);
+  Window win = FRAME_OUTER_WINDOW (f);
+  if (FRAME_X_DISPLAY_INFO (f)->root_window != FRAME_X_OUTPUT (f)->parent_desc)
+    /* Since the WM decoration lies under the FRAME_OUTER_WINDOW,
+       we must treat the former instead of the latter. */
+    win = FRAME_X_OUTPUT(f)->parent_desc;
+
+  double alpha = 1.0, alpha_lower_limit = 1.0;
+
+  if (dpyinfo->x_highlight_frame == f)
+    alpha = f->alpha[0];
+  else
+    alpha = f->alpha[1];
+
+  if( FLOATP(Vframe_alpha_lower_limit) )
+    alpha_lower_limit = XFLOAT_DATA (Vframe_alpha_lower_limit);
+  else if( INTEGERP(Vframe_alpha_lower_limit) )
+    alpha_lower_limit = ( XINT (Vframe_alpha_lower_limit) ) / 100.0;
+
+  if( alpha < 0.0 || 1.0 < alpha ) alpha = 1.0;
+  if ( 0.0 < alpha && alpha < alpha_lower_limit && alpha_lower_limit < 1.0)
+    alpha = alpha_lower_limit;
+
+  unsigned int opac = (unsigned int)(alpha * OPAQUE);
+
+  /* return unless necessary */
+  {
+    unsigned char *data;
+    Atom actual;
+    int format;
+    unsigned long n, left;
+
+    XGetWindowProperty(dpy, win, XInternAtom(dpy, OPACITY, False),
+		       0L, 1L, False, XA_CARDINAL, &actual, &format, &n, &left,
+		       (unsigned char **) &data);
+    if (data != None)
+      if (*(unsigned int *)data == opac)
+	{
+	  XFree ((void *) data);
+	  return;
+	}
+      else
+       {
+	  XFree ((void *) data);
+       }
+  }
+
+  XChangeProperty (dpy, win, XInternAtom (dpy, OPACITY, False),
+		   XA_CARDINAL, 32, PropModeReplace,
+		   (unsigned char *) &opac, 1L);
+  XSync (dpy, False);
+}
 
 
 /***********************************************************************
@@ -3157,6 +3210,7 @@
 		    f->output_data.x->border_pixel);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 static void
@@ -3172,6 +3226,7 @@
 			  f->output_data.x->border_tile);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 /* The focus has changed.  Update the frames as necessary to reflect
