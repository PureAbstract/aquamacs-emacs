--- lisp/frame.el.original	2005-08-06 14:02:55.000000000 +0900
+++ lisp/frame.el	2005-08-06 14:09:08.000000000 +0900
@@ -926,6 +926,32 @@
   (modify-frame-parameters (selected-frame)
 			   (list (cons 'border-color color-name))))
 
+(when (memq system-type '(windows-nt darwin))
+  (defun set-active-alpha (alpha &optional frame)
+    "Set the opacity of FRAME in active state to ALPHA.
+First argument ALPHA should range from 0.0 (invisible) to 1.0
+(completely opaque).
+When called interactively, prompt for the value of the opacity to
+set.  FRAME defaults to the selected frame.  To get the frame's
+current active alpha value state, use `frame-parameters'."
+    (interactive "nActive alpha (0.0 - 1.0): ")
+    (when (or (< alpha 0.0) (> alpha 1.0))
+      (error "Alpha value must be between 0.0 and 1.0, inclusive"))
+    (modify-frame-parameters frame
+                             (list (cons 'active-alpha alpha))))
+  (defun set-inactive-alpha (alpha &optional frame)
+    "Set the opacity of FRAME in inactive state to ALPHA.
+First argument ALPHA should range from 0.0 (invisible) to 1.0
+(completely opaque).
+When called interactively, prompt for the value of the opacity to
+set.  FRAME defaults to the selected frame.  To get the frame's
+current inactive alpha value state, use `frame-parameters'."
+    (interactive "nInactive alpha (0.0 - 1.0): ")
+    (when (or (< alpha 0.0) (> alpha 1.0))
+      (error "Alpha value must be between 0.0 and 1.0, inclusive"))
+    (modify-frame-parameters frame
+                             (list (cons 'inactive-alpha alpha)))))
+
 (defun auto-raise-mode (arg)
   "Toggle whether or not the selected frame should auto-raise.
 With arg, turn auto-raise mode on if and only if arg is positive.
--- src/frame.c.original	2005-08-06 14:02:55.000000000 +0900
+++ src/frame.c	2005-08-06 14:04:23.000000000 +0900
@@ -106,6 +106,10 @@
 Lisp_Object Qleft_fringe, Qright_fringe;
 Lisp_Object Qbuffer_predicate, Qbuffer_list;
 Lisp_Object Qtty_color_mode;
+#if defined (HAVE_CARBON) || defined (WINDOWSNT)
+Lisp_Object Qactive_alpha;
+Lisp_Object Qinactive_alpha;
+#endif
 
 Lisp_Object Qfullscreen, Qfullwidth, Qfullheight, Qfullboth;
 
@@ -2580,6 +2584,10 @@
   {"right-fringe",		&Qright_fringe},
   {"wait-for-wm",		&Qwait_for_wm},
   {"fullscreen",                &Qfullscreen},
+#if defined (HAVE_CARBON) || defined (WINDOWSNT)
+  {"active-alpha",		&Qactive_alpha},
+  {"inactive-alpha",		&Qinactive_alpha},
+#endif
 };
 
 #ifdef HAVE_WINDOW_SYSTEM
--- src/frame.h.original	2005-08-06 14:02:55.000000000 +0900
+++ src/frame.h	2005-08-06 14:04:23.000000000 +0900
@@ -451,6 +451,11 @@
   /* Additional space to put between text lines on this frame.  */
   int extra_line_spacing;
 
+#if defined (HAVE_CARBON) || defined (WINDOWSNT)
+  /* Opacity of the Frame, which should be a number between 0.0 and 1.0  */
+  float active_alpha, inactive_alpha;
+#endif
+
   /* Set to non-zero in change_frame_size when size of frame changed
      Clear the frame in clear_garbaged_frames if set.  */
   unsigned resized_p : 1;
@@ -1007,6 +1012,10 @@
 extern Lisp_Object Qline_spacing;
 extern Lisp_Object Qwait_for_wm;
 extern Lisp_Object Qfullscreen;
+#if defined (HAVE_CARBON) || defined (WINDOWSNT)
+extern Lisp_Object Qactive_alpha;
+extern Lisp_Object Qinactive_alpha;
+#endif
 
 extern Lisp_Object Qleft_fringe, Qright_fringe;
 extern Lisp_Object Qheight, Qwidth;
--- src/macfns.c.original	2005-08-06 14:02:55.000000000 +0900
+++ src/macfns.c	2005-08-06 14:04:23.000000000 +0900
@@ -218,6 +218,8 @@
 
 
 
+extern void x_set_frame_alpha P_ ((struct frame *, int));
+
 /* Store the screen positions of frame F into XPTR and YPTR.
    These are the positions of the containing window manager window,
    not Emacs's own window.  */
@@ -1926,6 +1928,84 @@
 #endif /* not MAC_OSX */
 }
 
+/* Change the opacity of frame F to ALPHA.
+   ALPHA must be a number between 0.0 and 1.0
+
+   The frame will become completely invisible if ALPHA is 0.0,
+   while the value of 1.0 makes it completely opaque.  */
+
+static void
+x_set_active_alpha (f, alpha, old_alpha)
+     struct frame *f;
+     Lisp_Object alpha, old_alpha;
+{
+  struct mac_display_info *dpyinfo = FRAME_MAC_DISPLAY_INFO (f);
+
+  /* Don't change the alpha if it's already ALPHA.  */
+  if (EQ (alpha, f->active_alpha))
+    return;
+
+  if (NILP (alpha))
+    return;
+
+  if ((XFLOAT_DATA (alpha) < 0.0) || (XFLOAT_DATA (alpha) > 1.0))
+    {
+      f->active_alpha = XFLOAT_DATA (old_alpha);
+      return;
+    }
+
+  if (FLOATP (alpha))
+    {
+      f->active_alpha = XFLOAT_DATA (alpha);
+
+#if TARGET_API_MAC_CARBON
+      BLOCK_INPUT;
+
+      if(dpyinfo->x_highlight_frame == f)
+        {
+          x_set_frame_alpha (f, 1);
+        }
+
+      UNBLOCK_INPUT;
+#endif
+    }
+
+  return;
+}
+
+static void
+x_set_inactive_alpha (f, alpha, old_alpha)
+     struct frame *f;
+     Lisp_Object alpha, old_alpha;
+{
+  struct mac_display_info *dpyinfo = FRAME_MAC_DISPLAY_INFO (f);
+
+  /* Don't change the alpha if it's already ALPHA.  */
+  if (EQ (alpha, f->inactive_alpha))
+    return;
+
+  if (NILP (alpha))
+    return;
+
+  if ((XFLOAT_DATA (alpha) < 0.0) || (XFLOAT_DATA (alpha) > 1.0))
+    {
+      f->inactive_alpha = XFLOAT_DATA (old_alpha);
+      return;
+    }
+
+  if (FLOATP (alpha))
+    {
+      f->inactive_alpha = XFLOAT_DATA (alpha);
+      BLOCK_INPUT;
+      if(dpyinfo->x_highlight_frame != f)
+        {
+          x_set_frame_alpha (f, 0);
+        }
+	 UNBLOCK_INPUT;
+    }
+
+  return;
+}
 
 /* Subroutines of creating a frame.  */
 
@@ -2636,6 +2714,10 @@
   x_default_parameter (f, parms, Qscroll_bar_width, Qnil,
 		       "scrollBarWidth", "ScrollBarWidth",
 		       RES_TYPE_NUMBER);
+  x_default_parameter (f, parms, Qactive_alpha, make_float(1.0),
+		       "activeAlpha", "ActiveAlpha", RES_TYPE_FLOAT);
+  x_default_parameter (f, parms, Qinactive_alpha, make_float(1.0),
+		       "inactiveAlpha", "InactiveAlpha", RES_TYPE_FLOAT);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via change_frame_size.
      Change will not be effected unless different from the current
@@ -4340,6 +4422,8 @@
   x_set_fringe_width,
   0, /* x_set_wait_for_wm, */
   x_set_fullscreen,
+  x_set_active_alpha,
+  x_set_inactive_alpha,
 };
 
 void
--- src/macterm.c.original	2005-08-06 14:02:55.000000000 +0900
+++ src/macterm.c	2005-08-06 14:04:24.000000000 +0900
@@ -1687,6 +1687,23 @@
   return FONT_TYPE_UNKNOWN;
 }
 
+void
+x_set_frame_alpha (f, activate_p)
+     struct frame *f;
+     int activate_p;
+{
+  SInt32 response;
+  OSErr err;
+
+  BLOCK_INPUT;
+  err = Gestalt (gestaltSystemVersion, &response);
+  UNBLOCK_INPUT;
+
+  if ((err == noErr) && (response >= 0x1020)) {
+    SetWindowAlpha (FRAME_MAC_WINDOW(f),
+                    activate_p? f->active_alpha: f->inactive_alpha);
+  }
+}
 
 
 /***********************************************************************
@@ -3403,6 +3420,7 @@
     ActivateControl (root_control);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f, 1);
 }
 
 static void
@@ -3418,6 +3436,7 @@
     DeactivateControl (root_control);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f, 0);
 }
 
 /* The focus has changed.  Update the frames as necessary to reflect
--- src/w32fns.c.original	2005-08-06 14:02:55.000000000 +0900
+++ src/w32fns.c	2005-08-06 14:04:24.000000000 +0900
@@ -70,6 +70,8 @@
 
 extern char *lispy_function_keys[];
 
+extern void x_set_frame_alpha P_ ((struct frame *, int));
+
 /* The gray bitmap `bitmaps/gray'.  This is done because w32term.c uses
    it, and including `bitmaps/gray' more than once is a problem when
    config.h defines `static' as an empty replacement string.  */
@@ -262,6 +264,7 @@
 TrackMouseEvent_Proc track_mouse_event_fn = NULL;
 ClipboardSequence_Proc clipboard_sequence_fn = NULL;
 extern AppendMenuW_Proc unicode_append_menu;
+extern SetLayeredWindowAttributes_Proc set_layered_window_attributes_fn;
 
 /* W95 mousewheel handler */
 unsigned int msh_mousewheel = 0;
@@ -1978,6 +1981,80 @@
 				      wid - 1) / wid;
 }
 
+/* Change the opacity of frame F to ALPHA.
+   ALPHA must be a number between 0.0 and 1.0
+
+   The frame will become completely invisible if ALPHA is 0.0,
+   while the value of 1.0 makes it completely opaque.  */
+
+static void
+x_set_active_alpha (f, alpha, old_alpha)
+     struct frame *f;
+     Lisp_Object alpha, old_alpha;
+{
+  struct w32_display_info *dpyinfo = FRAME_W32_DISPLAY_INFO (f);
+
+  /* Don't change the alpha if it's already ALPHA.  */
+  if (EQ (alpha, f->active_alpha))
+    return;
+
+  if (NILP (alpha))
+    return;
+
+  if ((XFLOAT_DATA (alpha) < 0.0) || (XFLOAT_DATA (alpha) > 1.0))
+    {
+      f->active_alpha = XFLOAT_DATA (old_alpha);
+      return;
+    }
+
+  if (FLOATP (alpha))
+    {
+      f->active_alpha = XFLOAT_DATA (alpha);
+
+      BLOCK_INPUT;
+
+      if(dpyinfo->x_highlight_frame == f)
+        {
+          x_set_frame_alpha (f, 1);
+        }
+
+      UNBLOCK_INPUT;
+    }
+
+  return;
+}
+
+static void
+x_set_inactive_alpha (f, alpha, old_alpha)
+     struct frame *f;
+     Lisp_Object alpha, old_alpha;
+{
+  struct w32_display_info *dpyinfo = FRAME_W32_DISPLAY_INFO (f);
+
+  /* Don't change the alpha if it's already ALPHA.  */
+  if (EQ (alpha, f->inactive_alpha))
+    return;
+
+  if (NILP (alpha))
+    return;
+
+  if ((XFLOAT_DATA (alpha) < 0.0) || (XFLOAT_DATA (alpha) > 1.0))
+    {
+      f->inactive_alpha = XFLOAT_DATA (old_alpha);
+      return;
+    }
+
+  if (FLOATP (alpha))
+    {
+      f->inactive_alpha = XFLOAT_DATA (alpha);
+      if(dpyinfo->x_highlight_frame != f)
+        {
+          x_set_frame_alpha (f, 0);
+        }
+    }
+
+  return;
+}
 
 /* Subroutines of creating a frame.  */
 
@@ -4321,6 +4398,10 @@
 		       "cursorType", "CursorType", RES_TYPE_SYMBOL);
   x_default_parameter (f, parameters, Qscroll_bar_width, Qnil,
 		       "scrollBarWidth", "ScrollBarWidth", RES_TYPE_NUMBER);
+  x_default_parameter (f, parameters, Qactive_alpha, make_float(1.0),
+		       "activeAlpha", "ActiveAlpha", RES_TYPE_FLOAT);
+  x_default_parameter (f, parameters, Qinactive_alpha, make_float(1.0),
+		       "inactiveAlpha", "InactiveAlpha", RES_TYPE_FLOAT);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via change_frame_size.
      Change will not be effected unless different from the current
@@ -8473,6 +8554,8 @@
   x_set_fringe_width,
   0, /* x_set_wait_for_wm, */
   x_set_fullscreen,
+  x_set_active_alpha,
+  x_set_inactive_alpha,
 };
 
 void
@@ -8914,6 +8997,9 @@
   /* ditto for GetClipboardSequenceNumber.  */
   clipboard_sequence_fn = (ClipboardSequence_Proc)
     GetProcAddress (user32_lib, "GetClipboardSequenceNumber");
+  /* ditto for SetLayeredWindowAttributes.  */
+  set_layered_window_attributes_fn = (SetLayeredWindowAttributes_Proc)
+    GetProcAddress (user32_lib, "SetLayeredWindowAttributes");
 
   DEFVAR_INT ("w32-ansi-code-page",
 	      &w32_ansi_code_page,
--- src/w32term.c.original	2005-08-06 14:02:55.000000000 +0900
+++ src/w32term.c	2005-08-06 14:04:24.000000000 +0900
@@ -280,6 +280,8 @@
 
 static Lisp_Object Qvendor_specific_keysyms;
 
+SetLayeredWindowAttributes_Proc set_layered_window_attributes_fn = NULL;
+
 
 /***********************************************************************
 			      Debugging
@@ -1211,6 +1213,25 @@
     return ANSI_FONT;
 }
 
+void
+x_set_frame_alpha (f, activate_p)
+     struct frame *f;
+     int activate_p;
+{
+  Window window = FRAME_W32_WINDOW (f);
+
+  if (set_layered_window_attributes_fn != NULL) {
+    SetWindowLong (window, GWL_EXSTYLE,
+                   GetWindowLong (window, GWL_EXSTYLE)|WS_EX_LAYERED);
+    set_layered_window_attributes_fn (FRAME_W32_WINDOW (f),
+                                      RGB(255, 255, 255),
+                                      (int)((activate_p?
+                                             f->active_alpha:
+                                             f->inactive_alpha)
+                                            * 255.0),
+                                      LWA_ALPHA);
+  }
+}
 
 
 /***********************************************************************
@@ -2810,6 +2831,7 @@
      struct frame *f;
 {
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f, 1);
 }
 
 static void
@@ -2817,6 +2839,7 @@
      struct frame *f;
 {
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f, 0);
 }
 
 /* The focus has changed.  Update the frames as necessary to reflect
--- src/w32term.h.original	2005-08-06 14:02:55.000000000 +0900
+++ src/w32term.h	2005-08-06 14:04:24.000000000 +0900
@@ -643,6 +643,14 @@
 
 #define WND_EXTRA_BYTES     (WND_LAST_INDEX)
 
+/* for transparency functions */
+#ifndef LWA_ALPHA
+#define LWA_ALPHA 2
+#endif
+#ifndef WS_EX_LAYERED
+#define WS_EX_LAYERED 0x80000   /* w2k */
+#endif
+
 extern DWORD dwWindowsThreadId;
 extern HANDLE hWindowsThread;
 extern DWORD dwMainThreadId;
@@ -755,6 +763,8 @@
       ? BDF_1D_FONT : BDF_2D_FONT))
 
 typedef DWORD (WINAPI * ClipboardSequence_Proc) ();
+typedef DWORD (WINAPI * SetLayeredWindowAttributes_Proc)
+  (HWND, DWORD, BYTE, DWORD);
 typedef BOOL (WINAPI * AppendMenuW_Proc) (
     IN HMENU,
     IN UINT,
