*** lisp/recentf.el	06 Apr 2008 13:51:37 +0200	1.56.2.2
--- lisp/recentf.el	10 Aug 2008 19:04:41 +0200	
***************
*** 394,400 ****
    "Convert file NAME to absolute, and canonicalize it.
  NAME is first passed to the function `expand-file-name', then to
  `recentf-filename-handlers' to post process it."
!   (recentf-apply-filename-handlers (expand-file-name name)))
  
  (defun recentf-include-p (filename)
    "Return non-nil if FILENAME should be included in the recent list.
--- 394,402 ----
    "Convert file NAME to absolute, and canonicalize it.
  NAME is first passed to the function `expand-file-name', then to
  `recentf-filename-handlers' to post process it."
!   (condition-case nil
!       (recentf-apply-filename-handlers (expand-file-name name))
!     (error name)))
  
  (defun recentf-include-p (filename)
    "Return non-nil if FILENAME should be included in the recent list.
*** lisp/erc/erc.el	28 Jul 2008 23:15:49 +0100	1.52
--- lisp/erc/erc.el	17 Aug 2008 19:44:33 +0100	
***************
*** 6085,6092 ****
  	(let ((header (if erc-header-line-format
  			  (format-spec erc-header-line-format spec)
  			nil)))
! 	  (cond ((null header)
! 		 (setq header-line-format nil))
  		(erc-header-line-uses-help-echo-p
  		 (let ((help-echo (with-temp-buffer
  				    (insert header)
--- 6085,6091 ----
  	(let ((header (if erc-header-line-format
  			  (format-spec erc-header-line-format spec)
  			nil)))
! 	  (cond ((null header))
  		(erc-header-line-uses-help-echo-p
  		 (let ((help-echo (with-temp-buffer
  				    (insert header)
Index: xdisp.c
The following stuff adapts the window background color to match 
the bg color of the default face used in the buffer.
===================================================================
RCS file: /sources/emacs/emacs/src/xdisp.c,v
retrieving revision 1.1149.2.33
diff -c -r1.1149.2.33 xdisp.c
*** src/xdisp.c	26 Aug 2008 11:11:46 -0000	1.1149.2.33
--- src/xdisp.c	22 Dec 2008 00:03:30 -0000
***************
*** 15759,15765 ****
  	  it->len = 1;
  
  	  if (default_face_p)
! 	    it->face_id = DEFAULT_FACE_ID;
  	  else if (it->face_before_selective_p)
  	    it->face_id = it->saved_face_id;
  	  face = FACE_FROM_ID (it->f, it->face_id);
--- 15920,15926 ----
  	  it->len = 1;
  
  	  if (default_face_p)
! 	    it->face_id = lookup_basic_face (it->f, DEFAULT_FACE_ID); 
  	  else if (it->face_before_selective_p)
  	    it->face_id = it->saved_face_id;
  	  face = FACE_FROM_ID (it->f, it->face_id);
Index: macterm.c
===================================================================
RCS file: /sources/emacs/emacs/src/Attic/macterm.c,v
retrieving revision 1.214.2.31
diff -c -r1.214.2.31 macterm.c
*** src/macterm.c	2 Sep 2008 08:19:06 -0000	1.214.2.31
--- src/macterm.c	22 Dec 2008 00:05:21 -0000
***************
*** 469,485 ****
  
  
  static void
! mac_erase_rectangle (f, gc, x, y, width, height)
       struct frame *f;
       GC gc;
       int x, y;
       unsigned int width, height;
  {
  #if USE_CG_DRAWING
    CGContextRef context;
  
    context = mac_begin_cg_clip (f, gc);
!   CG_SET_FILL_COLOR_WITH_GC_BACKGROUND (context, gc);
    CGContextFillRect (context, mac_rect_make (f, x, y, width, height));
    mac_end_cg_clip (f);
  #else
--- 509,550 ----
  
  
  static void
! mac_erase_rectangle_with_color (f, gc, x, y, width, height, color)
       struct frame *f;
       GC gc;
       int x, y;
       unsigned int width, height;
+      unsigned long color;
  {
  #if USE_CG_DRAWING
    CGContextRef context;
+   context = mac_begin_cg_clip (f, gc);
+   CG_SET_FILL_COLOR (context, color); 
+   CGContextFillRect (context, mac_rect_make (f, x, y, width, height));
+   mac_end_cg_clip (f);
+ #else
+   Rect r;
+ 
+   mac_begin_clip (f, gc);
+   RGBBackColor (color);
+   SetRect (&r, x, y, x + width, y + height);
+   EraseRect (&r);
+   RGBBackColor (GC_BACK_COLOR (FRAME_NORMAL_GC (f)));
+   mac_end_clip (f, gc);
+ #endif
+ }
  
+ static void
+ mac_erase_rectangle (f, gc, x, y, width, height)
+      struct frame *f;
+      GC gc;
+      int x, y;
+      unsigned int width, height;
+ {
+ #if USE_CG_DRAWING
+   CGContextRef context;
    context = mac_begin_cg_clip (f, gc);
!   CG_SET_FILL_COLOR_WITH_GC_BACKGROUND (context, gc); 
    CGContextFillRect (context, mac_rect_make (f, x, y, width, height));
    mac_end_cg_clip (f);
  #else
***************
*** 5258,5264 ****
       struct frame *f;
       int x, y, width, height;
  {
!   mac_clear_area (f, x, y, width, height);
  }
  
  
--- 5478,5513 ----
       struct frame *f;
       int x, y, width, height;
  {
!   struct buffer *old_buffer = NULL;
!   struct buffer *b;
!   unsigned long color = FRAME_NORMAL_GC (f)->xgcv.background;
! 
!   struct face *face = NULL; //  FRAME_DEFAULT_FACE (f);
! 
!   //   struct window *w = updated_window;
!   // is the current buffer correct?
!   if (updated_window)
!     {
!       if (current_buffer && XBUFFER (updated_window->buffer) != current_buffer)
! 	{
! 	  old_buffer = current_buffer;
! 	  set_buffer_internal_1 (XBUFFER (updated_window->buffer));
! 	}
!     
!   
!   int remapped_face = lookup_basic_face (f, DEFAULT_FACE_ID);
!   if (remapped_face)
!     face = FACE_FROM_ID (f, remapped_face);
! 
!   if (old_buffer)
!     set_buffer_internal_1 (old_buffer);
!   }
! 
!   if (face) {
!     mac_erase_rectangle_with_color (f, FRAME_NORMAL_GC (f), x, y, width, height, face->background);
!   } else
!     {
!       mac_clear_area (f, x, y, width, height);}
  }
  
  
