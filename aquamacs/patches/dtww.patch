DTWW patch
authored by Kim Storm and Chong Yidong
backported to 22 for Aquamacs by David Reitter Jul2008
This patch is part of Aquamacs.
Index: xdisp.c
===================================================================
RCS file: /sources/emacs/emacs/src/xdisp.c,v
retrieving revision 1.1149.2.27
diff -c -r1.1149.2.27 xdisp.c
*** src/xdisp.c	23 Apr 2008 08:56:30 -0000	1.1149.2.27
--- src/xdisp.c	5 Jul 2008 12:51:32 -0000
***************
*** 418,424 ****
  /* Nonzero means truncate lines in all windows less wide than the
     frame.  */
  
! int truncate_partial_width_windows;
  
  /* A flag to control how to display unibyte 8-bit character.  */
  
--- 418,424 ----
  /* Nonzero means truncate lines in all windows less wide than the
     frame.  */
  
! Lisp_Object Vtruncate_partial_width_windows;
  
  /* A flag to control how to display unibyte 8-bit character.  */
  
***************
*** 2603,2621 ****
      it->tab_width = 8;
  
    /* Are lines in the display truncated?  */
!   it->truncate_lines_p
!     = (base_face_id != DEFAULT_FACE_ID
!        || XINT (it->w->hscroll)
!        || (truncate_partial_width_windows
! 	   && !WINDOW_FULL_WIDTH_P (it->w))
!        || !NILP (current_buffer->truncate_lines));
  
    /* Get dimensions of truncation and continuation glyphs.  These are
       displayed as fringe bitmaps under X, so we don't need them for such
       frames.  */
    if (!FRAME_WINDOW_P (it->f))
      {
!       if (it->truncate_lines_p)
  	{
  	  /* We will need the truncation glyph.  */
  	  xassert (it->glyph_row == NULL);
--- 2603,2629 ----
      it->tab_width = 8;
  
    /* Are lines in the display truncated?  */
!   if (base_face_id != DEFAULT_FACE_ID
!       || XINT (it->w->hscroll)
!       || (! WINDOW_FULL_WIDTH_P (it->w)
! 	  && ((!NILP (Vtruncate_partial_width_windows)
! 	       && !INTEGERP (Vtruncate_partial_width_windows))
! 	      || (INTEGERP (Vtruncate_partial_width_windows)
! 		  && (WINDOW_TOTAL_COLS (it->w)
! 		      < XINT (Vtruncate_partial_width_windows))))))
!     it->line_wrap = TRUNCATE;
!   else if (NILP (current_buffer->truncate_lines))
!     it->line_wrap = NILP (current_buffer->word_wrap)
!       ? WINDOW_WRAP : WORD_WRAP;
!   else
!     it->line_wrap = TRUNCATE;
  
    /* Get dimensions of truncation and continuation glyphs.  These are
       displayed as fringe bitmaps under X, so we don't need them for such
       frames.  */
    if (!FRAME_WINDOW_P (it->f))
      {
!       if (it->line_wrap == TRUNCATE)
  	{
  	  /* We will need the truncation glyph.  */
  	  xassert (it->glyph_row == NULL);
***************
*** 2665,2671 ****
  	 for window-based redisplay.  */
        if (!FRAME_WINDOW_P (it->f))
  	{
! 	  if (it->truncate_lines_p)
  	    it->last_visible_x -= it->truncation_pixel_width;
  	  else
  	    it->last_visible_x -= it->continuation_pixel_width;
--- 2673,2679 ----
  	 for window-based redisplay.  */
        if (!FRAME_WINDOW_P (it->f))
  	{
! 	  if (it->line_wrap == TRUNCATE)
  	    it->last_visible_x -= it->truncation_pixel_width;
  	  else
  	    it->last_visible_x -= it->continuation_pixel_width;
***************
*** 2738,2744 ****
  
    /* Don't reseat to previous visible line start if current start
       position is in a string or image.  */
!   if (it->method == GET_FROM_BUFFER && !it->truncate_lines_p)
      {
        int start_at_line_beg_p;
        int first_y = it->current_y;
--- 2746,2752 ----
  
    /* Don't reseat to previous visible line start if current start
       position is in a string or image.  */
!   if (it->method == GET_FROM_BUFFER && it->line_wrap != TRUNCATE)
      {
        int start_at_line_beg_p;
        int first_y = it->current_y;
***************
*** 2763,2769 ****
  	     taken us to the start of the continuation line but to the
  	     end of the continued line.  */
  	  if (it->current_x > 0
! 	      && !it->truncate_lines_p /* Lines are continued.  */
  	      && (/* And glyph doesn't fit on the line.  */
  		  new_x > it->last_visible_x
  		  /* Or it fits exactly and we're on a window
--- 2771,2777 ----
  	     taken us to the start of the continuation line but to the
  	     end of the continued line.  */
  	  if (it->current_x > 0
! 	      && it->line_wrap != TRUNCATE /* Lines are continued.  */
  	      && (/* And glyph doesn't fit on the line.  */
  		  new_x > it->last_visible_x
  		  /* Or it fits exactly and we're on a window
***************
*** 5278,5283 ****
--- 5286,5292 ----
  	pos = --IT_CHARPOS (it2);
  	--IT_BYTEPOS (it2);
  	it2.sp = 0;
+ 	it2.string_from_display_prop_p = 0;
  	if (handle_display_prop (&it2) == HANDLED_RETURN
  	    && !NILP (val = get_char_property_and_overlay
  		      (make_number (pos), Qdisplay, Qnil, &overlay))
***************
*** 5428,5433 ****
--- 5437,5443 ----
    IT_STRING_CHARPOS (*it) = -1;
    IT_STRING_BYTEPOS (*it) = -1;
    it->string = Qnil;
+   it->string_from_display_prop_p = 0;
    it->method = GET_FROM_BUFFER;
    it->object = it->w->buffer;
    it->area = TEXT_AREA;
***************
*** 6488,6498 ****
--- 6498,6520 ----
  {
    enum move_it_result result = MOVE_UNDEFINED;
    struct glyph_row *saved_glyph_row;
+   struct it wrap_it, atpos_it, atx_it;
+   int may_wrap = 0;
  
    /* Don't produce glyphs in produce_glyphs.  */
    saved_glyph_row = it->glyph_row;
    it->glyph_row = NULL;
  
+    /* Use wrap_it to save a copy of IT wherever a word wrap could
+       occur.  Use atpos_it to save a copy of IT at the desired buffer
+       position, if found, so that we can scan ahead and check if the
+       word later overshoots the window edge.  Use atx_it similarly, for
+       pixel positions.  */
+    wrap_it.sp = -1;
+    atpos_it.sp = -1;
+    atx_it.sp = -1;
+   
+ 
  #define BUFFER_POS_REACHED_P()					\
    ((op & MOVE_TO_POS) != 0					\
     && BUFFERP (it->object)					\
***************
*** 6512,6547 ****
  	  && it->method == GET_FROM_BUFFER
  	  && IT_CHARPOS (*it) > to_charpos)
  	{
! 	  result = MOVE_POS_MATCH_OR_ZV;
! 	  break;
  	}
  
        /* Stop when ZV reached.
           We used to stop here when TO_CHARPOS reached as well, but that is
           too soon if this glyph does not fit on this line.  So we handle it
           explicitly below.  */
!       if (!get_next_display_element (it)
! 	  || (it->truncate_lines_p
! 	      && BUFFER_POS_REACHED_P ()))
  	{
  	  result = MOVE_POS_MATCH_OR_ZV;
  	  break;
  	}
  
!       /* The call to produce_glyphs will get the metrics of the
! 	 display element IT is loaded with.  We record in x the
! 	 x-position before this display element in case it does not
! 	 fit on the line.  */
!       x = it->current_x;
! 
!       /* Remember the line height so far in case the next element doesn't
! 	 fit on the line.  */
!       if (!it->truncate_lines_p)
  	{
  	  ascent = it->max_ascent;
  	  descent = it->max_descent;
  	}
  
        PRODUCE_GLYPHS (it);
  
        if (it->area != TEXT_AREA)
--- 6534,6616 ----
  	  && it->method == GET_FROM_BUFFER
  	  && IT_CHARPOS (*it) > to_charpos)
  	{
! 	  if (it->line_wrap == WORD_WRAP)
! 	    {
! 	       /* If wrap_it is valid, the current position might be in
!  		 a word that is wrapped to the next line, so continue
!  		 to see if that happens.  */
! 	      if (wrap_it.sp < 0)
! 		{
! 		  result = MOVE_POS_MATCH_OR_ZV;
! 		  break;
! 		}
! 	      if (atpos_it.sp < 0)
! 		atpos_it = *it;
! 	    }
! 	  else
! 	    {
! 	      result = MOVE_POS_MATCH_OR_ZV;
! 	      break;
! 	    }
  	}
  
        /* Stop when ZV reached.
           We used to stop here when TO_CHARPOS reached as well, but that is
           too soon if this glyph does not fit on this line.  So we handle it
           explicitly below.  */
!       if (!get_next_display_element (it))
  	{
  	  result = MOVE_POS_MATCH_OR_ZV;
  	  break;
  	}
  
!       if (it->line_wrap == TRUNCATE)
  	{
+ 	  if (BUFFER_POS_REACHED_P ())
+ 	    {
+ 	      result = MOVE_POS_MATCH_OR_ZV;
+ 	      break;
+ 	    }
+ 	}
+       else
+ 	{
+ 	  /* Remember the line height so far in case the next element
+ 	     doesn't fit on the line.  */
  	  ascent = it->max_ascent;
  	  descent = it->max_descent;
+ 
+ 	  if (it->line_wrap == WORD_WRAP)
+ 	    {
+ 	      if (it->what == IT_CHARACTER
+ 		  && (it->c == ' ' || it->c == '\t'))
+ 		may_wrap = 1;
+ 	      else if (may_wrap)
+ 		{
+ 		  /* We are done if the position is already found.  */
+ 		  if (atpos_it.sp >= 0)
+ 		    {
+ 		      *it = atpos_it;
+ 		      result = MOVE_POS_MATCH_OR_ZV;
+ 		      goto done;
+ 		    }
+ 		  if (atx_it.sp >= 0)
+ 		    {
+ 		      *it = atx_it;
+ 		      result = MOVE_X_REACHED;
+ 		      goto done;
+ 		    }
+ 		  wrap_it = *it;
+ 		  may_wrap = 0;
+ 		}
+ 	    }
  	}
  
+       /* The call to produce_glyphs will get the metrics of the
+ 	 display element IT is loaded with.  Record the x-position
+ 	 before this display element, in case it doesn't fit on the
+ 	 line.  */
+       x = it->current_x;
+ 
        PRODUCE_GLYPHS (it);
  
        if (it->area != TEXT_AREA)
***************
*** 6581,6609 ****
  	    {
  	      new_x = x + single_glyph_width;
  
! 	      /* We want to leave anything reaching TO_X to the caller.  */
! 	      if ((op & MOVE_TO_X) && new_x > to_x)
  		{
- 		  if (BUFFER_POS_REACHED_P ())
- 		    goto buffer_pos_reached;
  		  it->current_x = x;
  		  result = MOVE_X_REACHED;
  		  break;
  		}
! 	      else if (/* Lines are continued.  */
! 		       !it->truncate_lines_p
! 		       && (/* And glyph doesn't fit on the line.  */
! 			   new_x > it->last_visible_x
! 			   /* Or it fits exactly and we're on a window
! 			      system frame.  */
! 			   || (new_x == it->last_visible_x
! 			       && FRAME_WINDOW_P (it->f))))
  		{
  		  if (/* IT->hpos == 0 means the very first glyph
  			 doesn't fit on the line, e.g. a wide image.  */
  		      it->hpos == 0
  		      || (new_x == it->last_visible_x
! 			  && FRAME_WINDOW_P (it->f)))
  		    {
  		      ++it->hpos;
  		      it->current_x = new_x;
--- 6650,6708 ----
  	    {
  	      new_x = x + single_glyph_width;
  
!         /* We want to leave anything reaching TO_X to the caller.  */
!         if ((op & MOVE_TO_X) && new_x > to_x)
!   	{
! 	  if (it->line_wrap == WORD_WRAP)
!   	    {
! 	      if (BUFFER_POS_REACHED_P ())
!   		{
!   		  if (wrap_it.sp < 0)
!   		    goto buffer_pos_reached;
! 		  else if (atpos_it.sp < 0)
! 		    {
! 		      atpos_it = *it;
! 		      atpos_it.current_x = x;
! 		    }
!   		}
! 	      else if (wrap_it.sp < 0)
  		{
  		  it->current_x = x;
  		  result = MOVE_X_REACHED;
  		  break;
  		}
! 	      else if (atx_it.sp < 0)
  		{
+ 		  atx_it = *it;
+ 		  atx_it.current_x = x;
+ 		}
+ 	    }
+ 	  else
+ 	    {
+ 	      if (BUFFER_POS_REACHED_P ())
+   		goto buffer_pos_reached;
+ 	      it->current_x = x;
+ 	      result = MOVE_X_REACHED;
+ 	      break;
+   	    }
+   	}
+   
+         if (/* Lines are continued.  */
+ 		  it->line_wrap != TRUNCATE
+ 		  && (/* And glyph doesn't fit on the line.  */
+ 		      new_x > it->last_visible_x
+ 		      /* Or it fits exactly and we're on a window
+ 			 system frame.  */
+ 		      || (new_x == it->last_visible_x
+  			  && FRAME_WINDOW_P (it->f)
+  			  && it->line_wrap == WINDOW_WRAP)))		
+ 	  {
  		  if (/* IT->hpos == 0 means the very first glyph
  			 doesn't fit on the line, e.g. a wide image.  */
  		      it->hpos == 0
  		      || (new_x == it->last_visible_x
!  			  && FRAME_WINDOW_P (it->f)
!  			  && it->line_wrap == WINDOW_WRAP))
  		    {
  		      ++it->hpos;
  		      it->current_x = new_x;
***************
*** 6641,6646 ****
--- 6740,6746 ----
  				  break;
  				}
  			      if (ITERATOR_AT_END_OF_LINE_P (it))
+ 		      atx_it.sp = -1;
  				{
  				  result = MOVE_NEWLINE_OR_CR;
  				  break;
***************
*** 6656,6679 ****
  		      it->max_descent = descent;
  		    }
  
  		  TRACE_MOVE ((stderr, "move_it_in: continued at %d\n",
  			       IT_CHARPOS (*it)));
  		  result = MOVE_LINE_CONTINUED;
  		  break;
  		}
! 	      else if (BUFFER_POS_REACHED_P ())
! 		goto buffer_pos_reached;
! 	      else if (new_x > it->first_visible_x)
  		{
  		  /* Glyph is visible.  Increment number of glyphs that
  		     would be displayed.  */
  		  ++it->hpos;
  		}
- 	      else
- 		{
- 		  /* Glyph is completely off the left margin of the display
- 		     area.  Nothing to do.  */
- 		}
  	    }
  
  	  if (result != MOVE_UNDEFINED)
--- 6756,6796 ----
  		      it->max_descent = descent;
  		    }
  
+ 		  if (wrap_it.sp >= 0)
+ 		    {
+ 		      *it = wrap_it;
+ 		      atpos_it.sp = -1;
+ 		      atx_it.sp = -1;
+ 		    }
+ 
  		  TRACE_MOVE ((stderr, "move_it_in: continued at %d\n",
  			       IT_CHARPOS (*it)));
  		  result = MOVE_LINE_CONTINUED;
  		  break;
  		}
! 
! 	      if (BUFFER_POS_REACHED_P ())
! 		{
! 		  if (it->line_wrap == WORD_WRAP)
! 		    {
! 		      if (wrap_it.sp < 0)
! 			goto buffer_pos_reached;
! 		      if (atpos_it.sp < 0)
!  			{
!  			  atpos_it = *it;
!  			  atpos_it.current_x = x;
!  			}
! 		    }
! 		  else
! 		    goto buffer_pos_reached;
! 		}
! 
! 	      if (new_x > it->first_visible_x)
  		{
  		  /* Glyph is visible.  Increment number of glyphs that
  		     would be displayed.  */
  		  ++it->hpos;
  		}
  	    }
  
  	  if (result != MOVE_UNDEFINED)
***************
*** 6712,6718 ****
  
        /* Stop if lines are truncated and IT's current x-position is
  	 past the right edge of the window now.  */
!       if (it->truncate_lines_p
  	  && it->current_x >= it->last_visible_x)
  	{
  #ifdef HAVE_WINDOW_SYSTEM
--- 6829,6835 ----
  
        /* Stop if lines are truncated and IT's current x-position is
  	 past the right edge of the window now.  */
!       if (it->line_wrap == TRUNCATE
  	  && it->current_x >= it->last_visible_x)
  	{
  #ifdef HAVE_WINDOW_SYSTEM
***************
*** 6738,6743 ****
--- 6855,6868 ----
  
  #undef BUFFER_POS_REACHED_P
  
+   /* If we scanned beyond to_pos and didn't find a point to wrap at,
+      restore the saved iterator.  */
+   if (atpos_it.sp >= 0)
+      *it = atpos_it;
+    else if (atx_it.sp >= 0)
+      *it = atx_it;
+  
+  done:
    /* Restore the iterator settings altered at the beginning of this
       function.  */
    it->glyph_row = saved_glyph_row;
***************
*** 8365,8371 ****
        max_height = min (total_height, max_height);
  
        /* Find out the height of the text in the window.  */
!       if (it.truncate_lines_p)
  	height = 1;
        else
  	{
--- 8490,8496 ----
        max_height = min (total_height, max_height);
  
        /* Find out the height of the text in the window.  */
!       if (it.line_wrap == TRUNCATE)
  	height = 1;
        else
  	{
***************
*** 15790,15796 ****
        && it->glyph_row->displays_text_p
        && face->box == FACE_NO_BOX
        && face->background == FRAME_BACKGROUND_PIXEL (f)
!       && !face->stipple)
      return;
  
    /* Set the glyph row flag indicating that the face of the last glyph
--- 15915,15922 ----
        && it->glyph_row->displays_text_p
        && face->box == FACE_NO_BOX
        && face->background == FRAME_BACKGROUND_PIXEL (f)
!       && !face->stipple
!       && it->line_wrap != WORD_WRAP)
      return;
  
    /* Set the glyph row flag indicating that the face of the last glyph
***************
*** 16005,16010 ****
--- 16131,16141 ----
  {
    struct glyph_row *row = it->glyph_row;
    Lisp_Object overlay_arrow_string;
+   struct it wrap_it;
+   int may_wrap = 0, wrap_x;
+   int wrap_row_used = -1, wrap_row_ascent, wrap_row_height;
+   int wrap_row_phys_ascent, wrap_row_phys_height;
+   int wrap_row_extra_line_spacing;
  
    /* We always start displaying at hpos zero even if hscrolled.  */
    xassert (it->hpos == 0 && it->current_x == 0);
***************
*** 16099,16110 ****
  
        /* Remember the line height so far in case the next element doesn't
  	 fit on the line.  */
!       if (!it->truncate_lines_p)
  	{
  	  ascent = it->max_ascent;
  	  descent = it->max_descent;
  	  phys_ascent = it->max_phys_ascent;
  	  phys_descent = it->max_phys_descent;
  	}
  
        PRODUCE_GLYPHS (it);
--- 16230,16260 ----
  
        /* Remember the line height so far in case the next element doesn't
  	 fit on the line.  */
!       if (it->line_wrap != TRUNCATE)
  	{
  	  ascent = it->max_ascent;
  	  descent = it->max_descent;
  	  phys_ascent = it->max_phys_ascent;
  	  phys_descent = it->max_phys_descent;
+ 
+ 	  if (it->line_wrap == WORD_WRAP && it->area == TEXT_AREA)
+ 	    {
+ 	      if (it->what == IT_CHARACTER
+ 		  && (it->c == ' ' || it->c == '\t'))
+ 		may_wrap = 1;
+ 	      else if (may_wrap)
+ 		{
+ 		  wrap_it = *it;
+ 		  wrap_x = x;
+ 		  wrap_row_used = row->used[TEXT_AREA];
+ 		  wrap_row_ascent = row->ascent;
+ 		  wrap_row_height = row->height;
+ 		  wrap_row_phys_ascent = row->phys_ascent;
+ 		  wrap_row_phys_height = row->phys_height;
+ 		  wrap_row_extra_line_spacing = row->extra_line_spacing;
+ 		  may_wrap = 0;
+ 		}
+ 	    }
  	}
  
        PRODUCE_GLYPHS (it);
***************
*** 16164,16170 ****
  	      new_x = x + glyph->pixel_width;
  
  	      if (/* Lines are continued.  */
! 		  !it->truncate_lines_p
  		  && (/* Glyph doesn't fit on the line.  */
  		      new_x > it->last_visible_x
  		      /* Or it fits exactly on a window system frame.  */
--- 16314,16320 ----
  	      new_x = x + glyph->pixel_width;
  
  	      if (/* Lines are continued.  */
! 		  it->line_wrap != TRUNCATE
  		  && (/* Glyph doesn't fit on the line.  */
  		      new_x > it->last_visible_x
  		      /* Or it fits exactly on a window system frame.  */
***************
*** 16205,16210 ****
--- 16355,16372 ----
  				}
  			    }
  #endif /* HAVE_WINDOW_SYSTEM */
+ 
+ 			  /* If line-wrap is on, consider returning to
+ 			     a previously set wrap point, if there is
+ 			     one.  Be sure to handle the case where
+ 			     the last character on the line is a
+ 			     space, as well as the case where the
+ 			     following character is also a space.  */
+ 			  if (wrap_row_used > 0
+ 			      && (!may_wrap
+ 				  || (it->what == IT_CHARACTER
+ 				      && (it->c == ' ' || it->c == '\t'))))
+ 			    goto back_to_wrap;
  			}
  		    }
  		  else if (CHAR_GLYPH_PADDING_P (*glyph)
***************
*** 16232,16237 ****
--- 16394,16419 ----
  		      it->max_phys_ascent = phys_ascent;
  		      it->max_phys_descent = phys_descent;
  		    }
+ 		  else if (wrap_row_used > 0)
+ 		    {
+ 		    back_to_wrap:
+ 		      *it = wrap_it;
+ 		      it->continuation_lines_width += wrap_x;
+ 		      row->used[TEXT_AREA] = wrap_row_used;
+ 		      row->ascent = wrap_row_ascent;
+ 		      row->height = wrap_row_height;
+ 		      row->phys_ascent = wrap_row_phys_ascent;
+ 		      row->phys_height = wrap_row_phys_height;
+ 		      row->extra_line_spacing = wrap_row_extra_line_spacing;
+ 		      row->continued_p = 1;
+ 		      row->ends_at_zv_p = 0;
+ 		      row->exact_window_width_line_p = 0;
+ 		      it->continuation_lines_width += x;
+ 
+ 		      /* Make sure that a non-default face is extended
+ 			 up to the right margin of the window.  */
+ 		      extend_face_to_end_of_line (it);
+ 		    }
  		  else if (it->c == '\t' && FRAME_WINDOW_P (it->f))
  		    {
  		      /* A TAB that extends past the right edge of the
***************
*** 16347,16353 ****
  
        /* If we truncate lines, we are done when the last displayed
  	 glyphs reach past the right margin of the window.  */
!       if (it->truncate_lines_p
  	  && (FRAME_WINDOW_P (it->f)
  	      ? (it->current_x >= it->last_visible_x)
  	      : (it->current_x > it->last_visible_x)))
--- 16529,16535 ----
  
        /* If we truncate lines, we are done when the last displayed
  	 glyphs reach past the right margin of the window.  */
!       if (it->line_wrap == TRUNCATE
  	  && (FRAME_WINDOW_P (it->f)
  	      ? (it->current_x >= it->last_visible_x)
  	      : (it->current_x > it->last_visible_x)))
***************
*** 18356,18362 ****
  	{
  	  struct glyph *glyph = row->glyphs[TEXT_AREA] + n_glyphs_before + i;
  
! 	  if (!it->truncate_lines_p
  	      && x + glyph->pixel_width > max_x)
  	    {
  	      /* End of continued line or max_x reached.  */
--- 18538,18544 ----
  	{
  	  struct glyph *glyph = row->glyphs[TEXT_AREA] + n_glyphs_before + i;
  
! 	  if (it->line_wrap != TRUNCATE
  	      && x + glyph->pixel_width > max_x)
  	    {
  	      /* End of continued line or max_x reached.  */
***************
*** 18412,18418 ****
        set_iterator_to_next (it, 1);
  
        /* Stop if truncating at the right edge.  */
!       if (it->truncate_lines_p
  	  && it->current_x >= it->last_visible_x)
  	{
  	  /* Add truncation mark, but don't do it if the line is
--- 18594,18600 ----
        set_iterator_to_next (it, 1);
  
        /* Stop if truncating at the right edge.  */
!       if (it->line_wrap == TRUNCATE
  	  && it->current_x >= it->last_visible_x)
  	{
  	  /* Add truncation mark, but don't do it if the line is
***************
*** 20275,20281 ****
    else
      ascent = (height * FONT_BASE (font)) / FONT_HEIGHT (font);
  
!   if (width > 0 && !it->truncate_lines_p
        && it->current_x + width > it->last_visible_x)
      width = it->last_visible_x - it->current_x - 1;
  
--- 20457,20463 ----
    else
      ascent = (height * FONT_BASE (font)) / FONT_HEIGHT (font);
  
!   if (width > 0 && it->line_wrap != TRUNCATE
        && it->current_x + width > it->last_visible_x)
      width = it->last_visible_x - it->current_x - 1;
  
***************
*** 24149,24158 ****
    DEFVAR_INT ("debug-end-pos", &debug_end_pos, doc: /* Don't ask.  */);
  #endif
  
!   DEFVAR_BOOL ("truncate-partial-width-windows",
! 	       &truncate_partial_width_windows,
!     doc: /* *Non-nil means truncate lines in all windows less than full frame wide.  */);
!   truncate_partial_width_windows = 1;
  
    DEFVAR_BOOL ("mode-line-inverse-video", &mode_line_inverse_video,
      doc: /* When nil, display the mode-line/header-line/menu-bar in the default face.
--- 24331,24348 ----
    DEFVAR_INT ("debug-end-pos", &debug_end_pos, doc: /* Don't ask.  */);
  #endif
  
!   DEFVAR_LISP ("truncate-partial-width-windows",
! 	       &Vtruncate_partial_width_windows,
!     doc: /* Non-nil means truncate lines in windows with less than the frame width.
! For an integer value, truncate lines in each window with less than the
! full frame width, provided the window width is less than that integer;
! otherwise, respect the value of `truncate-lines'.
! 
! For any other non-nil value, truncate lines in all windows with
! less than the full frame width.
! 
!   Nil means to respect the value of `truncate-lines'.  */);
!   Vtruncate_partial_width_windows = make_number (30);
  
    DEFVAR_BOOL ("mode-line-inverse-video", &mode_line_inverse_video,
      doc: /* When nil, display the mode-line/header-line/menu-bar in the default face.
Index: indent.c
===================================================================
RCS file: /sources/emacs/emacs/src/indent.c,v
retrieving revision 1.192.2.3
diff -c -r1.192.2.3 indent.c
*** src/indent.c	8 Jan 2008 04:30:04 -0000	1.192.2.3
--- src/indent.c	5 Jul 2008 12:51:33 -0000
***************
*** 1395,1404 ****
  
        if (hpos > width)
  	{
! 	  if (hscroll
! 	      || (truncate_partial_width_windows
! 		  && ((width + continuation_glyph_width)
! 		      < FRAME_COLS (XFRAME (WINDOW_FRAME (win)))))
  	      || !NILP (current_buffer->truncate_lines))
  	    {
  	      /* Truncating: skip to newline, unless we are already past
--- 1395,1414 ----
  
        if (hpos > width)
  	{
! 	  int total_width = width + continuation_glyph_width;
! 	  int truncate = 0;
! 
! 	  if (!NILP ((Lisp_Object) Vtruncate_partial_width_windows)
! 	      && (total_width < FRAME_COLS (XFRAME (WINDOW_FRAME (win)))))
! 	    {
! 	      if (INTEGERP ((Lisp_Object) Vtruncate_partial_width_windows))
! 		truncate
! 		  = total_width < XFASTINT ((Lisp_Object) Vtruncate_partial_width_windows);
! 	      else
! 		truncate = 1;
! 	    }
! 
! 	  if (hscroll || truncate
  	      || !NILP (current_buffer->truncate_lines))
  	    {
  	      /* Truncating: skip to newline, unless we are already past
Index: dispnew.c
===================================================================
RCS file: /sources/emacs/emacs/src/dispnew.c,v
retrieving revision 1.392.2.3
diff -c -r1.392.2.3 dispnew.c
*** src/dispnew.c	5 Mar 2008 00:50:06 -0000	1.392.2.3
--- src/dispnew.c	5 Jul 2008 12:51:34 -0000
***************
*** 3516,3521 ****
--- 3516,3522 ----
        || g == '\t'
        || g == '\n'
        || g == '\r'
+       || (g == ' ' && !NILP (current_buffer->word_wrap))
        /* Give up if unable to display the cursor in the window.  */
        || w->cursor.vpos < 0
        /* Give up if we are showing a message or just cleared the message
Index: termopts.h
===================================================================
RCS file: /sources/emacs/emacs/src/termopts.h,v
retrieving revision 1.10.2.2
diff -c -r1.10.2.2 termopts.h
*** src/termopts.h	8 Jan 2008 04:29:50 -0000	1.10.2.2
--- src/termopts.h	5 Jul 2008 12:51:34 -0000
***************
*** 38,45 ****
  /* Terminal has meta key */
  extern int meta_key;
  
! /* Nonzero means truncate lines in all windows less wide than the frame */
! extern int truncate_partial_width_windows;
  
  /* arch-tag: 35d4d284-dc1a-4fff-97fa-0154a21aebdb
     (do not change this comment) */
--- 38,45 ----
  /* Terminal has meta key */
  extern int meta_key;
  
! /* Defined in xdisp.c */
! extern void* Vtruncate_partial_width_windows;
  
  /* arch-tag: 35d4d284-dc1a-4fff-97fa-0154a21aebdb
     (do not change this comment) */
Index: buffer.c
===================================================================
RCS file: /sources/emacs/emacs/src/buffer.c,v
retrieving revision 1.526.2.5
diff -c -r1.526.2.5 buffer.c
*** src/buffer.c	8 Jan 2008 04:30:20 -0000	1.526.2.5
--- src/buffer.c	5 Jul 2008 12:51:36 -0000
***************
*** 5036,5041 ****
--- 5036,5042 ----
  
    XSETFASTINT (buffer_defaults.tab_width, 8);
    buffer_defaults.truncate_lines = Qnil;
+   buffer_defaults.word_wrap = Qnil;
    buffer_defaults.ctl_arrow = Qt;
    buffer_defaults.direction_reversed = Qnil;
    buffer_defaults.cursor_type = Qt;
***************
*** 5108,5113 ****
--- 5109,5115 ----
  #endif
    XSETFASTINT (buffer_local_flags.tab_width, idx); ++idx;
    XSETFASTINT (buffer_local_flags.truncate_lines, idx); ++idx;
+   XSETFASTINT (buffer_local_flags.word_wrap, idx); ++idx;
    XSETFASTINT (buffer_local_flags.ctl_arrow, idx); ++idx;
    XSETFASTINT (buffer_local_flags.fill_column, idx); ++idx;
    XSETFASTINT (buffer_local_flags.left_margin, idx); ++idx;
***************
*** 5356,5361 ****
--- 5358,5368 ----
  		     doc: /* Default value of `truncate-lines' for buffers that do not override it.
  This is the same as (default-value 'truncate-lines).  */);
  
+   DEFVAR_LISP_NOPRO ("default-word-wrap",
+ 		     &buffer_defaults.word_wrap,
+ 		     doc: /* Default value of `word-wrap' for buffers that do not override it.
+ This is the same as (default-value 'word-wrap).  */);
+ 
    DEFVAR_LISP_NOPRO ("default-fill-column",
  		     &buffer_defaults.fill_column,
  		     doc: /* Default value of `fill-column' for buffers that do not override it.
***************
*** 5600,5605 ****
--- 5607,5621 ----
  `truncate-partial-width-windows' if that variable is non-nil
  and this buffer is not full-frame width.  */);
  
+   DEFVAR_PER_BUFFER ("word-wrap", &current_buffer->word_wrap, Qnil,
+ 		     doc: /* *Non-nil means to use word-wrapping for continuation lines.
+ When word-wrapping is on, continuation lines are wrapped at the space
+ or tab character nearest to the right window edge.
+ If nil, continuation lines are wrapped at the right screen edge.
+ 
+ This variable has no effect if long lines are truncated (see
+ `truncate-lines' and `truncate-partial-width-windows').  */);
+ 
  #ifdef DOS_NT
    DEFVAR_PER_BUFFER ("buffer-file-type", &current_buffer->buffer_file_type,
  		     Qnil,
Index: buffer.h
===================================================================
RCS file: /sources/emacs/emacs/src/buffer.h,v
retrieving revision 1.109.2.3
diff -c -r1.109.2.3 buffer.h
*** src/buffer.h	8 Jan 2008 04:30:20 -0000	1.109.2.3
--- src/buffer.h	5 Jul 2008 12:51:36 -0000
***************
*** 643,648 ****
--- 643,650 ----
  
    /* Non-nil means do not display continuation lines.  */
    Lisp_Object truncate_lines;
+   /* Non-nil means to use word wrapping when displaying continuation lines.  */
+   Lisp_Object word_wrap;
    /* Non-nil means display ctl chars with uparrow.  */
    Lisp_Object ctl_arrow;
    /* Non-nil means display text from right to left.  */
Index: dispextern.h
===================================================================
RCS file: /sources/emacs/emacs/src/dispextern.h,v
retrieving revision 1.225.2.7
diff -c -r1.225.2.7 dispextern.h
*** src/dispextern.h	8 Jan 2008 04:30:14 -0000	1.225.2.7
--- src/dispextern.h	5 Jul 2008 12:51:37 -0000
***************
*** 1800,1805 ****
--- 1800,1813 ----
    LAST_PROP_IDX
  };
  
+ /* An enumerator for the method of wrapping long lines.  */
+  	  	 
+ enum line_wrap_method
+ {
+   TRUNCATE,
+   WORD_WRAP,
+   WINDOW_WRAP
+ };
  
  struct it_slice
  {
***************
*** 2004,2011 ****
       where the `^' can be replaced by a display table entry.  */
    unsigned ctl_arrow_p : 1;
  
!   /* 1 means lines are truncated.  */
!   unsigned truncate_lines_p : 1;
  
    /* Non-zero means that the current face has a box.  */
    unsigned face_box_p : 1;
--- 2012,2018 ----
       where the `^' can be replaced by a display table entry.  */
    unsigned ctl_arrow_p : 1;
  
!   enum line_wrap_method line_wrap;
  
    /* Non-zero means that the current face has a box.  */
    unsigned face_box_p : 1;
