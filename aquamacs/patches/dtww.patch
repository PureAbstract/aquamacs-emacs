DTWW patch
authored by Kim Storm and Chong Yidong
backported to 22 for Aquamacs by David Reitter Jul2008
This patch is part of Aquamacs.
Index: xdisp.c
===================================================================
RCS file: /sources/emacs/emacs/src/xdisp.c,v
retrieving revision 1.1149.2.27
diff -c -r1.1149.2.27 xdisp.c
*** src/xdisp.c	23 Apr 2008 08:56:30 -0000	1.1149.2.27
--- src/xdisp.c	25 Jul 2008 01:58:41 -0000
***************
*** 341,350 ****
    (!NILP (Voverflow_newline_into_fringe)	\
     && FRAME_WINDOW_P (it->f)			\
     && WINDOW_RIGHT_FRINGE_WIDTH (it->w) > 0	\
!    && it->current_x == it->last_visible_x)
  
  #endif /* HAVE_WINDOW_SYSTEM */
  
  /* Non-nil means show the text cursor in void text areas
     i.e. in blank areas after eol and eob.  This used to be
     the default in 21.3.  */
--- 341,357 ----
    (!NILP (Voverflow_newline_into_fringe)	\
     && FRAME_WINDOW_P (it->f)			\
     && WINDOW_RIGHT_FRINGE_WIDTH (it->w) > 0	\
!    && it->current_x == it->last_visible_x	\
!    && it->line_wrap != WORD_WRAP)
  
  #endif /* HAVE_WINDOW_SYSTEM */
  
+ /* Test if the display element loaded in IT is a space or tab
+    character.  This is used to determine word wrapping.  */
+ 
+ #define IT_DISPLAYING_WHITESPACE(it)				\
+   (it->what == IT_CHARACTER && (it->c == ' ' || it->c == '\t'))
+ 
  /* Non-nil means show the text cursor in void text areas
     i.e. in blank areas after eol and eob.  This used to be
     the default in 21.3.  */
***************
*** 418,424 ****
  /* Nonzero means truncate lines in all windows less wide than the
     frame.  */
  
! int truncate_partial_width_windows;
  
  /* A flag to control how to display unibyte 8-bit character.  */
  
--- 425,431 ----
  /* Nonzero means truncate lines in all windows less wide than the
     frame.  */
  
! Lisp_Object Vtruncate_partial_width_windows;
  
  /* A flag to control how to display unibyte 8-bit character.  */
  
***************
*** 2603,2621 ****
      it->tab_width = 8;
  
    /* Are lines in the display truncated?  */
!   it->truncate_lines_p
!     = (base_face_id != DEFAULT_FACE_ID
!        || XINT (it->w->hscroll)
!        || (truncate_partial_width_windows
! 	   && !WINDOW_FULL_WIDTH_P (it->w))
!        || !NILP (current_buffer->truncate_lines));
  
    /* Get dimensions of truncation and continuation glyphs.  These are
       displayed as fringe bitmaps under X, so we don't need them for such
       frames.  */
    if (!FRAME_WINDOW_P (it->f))
      {
!       if (it->truncate_lines_p)
  	{
  	  /* We will need the truncation glyph.  */
  	  xassert (it->glyph_row == NULL);
--- 2610,2636 ----
      it->tab_width = 8;
  
    /* Are lines in the display truncated?  */
!   if (base_face_id != DEFAULT_FACE_ID
!       || XINT (it->w->hscroll)
!       || (! WINDOW_FULL_WIDTH_P (it->w)
! 	  && ((!NILP (Vtruncate_partial_width_windows)
! 	       && !INTEGERP (Vtruncate_partial_width_windows))
! 	      || (INTEGERP (Vtruncate_partial_width_windows)
! 		  && (WINDOW_TOTAL_COLS (it->w)
! 		      < XINT (Vtruncate_partial_width_windows))))))
!     it->line_wrap = TRUNCATE;
!   else if (NILP (current_buffer->truncate_lines))
!     it->line_wrap = NILP (current_buffer->word_wrap)
!       ? WINDOW_WRAP : WORD_WRAP;
!   else
!     it->line_wrap = TRUNCATE;
  
    /* Get dimensions of truncation and continuation glyphs.  These are
       displayed as fringe bitmaps under X, so we don't need them for such
       frames.  */
    if (!FRAME_WINDOW_P (it->f))
      {
!       if (it->line_wrap == TRUNCATE)
  	{
  	  /* We will need the truncation glyph.  */
  	  xassert (it->glyph_row == NULL);
***************
*** 2665,2671 ****
  	 for window-based redisplay.  */
        if (!FRAME_WINDOW_P (it->f))
  	{
! 	  if (it->truncate_lines_p)
  	    it->last_visible_x -= it->truncation_pixel_width;
  	  else
  	    it->last_visible_x -= it->continuation_pixel_width;
--- 2680,2686 ----
  	 for window-based redisplay.  */
        if (!FRAME_WINDOW_P (it->f))
  	{
! 	  if (it->line_wrap == TRUNCATE)
  	    it->last_visible_x -= it->truncation_pixel_width;
  	  else
  	    it->last_visible_x -= it->continuation_pixel_width;
***************
*** 2738,2744 ****
  
    /* Don't reseat to previous visible line start if current start
       position is in a string or image.  */
!   if (it->method == GET_FROM_BUFFER && !it->truncate_lines_p)
      {
        int start_at_line_beg_p;
        int first_y = it->current_y;
--- 2753,2759 ----
  
    /* Don't reseat to previous visible line start if current start
       position is in a string or image.  */
!   if (it->method == GET_FROM_BUFFER && it->line_wrap != TRUNCATE)
      {
        int start_at_line_beg_p;
        int first_y = it->current_y;
***************
*** 2763,2769 ****
  	     taken us to the start of the continuation line but to the
  	     end of the continued line.  */
  	  if (it->current_x > 0
! 	      && !it->truncate_lines_p /* Lines are continued.  */
  	      && (/* And glyph doesn't fit on the line.  */
  		  new_x > it->last_visible_x
  		  /* Or it fits exactly and we're on a window
--- 2778,2784 ----
  	     taken us to the start of the continuation line but to the
  	     end of the continued line.  */
  	  if (it->current_x > 0
! 	      && it->line_wrap != TRUNCATE /* Lines are continued.  */
  	      && (/* And glyph doesn't fit on the line.  */
  		  new_x > it->last_visible_x
  		  /* Or it fits exactly and we're on a window
***************
*** 5278,5283 ****
--- 5293,5299 ----
  	pos = --IT_CHARPOS (it2);
  	--IT_BYTEPOS (it2);
  	it2.sp = 0;
+ 	it2.string_from_display_prop_p = 0;
  	if (handle_display_prop (&it2) == HANDLED_RETURN
  	    && !NILP (val = get_char_property_and_overlay
  		      (make_number (pos), Qdisplay, Qnil, &overlay))
***************
*** 5428,5433 ****
--- 5444,5450 ----
    IT_STRING_CHARPOS (*it) = -1;
    IT_STRING_BYTEPOS (*it) = -1;
    it->string = Qnil;
+   it->string_from_display_prop_p = 0;
    it->method = GET_FROM_BUFFER;
    it->object = it->w->buffer;
    it->area = TEXT_AREA;
***************
*** 6488,6498 ****
--- 6505,6527 ----
  {
    enum move_it_result result = MOVE_UNDEFINED;
    struct glyph_row *saved_glyph_row;
+   struct it wrap_it, atpos_it, atx_it;
+   int may_wrap = 0;
  
    /* Don't produce glyphs in produce_glyphs.  */
    saved_glyph_row = it->glyph_row;
    it->glyph_row = NULL;
  
+    /* Use wrap_it to save a copy of IT wherever a word wrap could
+       occur.  Use atpos_it to save a copy of IT at the desired buffer
+       position, if found, so that we can scan ahead and check if the
+       word later overshoots the window edge.  Use atx_it similarly, for
+       pixel positions.  */
+    wrap_it.sp = -1;
+    atpos_it.sp = -1;
+    atx_it.sp = -1;
+   
+ 
  #define BUFFER_POS_REACHED_P()					\
    ((op & MOVE_TO_POS) != 0					\
     && BUFFERP (it->object)					\
***************
*** 6506,6546 ****
      {
        int x, i, ascent = 0, descent = 0;
  
!       /* Stop if we move beyond TO_CHARPOS (after an image or stretch glyph).  */
        if ((op & MOVE_TO_POS) != 0
  	  && BUFFERP (it->object)
  	  && it->method == GET_FROM_BUFFER
  	  && IT_CHARPOS (*it) > to_charpos)
  	{
! 	  result = MOVE_POS_MATCH_OR_ZV;
! 	  break;
  	}
  
        /* Stop when ZV reached.
           We used to stop here when TO_CHARPOS reached as well, but that is
           too soon if this glyph does not fit on this line.  So we handle it
           explicitly below.  */
!       if (!get_next_display_element (it)
! 	  || (it->truncate_lines_p
! 	      && BUFFER_POS_REACHED_P ()))
  	{
  	  result = MOVE_POS_MATCH_OR_ZV;
  	  break;
  	}
  
!       /* The call to produce_glyphs will get the metrics of the
! 	 display element IT is loaded with.  We record in x the
! 	 x-position before this display element in case it does not
! 	 fit on the line.  */
!       x = it->current_x;
! 
!       /* Remember the line height so far in case the next element doesn't
! 	 fit on the line.  */
!       if (!it->truncate_lines_p)
  	{
! 	  ascent = it->max_ascent;
! 	  descent = it->max_descent;
  	}
  
        PRODUCE_GLYPHS (it);
  
--- 6535,6622 ----
      {
        int x, i, ascent = 0, descent = 0;
  
!       /* Utility macro to reset an iterator with x, ascent, and descent.  */
! #define IT_RESET_X_ASCENT_DESCENT(IT)			\
!       ((IT)->current_x = x, (IT)->max_ascent = ascent,	\
!        (IT)->max_descent = descent)
!       
!       /* Stop if we move beyond TO_CHARPOS (after an image or stretch
! 	 glyph).  */
        if ((op & MOVE_TO_POS) != 0
  	  && BUFFERP (it->object)
  	  && it->method == GET_FROM_BUFFER
  	  && IT_CHARPOS (*it) > to_charpos)
  	{
! 	  if (it->line_wrap != WORD_WRAP || wrap_it.sp < 0)
! 	    {
! 	      result = MOVE_POS_MATCH_OR_ZV;
! 	      break;
! 	    }
! 	  else if (it->line_wrap == WORD_WRAP && atpos_it.sp < 0)
! 	    /* If wrap_it is valid, the current position might be in a
! 	       word that is wrapped.  So, save the iterator in
! 	       atpos_it and continue to see if wrapping happens.  */
! 	    atpos_it = *it;
  	}
  
        /* Stop when ZV reached.
           We used to stop here when TO_CHARPOS reached as well, but that is
           too soon if this glyph does not fit on this line.  So we handle it
           explicitly below.  */
!       if (!get_next_display_element (it))
  	{
  	  result = MOVE_POS_MATCH_OR_ZV;
  	  break;
  	}
  
!       if (it->line_wrap == TRUNCATE)
  	{
! 	  if (BUFFER_POS_REACHED_P ())
! 	    {
! 	      result = MOVE_POS_MATCH_OR_ZV;
! 	      break;
! 	    }
! 	}
!       else
! 	{
! 
! 	  if (it->line_wrap == WORD_WRAP)
! 	    {
! 	      if (IT_DISPLAYING_WHITESPACE (it))
! 		may_wrap = 1;
! 	      else if (may_wrap)
! 		{
! 		  /* We have reached a glyph that follows one or more
! 		     whitespace characters.  If the position is
! 		     already found, we are done.  */
! 		  if (atpos_it.sp >= 0)
! 		    {
! 		      *it = atpos_it;
! 		      result = MOVE_POS_MATCH_OR_ZV;
! 		      goto done;
! 		    }
! 		  if (atx_it.sp >= 0)
! 		    {
! 		      *it = atx_it;
! 		      result = MOVE_X_REACHED;
! 		      goto done;
! 		    }
! 		  /* Otherwise, we can wrap here.  */
! 		  wrap_it = *it;
! 		  may_wrap = 0;
! 		}
! 	    }
  	}
+       /* Remember the line height for the current line, in case
+ 	 the next element doesn't fit on the line.  */
+       ascent = it->max_ascent;
+       descent = it->max_descent;
+ 
+       /* The call to produce_glyphs will get the metrics of the
+ 	 display element IT is loaded with.  Record the x-position
+ 	 before this display element, in case it doesn't fit on the
+ 	 line.  */
+       x = it->current_x;
  
        PRODUCE_GLYPHS (it);
  
***************
*** 6581,6609 ****
  	    {
  	      new_x = x + single_glyph_width;
  
! 	      /* We want to leave anything reaching TO_X to the caller.  */
! 	      if ((op & MOVE_TO_X) && new_x > to_x)
! 		{
! 		  if (BUFFER_POS_REACHED_P ())
! 		    goto buffer_pos_reached;
! 		  it->current_x = x;
! 		  result = MOVE_X_REACHED;
! 		  break;
! 		}
! 	      else if (/* Lines are continued.  */
! 		       !it->truncate_lines_p
! 		       && (/* And glyph doesn't fit on the line.  */
! 			   new_x > it->last_visible_x
! 			   /* Or it fits exactly and we're on a window
! 			      system frame.  */
! 			   || (new_x == it->last_visible_x
! 			       && FRAME_WINDOW_P (it->f))))
! 		{
  		  if (/* IT->hpos == 0 means the very first glyph
  			 doesn't fit on the line, e.g. a wide image.  */
  		      it->hpos == 0
  		      || (new_x == it->last_visible_x
! 			  && FRAME_WINDOW_P (it->f)))
  		    {
  		      ++it->hpos;
  		      it->current_x = new_x;
--- 6657,6705 ----
  	    {
  	      new_x = x + single_glyph_width;
  
!         /* We want to leave anything reaching TO_X to the caller.  */
!         if ((op & MOVE_TO_X) && new_x > to_x)
! 	  {
! 	    if (BUFFER_POS_REACHED_P ())
! 	      {
! 		if (it->line_wrap != WORD_WRAP || wrap_it.sp < 0)
! 		  goto buffer_pos_reached;
! 		if (atpos_it.sp < 0)
! 		  {
! 		    atpos_it = *it;
! 		    IT_RESET_X_ASCENT_DESCENT (&atpos_it);
! 		  }
! 	      }
! 	    else
! 	      {
! 		if (it->line_wrap != WORD_WRAP || wrap_it.sp < 0)
! 		  {
! 		    it->current_x = x;
! 		    result = MOVE_X_REACHED;
! 		    break;
! 		  }
! 		if (atx_it.sp < 0)
! 		  {
! 		    atx_it = *it;
! 		    IT_RESET_X_ASCENT_DESCENT (&atx_it);
! 		  }
! 	      }
! 	  }
!   
!         if (/* Lines are continued.  */
! 		  it->line_wrap != TRUNCATE
! 		  && (/* And glyph doesn't fit on the line.  */
! 		      new_x > it->last_visible_x
! 		      /* Or it fits exactly and we're on a window
! 			 system frame.  */
! 		      || (new_x == it->last_visible_x
!  			  && FRAME_WINDOW_P (it->f))))		
! 	  {
  		  if (/* IT->hpos == 0 means the very first glyph
  			 doesn't fit on the line, e.g. a wide image.  */
  		      it->hpos == 0
  		      || (new_x == it->last_visible_x
!  			  && FRAME_WINDOW_P (it->f)))
  		    {
  		      ++it->hpos;
  		      it->current_x = new_x;
***************
*** 6617,6626 ****
  			     now that we know it fits in this row.  */
  			  if (BUFFER_POS_REACHED_P ())
  			    {
! 			      it->hpos = hpos_before_this_char;
! 			      it->current_x = x_before_this_char;
! 			      result = MOVE_POS_MATCH_OR_ZV;
! 			      break;
  			    }
  
  			  set_iterator_to_next (it, 1);
--- 6713,6733 ----
  			     now that we know it fits in this row.  */
  			  if (BUFFER_POS_REACHED_P ())
  			    {
! 			      if (it->line_wrap != WORD_WRAP
! 				  || wrap_it.sp < 0)
! 				{
! 				  it->hpos = hpos_before_this_char;
! 				  it->current_x = x_before_this_char;
! 				  result = MOVE_POS_MATCH_OR_ZV;
! 				  break;
! 				}
! 			      if (it->line_wrap == WORD_WRAP
! 				  && atpos_it.sp < 0)
! 				{
! 				  atpos_it = *it;
! 				  atpos_it.current_x = x_before_this_char;
! 				  atpos_it.hpos = hpos_before_this_char;
! 				}
  			    }
  
  			  set_iterator_to_next (it, 1);
***************
*** 6650,6659 ****
  			}
  		    }
  		  else
  		    {
! 		      it->current_x = x;
! 		      it->max_ascent = ascent;
! 		      it->max_descent = descent;
  		    }
  
  		  TRACE_MOVE ((stderr, "move_it_in: continued at %d\n",
--- 6757,6769 ----
  			}
  		    }
  		  else
+ 		    IT_RESET_X_ASCENT_DESCENT (it);
+ 
+ 		  if (wrap_it.sp >= 0)
  		    {
! 		      *it = wrap_it;
! 		      atpos_it.sp = -1;
! 		      atx_it.sp = -1;
  		    }
  
  		  TRACE_MOVE ((stderr, "move_it_in: continued at %d\n",
***************
*** 6661,6679 ****
  		  result = MOVE_LINE_CONTINUED;
  		  break;
  		}
! 	      else if (BUFFER_POS_REACHED_P ())
! 		goto buffer_pos_reached;
! 	      else if (new_x > it->first_visible_x)
  		{
  		  /* Glyph is visible.  Increment number of glyphs that
  		     would be displayed.  */
  		  ++it->hpos;
  		}
- 	      else
- 		{
- 		  /* Glyph is completely off the left margin of the display
- 		     area.  Nothing to do.  */
- 		}
  	    }
  
  	  if (result != MOVE_UNDEFINED)
--- 6771,6794 ----
  		  result = MOVE_LINE_CONTINUED;
  		  break;
  		}
! 
! 	      if (BUFFER_POS_REACHED_P ())
! 		{
! 		  if (it->line_wrap != WORD_WRAP || wrap_it.sp < 0)
! 		    goto buffer_pos_reached;
! 		  if (it->line_wrap == WORD_WRAP && atpos_it.sp < 0)
! 		    {
! 		      atpos_it = *it;
! 		      IT_RESET_X_ASCENT_DESCENT (&atpos_it);
! 		    }
! 		}
! 
! 	      if (new_x > it->first_visible_x)
  		{
  		  /* Glyph is visible.  Increment number of glyphs that
  		     would be displayed.  */
  		  ++it->hpos;
  		}
  	    }
  
  	  if (result != MOVE_UNDEFINED)
***************
*** 6682,6690 ****
        else if (BUFFER_POS_REACHED_P ())
  	{
  	buffer_pos_reached:
! 	  it->current_x = x;
! 	  it->max_ascent = ascent;
! 	  it->max_descent = descent;
  	  result = MOVE_POS_MATCH_OR_ZV;
  	  break;
  	}
--- 6797,6803 ----
        else if (BUFFER_POS_REACHED_P ())
  	{
  	buffer_pos_reached:
! 	  IT_RESET_X_ASCENT_DESCENT (it);
  	  result = MOVE_POS_MATCH_OR_ZV;
  	  break;
  	}
***************
*** 6712,6718 ****
  
        /* Stop if lines are truncated and IT's current x-position is
  	 past the right edge of the window now.  */
!       if (it->truncate_lines_p
  	  && it->current_x >= it->last_visible_x)
  	{
  #ifdef HAVE_WINDOW_SYSTEM
--- 6825,6831 ----
  
        /* Stop if lines are truncated and IT's current x-position is
  	 past the right edge of the window now.  */
!       if (it->line_wrap == TRUNCATE
  	  && it->current_x >= it->last_visible_x)
  	{
  #ifdef HAVE_WINDOW_SYSTEM
***************
*** 6734,6743 ****
--- 6847,6865 ----
  	  result = MOVE_LINE_TRUNCATED;
  	  break;
  	}
+ #undef IT_RESET_X_ASCENT_DESCENT
      }
  
  #undef BUFFER_POS_REACHED_P
  
+   /* If we scanned beyond to_pos and didn't find a point to wrap at,
+      restore the saved iterator.  */
+   if (atpos_it.sp >= 0)
+      *it = atpos_it;
+    else if (atx_it.sp >= 0)
+      *it = atx_it;
+  
+  done:
    /* Restore the iterator settings altered at the beginning of this
       function.  */
    it->glyph_row = saved_glyph_row;
***************
*** 6745,6750 ****
--- 6867,6882 ----
  }
  
  
+ /* For external use.  */
+ void
+ move_it_in_display_line (struct it *it,
+ 			 EMACS_INT to_charpos, int to_x,
+ 			 enum move_operation_enum op)
+ {
+   move_it_in_display_line_to (it, to_charpos, to_x, op);
+ }
+ 
+ 
  /* Move IT forward until it satisfies one or more of the criteria in
     TO_CHARPOS, TO_X, TO_Y, and TO_VPOS.
  
***************
*** 6816,6821 ****
--- 6948,6956 ----
  	{
  	  struct it it_backup;
  
+ 	  if (it->line_wrap == WORD_WRAP)
+ 	    it_backup = *it;
+ 
  	  /* TO_Y specified means stop at TO_X in the line containing
  	     TO_Y---or at TO_CHARPOS if this is reached first.  The
  	     problem is that we can't really tell whether the line
***************
*** 6828,6878 ****
  	     If we didn't use TO_X == 0, we would stop at the end of
  	     the line which is probably not what a caller would expect
  	     to happen.  */
! 	  skip = move_it_in_display_line_to (it, to_charpos,
! 					     ((op & MOVE_TO_X)
! 					      ? to_x : 0),
! 					     (MOVE_TO_X
! 					      | (op & MOVE_TO_POS)));
  
  	  /* If TO_CHARPOS is reached or ZV, we don't have to do more.  */
  	  if (skip == MOVE_POS_MATCH_OR_ZV)
  	    {
! 	      reached = 5;
! 	      break;
! 	    }
! 
! 	  /* If TO_X was reached, we would like to know whether TO_Y
  	     is in the line.  This can only be said if we know the
  	     total line height which requires us to scan the rest of
  	     the line.  */
- 	  if (skip == MOVE_X_REACHED)
- 	    {
  	      it_backup = *it;
  	      TRACE_MOVE ((stderr, "move_it: from %d\n", IT_CHARPOS (*it)));
  	      skip2 = move_it_in_display_line_to (it, to_charpos, -1,
  						  op & MOVE_TO_POS);
  	      TRACE_MOVE ((stderr, "move_it: to %d\n", IT_CHARPOS (*it)));
! 	    }
  
! 	  /* Now, decide whether TO_Y is in this line.  */
! 	  line_height = it->max_ascent + it->max_descent;
! 	  TRACE_MOVE ((stderr, "move_it: line_height = %d\n", line_height));
! 
! 	  if (to_y >= it->current_y
! 	      && to_y < it->current_y + line_height)
! 	    {
! 	      if (skip == MOVE_X_REACHED)
! 		/* If TO_Y is in this line and TO_X was reached above,
! 		   we scanned too far.  We have to restore IT's settings
! 		   to the ones before skipping.  */
! 		*it = it_backup;
! 	      reached = 6;
  	    }
! 	  else if (skip == MOVE_X_REACHED)
  	    {
! 	      skip = skip2;
! 	      if (skip == MOVE_POS_MATCH_OR_ZV)
! 		reached = 7;
  	    }
  
  	  if (reached)
--- 6963,7028 ----
  	     If we didn't use TO_X == 0, we would stop at the end of
  	     the line which is probably not what a caller would expect
  	     to happen.  */
! 	  skip = move_it_in_display_line_to
! 	    (it, to_charpos, ((op & MOVE_TO_X) ? to_x : 0),
! 	     (MOVE_TO_X | (op & MOVE_TO_POS)));
  
  	  /* If TO_CHARPOS is reached or ZV, we don't have to do more.  */
  	  if (skip == MOVE_POS_MATCH_OR_ZV)
+ 	    reached = 5;
+ 	  else if (skip == MOVE_X_REACHED)
  	    {
! 	     /* If TO_X was reached, we would like to know whether TO_Y
  	     is in the line.  This can only be said if we know the
  	     total line height which requires us to scan the rest of
  	     the line.  */
  	      it_backup = *it;
  	      TRACE_MOVE ((stderr, "move_it: from %d\n", IT_CHARPOS (*it)));
  	      skip2 = move_it_in_display_line_to (it, to_charpos, -1,
  						  op & MOVE_TO_POS);
  	      TRACE_MOVE ((stderr, "move_it: to %d\n", IT_CHARPOS (*it)));
! 	      line_height = it->max_ascent + it->max_descent;
! 	      TRACE_MOVE ((stderr, "move_it: line_height = %d\n", line_height));
  
! 	      if (to_y >= it->current_y
! 		  && to_y < it->current_y + line_height)
! 		{
! 		  /* If TO_Y is in this line and TO_X was reached
! 		     above, we scanned too far.  We have to restore
! 		     IT's settings to the ones before skipping.  */
! 		  *it = it_backup;
! 		  reached = 6;
! 		}
! 	      else
! 		{
! 		  skip = skip2;
! 		  if (skip == MOVE_POS_MATCH_OR_ZV)
! 		    reached = 7;
! 		}
  	    }
! 	  else
  	    {
! 	      /* Check whether TO_Y is in this line.  */
! 	      line_height = it->max_ascent + it->max_descent;
! 	      TRACE_MOVE ((stderr, "move_it: line_height = %d\n", line_height));
! 
! 	      if (to_y >= it->current_y
! 		  && to_y < it->current_y + line_height)
! 		{
! 		  /* When word-wrap is on, TO_X may lie past the end
! 		     of a wrapped line.  Then it->current is the
! 		     character on the next line, so backtrack to the
! 		     space before the wrap point.  */
! 		  if (skip == MOVE_LINE_CONTINUED
! 		      && it->line_wrap == WORD_WRAP)
! 		    {
! 		      int prev_x = max (it->current_x - 1, 0);
! 		      *it = it_backup;
! 		      skip = move_it_in_display_line_to
! 			(it, -1, prev_x, MOVE_TO_X);
! 		    }
! 		  reached = 6;
! 		}
  	    }
  
  	  if (reached)
***************
*** 6942,6948 ****
        && IT_CHARPOS (*it) == to_charpos
        && it->what == IT_CHARACTER
        && it->nglyphs > 1
!       && !it->truncate_lines_p
        && it->current_x == it->last_visible_x - 1
        && it->c != '\n'
        && it->c != '\t'
--- 7092,7098 ----
        && IT_CHARPOS (*it) == to_charpos
        && it->what == IT_CHARACTER
        && it->nglyphs > 1
!       && it->line_wrap != TRUNCATE
        && it->current_x == it->last_visible_x - 1
        && it->c != '\n'
        && it->c != '\t'
***************
*** 7955,7960 ****
--- 8105,8111 ----
  	sprintf (name, " *Echo Area %d*", i);
  	echo_buffer[i] = Fget_buffer_create (build_string (name));
  	XBUFFER (echo_buffer[i])->truncate_lines = Qnil;
+ 	XBUFFER (echo_buffer[i])->word_wrap = Qt;
  
  	for (j = 0; j < 2; ++j)
  	  if (EQ (old_buffer, echo_area_buffer[j]))
***************
*** 8365,8371 ****
        max_height = min (total_height, max_height);
  
        /* Find out the height of the text in the window.  */
!       if (it.truncate_lines_p)
  	height = 1;
        else
  	{
--- 8515,8521 ----
        max_height = min (total_height, max_height);
  
        /* Find out the height of the text in the window.  */
!       if (it.line_wrap == TRUNCATE)
  	height = 1;
        else
  	{
***************
*** 14188,14196 ****
    int yb = window_text_bottom_y (w);
  
    /* Find the last row displaying unchanged text.  */
!   row = MATRIX_FIRST_TEXT_ROW (w->current_matrix);
!   while (MATRIX_ROW_DISPLAYS_TEXT_P (row)
! 	 && MATRIX_ROW_START_CHARPOS (row) < first_changed_pos)
      {
        if (/* If row ends before first_changed_pos, it is unchanged,
  	     except in some case.  */
--- 14338,14347 ----
    int yb = window_text_bottom_y (w);
  
    /* Find the last row displaying unchanged text.  */
!   for (row = MATRIX_FIRST_TEXT_ROW (w->current_matrix);
!        MATRIX_ROW_DISPLAYS_TEXT_P (row)
! 	 && MATRIX_ROW_START_CHARPOS (row) < first_changed_pos;
!        ++row)
      {
        if (/* If row ends before first_changed_pos, it is unchanged,
  	     except in some case.  */
***************
*** 14207,14216 ****
  	row_found = row;
  
        /* Stop if last visible row.  */
!      if (MATRIX_ROW_BOTTOM_Y (row) >= yb)
  	break;
- 
-       ++row;
      }
  
    return row_found;
--- 14358,14365 ----
  	row_found = row;
  
        /* Stop if last visible row.  */
!       if (MATRIX_ROW_BOTTOM_Y (row) >= yb)
  	break;
      }
  
    return row_found;
***************
*** 14396,14402 ****
      }
  }
  
- 
  /* Try to redisplay window W by reusing its existing display.  W's
     current matrix must be up to date when this function is called,
     i.e. window_end_valid must not be nil.
--- 14545,14550 ----
***************
*** 14528,14533 ****
--- 14676,14687 ----
    if (overlay_arrows_changed_p ())
      GIVE_UP (12);
  
+   /* When word-wrap is on, adding a space to the first word of a
+      wrapped line can change the wrap position, altering the line
+      above it.  It might be worthwhile to handle this more
+      intelligently, but for now just redisplay from scratch.  */
+   if (!NILP (XBUFFER (w->buffer)->word_wrap))
+     GIVE_UP (21);
  
    /* Make sure beg_unchanged and end_unchanged are up to date.  Do it
       only if buffer has really changed.  The reason is that the gap is
***************
*** 16005,16010 ****
--- 16159,16169 ----
  {
    struct glyph_row *row = it->glyph_row;
    Lisp_Object overlay_arrow_string;
+   struct it wrap_it;
+   int may_wrap = 0, wrap_x;
+   int wrap_row_used = -1, wrap_row_ascent, wrap_row_height;
+   int wrap_row_phys_ascent, wrap_row_phys_height;
+   int wrap_row_extra_line_spacing;
  
    /* We always start displaying at hpos zero even if hscrolled.  */
    xassert (it->hpos == 0 && it->current_x == 0);
***************
*** 16099,16110 ****
  
        /* Remember the line height so far in case the next element doesn't
  	 fit on the line.  */
!       if (!it->truncate_lines_p)
  	{
  	  ascent = it->max_ascent;
  	  descent = it->max_descent;
  	  phys_ascent = it->max_phys_ascent;
  	  phys_descent = it->max_phys_descent;
  	}
  
        PRODUCE_GLYPHS (it);
--- 16258,16287 ----
  
        /* Remember the line height so far in case the next element doesn't
  	 fit on the line.  */
!       if (it->line_wrap != TRUNCATE)
  	{
  	  ascent = it->max_ascent;
  	  descent = it->max_descent;
  	  phys_ascent = it->max_phys_ascent;
  	  phys_descent = it->max_phys_descent;
+ 
+ 	  if (it->line_wrap == WORD_WRAP && it->area == TEXT_AREA)
+ 	    {
+ 	      if (IT_DISPLAYING_WHITESPACE (it))
+ 		may_wrap = 1;
+ 	      else if (may_wrap)
+ 		{
+ 		  wrap_it = *it;
+ 		  wrap_x = x;
+ 		  wrap_row_used = row->used[TEXT_AREA];
+ 		  wrap_row_ascent = row->ascent;
+ 		  wrap_row_height = row->height;
+ 		  wrap_row_phys_ascent = row->phys_ascent;
+ 		  wrap_row_phys_height = row->phys_height;
+ 		  wrap_row_extra_line_spacing = row->extra_line_spacing;
+ 		  may_wrap = 0;
+ 		}
+ 	    }
  	}
  
        PRODUCE_GLYPHS (it);
***************
*** 16164,16170 ****
  	      new_x = x + glyph->pixel_width;
  
  	      if (/* Lines are continued.  */
! 		  !it->truncate_lines_p
  		  && (/* Glyph doesn't fit on the line.  */
  		      new_x > it->last_visible_x
  		      /* Or it fits exactly on a window system frame.  */
--- 16341,16347 ----
  	      new_x = x + glyph->pixel_width;
  
  	      if (/* Lines are continued.  */
! 		  it->line_wrap != TRUNCATE
  		  && (/* Glyph doesn't fit on the line.  */
  		      new_x > it->last_visible_x
  		      /* Or it fits exactly on a window system frame.  */
***************
*** 16187,16192 ****
--- 16364,16381 ----
  		      ++it->hpos;
  		      if (i == nglyphs - 1)
  			{
+ 			  /* If line-wrap is on, check if a previous
+ 			     wrap point was found.  */
+ 			  if (wrap_row_used > 0
+ 			      /* Even if there is a previous wrap
+ 				 point, continue the line here as
+ 				 usual, if (i) the previous character
+ 				 was a space or tab AND (ii) the
+ 				 current character is not.  */
+ 			      && (!may_wrap
+ 				  || IT_DISPLAYING_WHITESPACE (it)))
+ 			    goto back_to_wrap;
+ 
  			  set_iterator_to_next (it, 1);
  #ifdef HAVE_WINDOW_SYSTEM
  			  if (IT_OVERFLOW_NEWLINE_INTO_FRINGE (it))
***************
*** 16232,16237 ****
--- 16421,16446 ----
  		      it->max_phys_ascent = phys_ascent;
  		      it->max_phys_descent = phys_descent;
  		    }
+ 		  else if (wrap_row_used > 0)
+ 		    {
+ 		    back_to_wrap:
+ 		      *it = wrap_it;
+ 		      it->continuation_lines_width += wrap_x;
+ 		      row->used[TEXT_AREA] = wrap_row_used;
+ 		      row->ascent = wrap_row_ascent;
+ 		      row->height = wrap_row_height;
+ 		      row->phys_ascent = wrap_row_phys_ascent;
+ 		      row->phys_height = wrap_row_phys_height;
+ 		      row->extra_line_spacing = wrap_row_extra_line_spacing;
+ 		      row->continued_p = 1;
+ 		      row->ends_at_zv_p = 0;
+ 		      row->exact_window_width_line_p = 0;
+ 		      it->continuation_lines_width += x;
+ 
+ 		      /* Make sure that a non-default face is extended
+ 			 up to the right margin of the window.  */
+ 		      extend_face_to_end_of_line (it);
+ 		    }
  		  else if (it->c == '\t' && FRAME_WINDOW_P (it->f))
  		    {
  		      /* A TAB that extends past the right edge of the
***************
*** 16347,16353 ****
  
        /* If we truncate lines, we are done when the last displayed
  	 glyphs reach past the right margin of the window.  */
!       if (it->truncate_lines_p
  	  && (FRAME_WINDOW_P (it->f)
  	      ? (it->current_x >= it->last_visible_x)
  	      : (it->current_x > it->last_visible_x)))
--- 16556,16562 ----
  
        /* If we truncate lines, we are done when the last displayed
  	 glyphs reach past the right margin of the window.  */
!       if (it->line_wrap == TRUNCATE
  	  && (FRAME_WINDOW_P (it->f)
  	      ? (it->current_x >= it->last_visible_x)
  	      : (it->current_x > it->last_visible_x)))
***************
*** 18356,18362 ****
  	{
  	  struct glyph *glyph = row->glyphs[TEXT_AREA] + n_glyphs_before + i;
  
! 	  if (!it->truncate_lines_p
  	      && x + glyph->pixel_width > max_x)
  	    {
  	      /* End of continued line or max_x reached.  */
--- 18565,18571 ----
  	{
  	  struct glyph *glyph = row->glyphs[TEXT_AREA] + n_glyphs_before + i;
  
! 	  if (it->line_wrap != TRUNCATE
  	      && x + glyph->pixel_width > max_x)
  	    {
  	      /* End of continued line or max_x reached.  */
***************
*** 18412,18418 ****
        set_iterator_to_next (it, 1);
  
        /* Stop if truncating at the right edge.  */
!       if (it->truncate_lines_p
  	  && it->current_x >= it->last_visible_x)
  	{
  	  /* Add truncation mark, but don't do it if the line is
--- 18621,18627 ----
        set_iterator_to_next (it, 1);
  
        /* Stop if truncating at the right edge.  */
!       if (it->line_wrap == TRUNCATE
  	  && it->current_x >= it->last_visible_x)
  	{
  	  /* Add truncation mark, but don't do it if the line is
***************
*** 20275,20281 ****
    else
      ascent = (height * FONT_BASE (font)) / FONT_HEIGHT (font);
  
!   if (width > 0 && !it->truncate_lines_p
        && it->current_x + width > it->last_visible_x)
      width = it->last_visible_x - it->current_x - 1;
  
--- 20484,20490 ----
    else
      ascent = (height * FONT_BASE (font)) / FONT_HEIGHT (font);
  
!   if (width > 0 && it->line_wrap != TRUNCATE
        && it->current_x + width > it->last_visible_x)
      width = it->last_visible_x - it->current_x - 1;
  
***************
*** 24149,24158 ****
    DEFVAR_INT ("debug-end-pos", &debug_end_pos, doc: /* Don't ask.  */);
  #endif
  
!   DEFVAR_BOOL ("truncate-partial-width-windows",
! 	       &truncate_partial_width_windows,
!     doc: /* *Non-nil means truncate lines in all windows less than full frame wide.  */);
!   truncate_partial_width_windows = 1;
  
    DEFVAR_BOOL ("mode-line-inverse-video", &mode_line_inverse_video,
      doc: /* When nil, display the mode-line/header-line/menu-bar in the default face.
--- 24358,24375 ----
    DEFVAR_INT ("debug-end-pos", &debug_end_pos, doc: /* Don't ask.  */);
  #endif
  
!   DEFVAR_LISP ("truncate-partial-width-windows",
! 	       &Vtruncate_partial_width_windows,
!     doc: /* Non-nil means truncate lines in windows with less than the frame width.
! For an integer value, truncate lines in each window with less than the
! full frame width, provided the window width is less than that integer;
! otherwise, respect the value of `truncate-lines'.
! 
! For any other non-nil value, truncate lines in all windows with
! less than the full frame width.
! 
!   Nil means to respect the value of `truncate-lines'.  */);
!   Vtruncate_partial_width_windows = make_number (30);
  
    DEFVAR_BOOL ("mode-line-inverse-video", &mode_line_inverse_video,
      doc: /* When nil, display the mode-line/header-line/menu-bar in the default face.
Index: indent.c
===================================================================
RCS file: /sources/emacs/emacs/src/indent.c,v
retrieving revision 1.192.2.3
diff -c -r1.192.2.3 indent.c
*** src/indent.c	8 Jan 2008 04:30:04 -0000	1.192.2.3
--- src/indent.c	25 Jul 2008 02:19:08 -0000
***************
*** 1395,1404 ****
  
        if (hpos > width)
  	{
! 	  if (hscroll
! 	      || (truncate_partial_width_windows
! 		  && ((width + continuation_glyph_width)
! 		      < FRAME_COLS (XFRAME (WINDOW_FRAME (win)))))
  	      || !NILP (current_buffer->truncate_lines))
  	    {
  	      /* Truncating: skip to newline, unless we are already past
--- 1395,1414 ----
  
        if (hpos > width)
  	{
! 	  int total_width = width + continuation_glyph_width;
! 	  int truncate = 0;
! 
! 	  if (!NILP ((Lisp_Object) Vtruncate_partial_width_windows)
! 	      && (total_width < FRAME_COLS (XFRAME (WINDOW_FRAME (win)))))
! 	    {
! 	      if (INTEGERP ((Lisp_Object) Vtruncate_partial_width_windows))
! 		truncate
! 		  = total_width < XFASTINT ((Lisp_Object) Vtruncate_partial_width_windows);
! 	      else
! 		truncate = 1;
! 	    }
! 
! 	  if (hscroll || truncate
  	      || !NILP (current_buffer->truncate_lines))
  	    {
  	      /* Truncating: skip to newline, unless we are already past
***************
*** 2023,2028 ****
--- 2033,2039 ----
  			 w);
  }
  
+ 
  DEFUN ("vertical-motion", Fvertical_motion, Svertical_motion, 1, 2, 0,
         doc: /* Move point to start of the screen line LINES lines down.
  If LINES is negative, this means moving up.
***************
*** 2039,2044 ****
--- 2050,2059 ----
  parameters such as width, horizontal scrolling, and so on.
  The default is to use the selected window's parameters.
  
+ LINES can optionally take the form (COLS . LINES), in which case
+ the motion will not stop at the start of a screen line but on
+ its column COLS (if such exists on that line, that is).
+ 
  `vertical-motion' always uses the current buffer,
  regardless of which buffer is displayed in WINDOW.
  This is consistent with other cursor motion functions
***************
*** 2052,2057 ****
--- 2067,2082 ----
    struct window *w;
    Lisp_Object old_buffer;
    struct gcpro gcpro1;
+   Lisp_Object lcols = Qnil;
+   double cols;
+ 
+   /* Allow LINES to be of the form (HPOS . VPOS) aka (COLUMNS . LINES).  */
+   if (CONSP (lines) && (NUMBERP (XCAR (lines))))
+     {
+       lcols = XCAR (lines);
+       cols = INTEGERP (lcols) ? (double) XINT (lcols) : XFLOAT_DATA (lcols);
+       lines = XCDR (lines);
+     }
  
    CHECK_NUMBER (lines);
    if (! NILP (window))
***************
*** 2077,2088 ****
      }
    else
      {
!       int it_start;
!       int oselective;
!       int it_overshoot_expected;
  
        SET_TEXT_POS (pt, PT, PT_BYTE);
        start_display (&it, w, pt);
  
        /* Scan from the start of the line containing PT.  If we don't
  	 do this, we start moving with IT->current_x == 0, while PT is
--- 2102,2112 ----
      }
    else
      {
!       int it_start, oselective, it_overshoot_expected, first_x;
  
        SET_TEXT_POS (pt, PT, PT_BYTE);
        start_display (&it, w, pt);
+       first_x = it.first_visible_x;
  
        /* Scan from the start of the line containing PT.  If we don't
  	 do this, we start moving with IT->current_x == 0, while PT is
***************
*** 2140,2145 ****
--- 2164,2185 ----
        if (XINT (lines) >= 0 || IT_CHARPOS (it) > 0)
  	move_it_by_lines (&it, XINT (lines), 0);
  
+       /* Move to the goal column, if one was specified.  */
+       if (!NILP (lcols))
+ 	{
+ 	  /* If the window was originally hscrolled, move forward by
+ 	     the hscrolled amount first.  */
+ 	  if (first_x > 0)
+ 	    {
+ 	      move_it_in_display_line (&it, ZV, first_x, MOVE_TO_X);
+ 	      it.current_x = 0;
+ 	    }
+ 	  move_it_in_display_line
+ 	    (&it, ZV,
+ 	     (int)(cols * FRAME_COLUMN_WIDTH (XFRAME (w->frame)) + 0.5),
+ 	     MOVE_TO_X);
+ 	}
+ 
        SET_PT_BOTH (IT_CHARPOS (it), IT_BYTEPOS (it));
      }
  
***************
*** 2150,2155 ****
--- 2190,2196 ----
  }
  
  
+ 
  
  /* File's initialization.  */
  
Index: dispnew.c
===================================================================
RCS file: /sources/emacs/emacs/src/dispnew.c,v
retrieving revision 1.392.2.3
diff -c -r1.392.2.3 dispnew.c
*** src/dispnew.c	5 Mar 2008 00:50:06 -0000	1.392.2.3
--- src/dispnew.c	5 Jul 2008 12:51:34 -0000
***************
*** 3516,3521 ****
--- 3516,3522 ----
        || g == '\t'
        || g == '\n'
        || g == '\r'
+       || (g == ' ' && !NILP (current_buffer->word_wrap))
        /* Give up if unable to display the cursor in the window.  */
        || w->cursor.vpos < 0
        /* Give up if we are showing a message or just cleared the message
Index: termopts.h
===================================================================
RCS file: /sources/emacs/emacs/src/termopts.h,v
retrieving revision 1.10.2.2
diff -c -r1.10.2.2 termopts.h
*** src/termopts.h	8 Jan 2008 04:29:50 -0000	1.10.2.2
--- src/termopts.h	5 Jul 2008 12:51:34 -0000
***************
*** 38,45 ****
  /* Terminal has meta key */
  extern int meta_key;
  
! /* Nonzero means truncate lines in all windows less wide than the frame */
! extern int truncate_partial_width_windows;
  
  /* arch-tag: 35d4d284-dc1a-4fff-97fa-0154a21aebdb
     (do not change this comment) */
--- 38,45 ----
  /* Terminal has meta key */
  extern int meta_key;
  
! /* Defined in xdisp.c */
! extern void* Vtruncate_partial_width_windows;
  
  /* arch-tag: 35d4d284-dc1a-4fff-97fa-0154a21aebdb
     (do not change this comment) */
Index: buffer.c
===================================================================
RCS file: /sources/emacs/emacs/src/buffer.c,v
retrieving revision 1.526.2.5
diff -c -r1.526.2.5 buffer.c
*** src/buffer.c	8 Jan 2008 04:30:20 -0000	1.526.2.5
--- src/buffer.c	5 Jul 2008 12:51:36 -0000
***************
*** 5036,5041 ****
--- 5036,5042 ----
  
    XSETFASTINT (buffer_defaults.tab_width, 8);
    buffer_defaults.truncate_lines = Qnil;
+   buffer_defaults.word_wrap = Qnil;
    buffer_defaults.ctl_arrow = Qt;
    buffer_defaults.direction_reversed = Qnil;
    buffer_defaults.cursor_type = Qt;
***************
*** 5108,5113 ****
--- 5109,5115 ----
  #endif
    XSETFASTINT (buffer_local_flags.tab_width, idx); ++idx;
    XSETFASTINT (buffer_local_flags.truncate_lines, idx); ++idx;
+   XSETFASTINT (buffer_local_flags.word_wrap, idx); ++idx;
    XSETFASTINT (buffer_local_flags.ctl_arrow, idx); ++idx;
    XSETFASTINT (buffer_local_flags.fill_column, idx); ++idx;
    XSETFASTINT (buffer_local_flags.left_margin, idx); ++idx;
***************
*** 5356,5361 ****
--- 5358,5368 ----
  		     doc: /* Default value of `truncate-lines' for buffers that do not override it.
  This is the same as (default-value 'truncate-lines).  */);
  
+   DEFVAR_LISP_NOPRO ("default-word-wrap",
+ 		     &buffer_defaults.word_wrap,
+ 		     doc: /* Default value of `word-wrap' for buffers that do not override it.
+ This is the same as (default-value 'word-wrap).  */);
+ 
    DEFVAR_LISP_NOPRO ("default-fill-column",
  		     &buffer_defaults.fill_column,
  		     doc: /* Default value of `fill-column' for buffers that do not override it.
***************
*** 5600,5605 ****
--- 5607,5621 ----
  `truncate-partial-width-windows' if that variable is non-nil
  and this buffer is not full-frame width.  */);
  
+   DEFVAR_PER_BUFFER ("word-wrap", &current_buffer->word_wrap, Qnil,
+ 		     doc: /* *Non-nil means to use word-wrapping for continuation lines.
+ When word-wrapping is on, continuation lines are wrapped at the space
+ or tab character nearest to the right window edge.
+ If nil, continuation lines are wrapped at the right screen edge.
+ 
+ This variable has no effect if long lines are truncated (see
+ `truncate-lines' and `truncate-partial-width-windows').  */);
+ 
  #ifdef DOS_NT
    DEFVAR_PER_BUFFER ("buffer-file-type", &current_buffer->buffer_file_type,
  		     Qnil,
Index: buffer.h
===================================================================
RCS file: /sources/emacs/emacs/src/buffer.h,v
retrieving revision 1.109.2.3
diff -c -r1.109.2.3 buffer.h
*** src/buffer.h	8 Jan 2008 04:30:20 -0000	1.109.2.3
--- src/buffer.h	5 Jul 2008 12:51:36 -0000
***************
*** 643,648 ****
--- 643,650 ----
  
    /* Non-nil means do not display continuation lines.  */
    Lisp_Object truncate_lines;
+   /* Non-nil means to use word wrapping when displaying continuation lines.  */
+   Lisp_Object word_wrap;
    /* Non-nil means display ctl chars with uparrow.  */
    Lisp_Object ctl_arrow;
    /* Non-nil means display text from right to left.  */
Index: dispextern.h
===================================================================
RCS file: /sources/emacs/emacs/src/dispextern.h,v
retrieving revision 1.225.2.7
diff -c -r1.225.2.7 dispextern.h
*** src/dispextern.h	8 Jan 2008 04:30:14 -0000	1.225.2.7
--- src/dispextern.h	5 Jul 2008 12:51:37 -0000
***************
*** 1800,1805 ****
--- 1800,1813 ----
    LAST_PROP_IDX
  };
  
+ /* An enumerator for the method of wrapping long lines.  */
+  	  	 
+ enum line_wrap_method
+ {
+   TRUNCATE,
+   WORD_WRAP,
+   WINDOW_WRAP
+ };
  
  struct it_slice
  {
***************
*** 2004,2011 ****
       where the `^' can be replaced by a display table entry.  */
    unsigned ctl_arrow_p : 1;
  
!   /* 1 means lines are truncated.  */
!   unsigned truncate_lines_p : 1;
  
    /* Non-zero means that the current face has a box.  */
    unsigned face_box_p : 1;
--- 2012,2018 ----
       where the `^' can be replaced by a display table entry.  */
    unsigned ctl_arrow_p : 1;
  
!   enum line_wrap_method line_wrap;
  
    /* Non-zero means that the current face has a box.  */
    unsigned face_box_p : 1;
