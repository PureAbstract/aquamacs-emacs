A  src/ChangeLog.face-remap
M  src/xfaces.c
M  src/dispextern.h
M  src/fontset.c
M  src/xdisp.c
M  lisp/term/mac-win.el 
M  src/mactoolbox.c

--- src/dispextern.h
+++ src/dispextern.h
@@ -2860,6 +2872,7 @@
 int xstricmp P_ ((const unsigned char *, const unsigned char *));
 int lookup_face P_ ((struct frame *, Lisp_Object *, int, struct face *));
 int lookup_named_face P_ ((struct frame *, Lisp_Object, int, int));
+int lookup_basic_face P_ ((struct frame *, int));
 int smaller_face P_ ((struct frame *, int, int));
 int face_with_height P_ ((struct frame *, int, int));
 int lookup_derived_face P_ ((struct frame *, Lisp_Object, int, int, int));
@@ -2880,6 +2881,8 @@
 extern Lisp_Object split_font_name_into_vector P_ ((Lisp_Object));
 extern Lisp_Object build_font_name_from_vector P_ ((Lisp_Object));
 
+extern Lisp_Object Vface_remapping_alist;
+
 /* Defined in xfns.c  */
 
 #ifdef HAVE_X_WINDOWS


--- src/fontset.c
+++ src/fontset.c
@@ -1304,7 +1304,7 @@
       CHECK_NATNUM (ch);
       c = XINT (ch);
       f = XFRAME (selected_frame);
-      face_id = DEFAULT_FACE_ID;
+      face_id = lookup_basic_face (f, DEFAULT_FACE_ID);
     }
   else
     {
--- src/xdisp.c
+++ src/xdisp.c
@@ -2493,6 +2493,7 @@
      enum face_id base_face_id;
 {
   int highlight_region_p;
+  enum face_id remapped_base_face_id = base_face_id;
 
   /* Some precondition checks.  */
   xassert (w != NULL && it != NULL);
@@ -2509,6 +2510,10 @@
       free_all_realized_faces (Qnil);
     }
 
+  /* Perhaps remap BASE_FACE_ID to a user-specified alternative.  */
+  if (! NILP (Vface_remapping_alist))
+    remapped_base_face_id = lookup_basic_face (XFRAME (w->frame), base_face_id);
+
   /* Use one of the mode line rows of W's desired matrix if
      appropriate.  */
   if (row == NULL)
@@ -2524,7 +2529,7 @@
   bzero (it, sizeof *it);
   it->current.overlay_string_index = -1;
   it->current.dpvec_index = -1;
-  it->base_face_id = base_face_id;
+  it->base_face_id = remapped_base_face_id;
   it->string = Qnil;
   IT_STRING_CHARPOS (*it) = IT_STRING_BYTEPOS (*it) = -1;
 
@@ -2709,11 +2714,11 @@
     {
       struct face *face;
 
-      it->face_id = base_face_id;
+      it->face_id = remapped_base_face_id;
 
       /* If we have a boxed mode line, make the first character appear
 	 with a left box line.  */
-      face = FACE_FROM_ID (it->f, base_face_id);
+      face = FACE_FROM_ID (it->f, remapped_base_face_id);
       if (face->box != FACE_NO_BOX)
 	it->start_of_box_run_p = 1;
     }
@@ -4079,7 +4084,8 @@
 	      /* Value is a multiple of the canonical char height.  */
 	      struct face *face;
 
-	      face = FACE_FROM_ID (it->f, DEFAULT_FACE_ID);
+	      face = FACE_FROM_ID (it->f,
+				   lookup_basic_face (it->f, DEFAULT_FACE_ID));
 	      new_height = (XFLOATINT (it->font_height)
 			    * XINT (face->lface[LFACE_HEIGHT_INDEX]));
 	    }
@@ -4189,7 +4195,7 @@
 	  || EQ (XCAR (spec), Qright_fringe))
       && CONSP (XCDR (spec)))
     {
-      int face_id = DEFAULT_FACE_ID;
+      int face_id = lookup_basic_face (it->f, DEFAULT_FACE_ID);
       int fringe_bitmap;
 
       if (!FRAME_WINDOW_P (it->f))


--- src/xfaces.c
+++ src/xfaces.c
@@ -422,6 +422,23 @@
 
 Lisp_Object Vface_new_frame_defaults;
 
+/* Alist of face remappings.  Each element is of the form:
+   (FACE REPLACEMENT...) which causes display of the face FACE to use
+   REPLACEMENT... instead.  REPLACEMENT... is interpreted the same way
+   the value of a `face' text property is: it may be (1) A face name,
+   (2) A list of face names, (3) A property-list of face attribute/value
+   pairs, or (4) A list of face names intermixed with lists containing
+   face attribute/value pairs.
+
+   Multiple entries in REPLACEMENT... are merged together to form the final
+   result, with faces or attributes earlier in the list taking precedence
+   over those that are later.
+
+   Face-name remapping cycles are suppressed; recursive references use
+   the underlying face instead of the remapped face.  */
+
+Lisp_Object Vface_remapping_alist;
+
 /* The next ID to assign to Lisp faces.  */
 
 static int next_lface_id;
@@ -484,7 +501,8 @@
 static int x_face_list_fonts P_ ((struct frame *, char *,
 				  struct font_name **, int, int));
 static int font_scalable_p P_ ((struct font_name *));
-static int get_lface_attributes P_ ((struct frame *, Lisp_Object, Lisp_Object *, int));
+static int get_lface_attributes P_ ((struct frame *, Lisp_Object, Lisp_Object *,
+ 				     int, struct named_merge_point *));
 static int load_pixmap P_ ((struct frame *, Lisp_Object, unsigned *, unsigned *));
 static unsigned char *xstrlwr P_ ((unsigned char *));
 static struct frame *frame_or_selected_frame P_ ((Lisp_Object, int));
@@ -3183,6 +3201,12 @@
 
 /* Face-merge cycle checking.  */
 
+enum named_merge_point_kind
+{
+  NAMED_MERGE_POINT_NORMAL,
+  NAMED_MERGE_POINT_REMAP
+};
+
 /* A `named merge point' is simply a point during face-merging where we
    look up a face by name.  We keep a stack of which named lookups we're
    currently processing so that we can easily detect cycles, using a
@@ -3192,27 +3216,40 @@
 struct named_merge_point
 {
   Lisp_Object face_name;
+  enum named_merge_point_kind named_merge_point_kind;
   struct named_merge_point *prev;
 };
 
 
 /* If a face merging cycle is detected for FACE_NAME, return 0,
    otherwise add NEW_NAMED_MERGE_POINT, which is initialized using
-   FACE_NAME, as the head of the linked list pointed to by
-   NAMED_MERGE_POINTS, and return 1.  */
+   FACE_NAME and NAMED_MERGE_POINT_KIND, as the head of the linked list
+   pointed to by NAMED_MERGE_POINTS, and return 1.  */
 
 static INLINE int
 push_named_merge_point (struct named_merge_point *new_named_merge_point,
 			Lisp_Object face_name,
+			enum named_merge_point_kind named_merge_point_kind,
 			struct named_merge_point **named_merge_points)
 {
   struct named_merge_point *prev;
 
   for (prev = *named_merge_points; prev; prev = prev->prev)
     if (EQ (face_name, prev->face_name))
-      return 0;
+      {
+	if (prev->named_merge_point_kind == named_merge_point_kind)
+	  /* A cycle, so fail.  */
+	  return 0;
+	else if (prev->named_merge_point_kind == NAMED_MERGE_POINT_REMAP)
+	  /* A remap `hides ' any previous normal merge points
+	     (because the remap means that it's actually different face),
+	     so as we know the current merge point must be normal, we
+	     can just assume it's OK.  */
+	  break;
+      }
 
   new_named_merge_point->face_name = face_name;
+  new_named_merge_point->named_merge_point_kind = named_merge_point_kind;
   new_named_merge_point->prev = *named_merge_points;
 
   *named_merge_points = new_named_merge_point;
@@ -3274,22 +3311,17 @@
 /* Return the face definition of FACE_NAME on frame F.  F null means
    return the definition for new frames.  FACE_NAME may be a string or
    a symbol (apparently Emacs 20.2 allowed strings as face names in
-   face text properties; Ediff uses that).  If FACE_NAME is an alias
-   for another face, return that face's definition.  If SIGNAL_P is
-   non-zero, signal an error if FACE_NAME is not a valid face name.
-   If SIGNAL_P is zero, value is nil if FACE_NAME is not a valid face
-   name.  */
-
+   face text properties; Ediff uses that).  If SIGNAL_P is non-zero,
+   signal an error if FACE_NAME is not a valid face name.  If SIGNAL_P
+   is zero, value is nil if FACE_NAME is not a valid face name.  */
 static INLINE Lisp_Object
-lface_from_face_name (f, face_name, signal_p)
+lface_from_face_name_no_resolve (f, face_name, signal_p)
      struct frame *f;
      Lisp_Object face_name;
      int signal_p;
 {
   Lisp_Object lface;
 
-  face_name = resolve_face_name (face_name, signal_p);
-
   if (f)
     lface = assq_no_quit (face_name, f->face_alist);
   else
@@ -3301,9 +3333,28 @@
     signal_error ("Invalid face", face_name);
 
   check_lface (lface);
+
   return lface;
 }
 
+/* Return the face definition of FACE_NAME on frame F.  F null means
+   return the definition for new frames.  FACE_NAME may be a string or
+   a symbol (apparently Emacs 20.2 allowed strings as face names in
+   face text properties; Ediff uses that).  If FACE_NAME is an alias
+   for another face, return that face's definition.  If SIGNAL_P is
+   non-zero, signal an error if FACE_NAME is not a valid face name.
+   If SIGNAL_P is zero, value is nil if FACE_NAME is not a valid face
+   name.  */
+static INLINE Lisp_Object
+lface_from_face_name (f, face_name, signal_p)
+     struct frame *f;
+     Lisp_Object face_name;
+     int signal_p;
+{
+  face_name = resolve_face_name (face_name, signal_p);
+  return lface_from_face_name_no_resolve (f, face_name, signal_p);
+}
+
 
 /* Get face attributes of face FACE_NAME from frame-local faces on
    frame F.  Store the resulting attributes in ATTRS which must point
@@ -3312,26 +3363,65 @@
    Otherwise, value is zero if FACE_NAME is not a face.  */
 
 static INLINE int
-get_lface_attributes (f, face_name, attrs, signal_p)
+get_lface_attributes_no_remap (f, face_name, attrs, signal_p)
      struct frame *f;
      Lisp_Object face_name;
      Lisp_Object *attrs;
      int signal_p;
 {
   Lisp_Object lface;
-  int success_p;
 
-  lface = lface_from_face_name (f, face_name, signal_p);
-  if (!NILP (lface))
+  lface = lface_from_face_name_no_resolve (f, face_name, signal_p);
+
+  if (! NILP (lface))
+    bcopy (XVECTOR (lface)->contents, attrs,
+	   LFACE_VECTOR_SIZE * sizeof *attrs);
+
+  return !NILP (lface);
+}
+
+/* Get face attributes of face FACE_NAME from frame-local faces on frame
+   F.  Store the resulting attributes in ATTRS which must point to a
+   vector of Lisp_Objects of size LFACE_VECTOR_SIZE.  If FACE_NAME is an
+   alias for another face, use that face's definition.  If SIGNAL_P is
+   non-zero, signal an error if FACE_NAME does not name a face.
+   Otherwise, value is zero if FACE_NAME is not a face.  */
+
+static INLINE int
+get_lface_attributes (f, face_name, attrs, signal_p, named_merge_points)
+     struct frame *f;
+     Lisp_Object face_name;
+     Lisp_Object *attrs;
+     int signal_p;
+     struct named_merge_point *named_merge_points;
+{
+  Lisp_Object face_remapping;
+
+  face_name = resolve_face_name (face_name, signal_p);
+
+  /* See if SYMBOL has been remapped to some other face (usually this
+     is done buffer-locally).  */
+  face_remapping = assq_no_quit (face_name, Vface_remapping_alist);
+  if (CONSP (face_remapping))
     {
-      bcopy (XVECTOR (lface)->contents, attrs,
-	     LFACE_VECTOR_SIZE * sizeof *attrs);
-      success_p = 1;
+      struct named_merge_point named_merge_point;
+
+      if (push_named_merge_point (&named_merge_point,
+				  face_name, NAMED_MERGE_POINT_REMAP,
+				  &named_merge_points))
+	{
+	  int i;
+
+	  for (i = 1; i < LFACE_VECTOR_SIZE; ++i)
+	    attrs[i] = Qunspecified;
+
+	  return merge_face_ref (f, XCDR (face_remapping), attrs,
+				 signal_p, named_merge_points);
+	}
     }
-  else
-    success_p = 0;
 
-  return success_p;
+  /* Default case, no remapping.  */
+  return get_lface_attributes_no_remap (f, face_name, attrs, signal_p);
 }
 
 
@@ -3524,8 +3614,8 @@
    specified attribute of FROM overrides the corresponding attribute of
    TO; relative attributes in FROM are merged with the absolute value in
    TO and replace it.  NAMED_MERGE_POINTS is used internally to detect
-   loops in face inheritance; it should be 0 when called from other
-   places.  */
+   loops in face inheritance/remapping; it should be 0 when called from
+   other places.  */
 
 static INLINE void
 merge_face_vectors (f, from, to, named_merge_points)
@@ -3586,11 +3676,12 @@
   struct named_merge_point named_merge_point;
 
   if (push_named_merge_point (&named_merge_point,
-			      face_name, &named_merge_points))
+			      face_name, NAMED_MERGE_POINT_NORMAL,
+			      &named_merge_points))
     {
       struct gcpro gcpro1;
       Lisp_Object from[LFACE_VECTOR_SIZE];
-      int ok = get_lface_attributes (f, face_name, from, 0);
+      int ok = get_lface_attributes (f, face_name, from, 0, named_merge_points);
 
       if (ok)
 	{
@@ -4540,7 +4631,7 @@
 
       /* Changing the background color might change the background
 	 mode, so that we have to load new defface specs.
-	 Call frame-set-background-mode to do that.  */
+	 Call frame-update-face-colors to do that.  */
       XSETFRAME (frame, f);
       call1 (Qframe_set_background_mode, frame);
 
@@ -5720,7 +5811,7 @@
 	abort ();  /* realize_basic_faces must have set it up  */
     }
 
-  if (!get_lface_attributes (f, symbol, symbol_attrs, signal_p))
+  if (! get_lface_attributes (f, symbol, symbol_attrs, signal_p, 0))
     return -1;
 
   bcopy (default_face->lface, attrs, sizeof attrs);
@@ -5730,6 +5821,58 @@
 }
 
 
+/* Return the display face-id of the basic face who's canonical face-id
+   is FACE_ID.  The return value will usually simply be FACE_ID, unless that
+   basic face has bee remapped via Vface_remapping_alist.  This function is
+   conservative: if something goes wrong, it will simply return FACE_ID
+   rather than signal an error.   */
+
+int
+lookup_basic_face (f, face_id)
+     struct frame *f;
+     int face_id;
+{
+  Lisp_Object name, mapping;
+  int remapped_face_id;
+
+  if (NILP (Vface_remapping_alist))
+    return face_id;		/* Nothing to do.  */
+
+  switch (face_id)
+    {
+    case DEFAULT_FACE_ID:		name = Qdefault;		break;
+    case MODE_LINE_FACE_ID:		name = Qmode_line;		break;
+    case MODE_LINE_INACTIVE_FACE_ID:	name = Qmode_line_inactive;	break;
+    case HEADER_LINE_FACE_ID:		name = Qheader_line;		break;
+    case TOOL_BAR_FACE_ID:		name = Qtool_bar;		break;
+    case FRINGE_FACE_ID:		name = Qfringe;			break;
+    case SCROLL_BAR_FACE_ID:		name = Qscroll_bar;		break;
+    case BORDER_FACE_ID:		name = Qborder;			break;
+    case CURSOR_FACE_ID:		name = Qcursor;			break;
+    case MOUSE_FACE_ID:			name = Qmouse;			break;
+    case MENU_FACE_ID:			name = Qmenu;			break;
+
+    default:
+      abort ();	    /* the caller is supposed to pass us a basic face id */
+    }
+
+  /* Do a quick scan through Vface_remapping_alist, and return immediately
+     if there is no remapping for face NAME.  This is just an optimization
+     for the very common no-remapping case.  */
+  mapping = assq_no_quit (name, Vface_remapping_alist);
+  if (NILP (mapping))
+    return face_id;		/* Give up.  */
+
+  /* If there is a remapping entry, lookup the face using NAME, which will
+     handle the remapping too.  */
+  remapped_face_id = lookup_named_face (f, name, 0, 0);
+  if (remapped_face_id < 0)
+    return face_id;		/* Give up. */
+
+  return remapped_face_id;
+}
+
+
 /* Return the ID of the realized ASCII face of Lisp face with ID
    LFACE_ID on frame F.  Value is -1 if LFACE_ID isn't valid.  */
 
@@ -5863,7 +6006,7 @@
   if (!default_face)
     abort ();
 
-  get_lface_attributes (f, symbol, symbol_attrs, signal_p);
+  get_lface_attributes (f, symbol, symbol_attrs, signal_p, 0);
   bcopy (default_face->lface, attrs, sizeof attrs);
   merge_face_vectors (f, symbol_attrs, attrs, 0);
   return lookup_face (f, attrs, c, default_face);
@@ -7105,7 +7248,7 @@
   struct face *new_face;
 
   /* The default face must exist and be fully specified.  */
-  get_lface_attributes (f, Qdefault, attrs, 1);
+  get_lface_attributes_no_remap (f, Qdefault, attrs, 1);
   check_lface_attrs (attrs);
   xassert (lface_fully_specified_p (attrs));
 
@@ -7118,7 +7261,7 @@
     }
 
   /* Merge SYMBOL's face with the default face.  */
-  get_lface_attributes (f, symbol, symbol_attrs, 1);
+  get_lface_attributes_no_remap (f, symbol, symbol_attrs, 1);
   merge_face_vectors (f, symbol_attrs, attrs, 0);
 
   /* Realize the face.  */
@@ -7658,13 +7801,18 @@
 
   *endptr = endpos;
 
-  default_face = FACE_FROM_ID (f, DEFAULT_FACE_ID);
+
+  /* Perhaps remap BASE_FACE_ID to a user-specified alternative.  */
+  if (NILP (Vface_remapping_alist))
+    default_face = FACE_FROM_ID (f, DEFAULT_FACE_ID);
+  else
+    default_face = FACE_FROM_ID (f, lookup_basic_face (f, DEFAULT_FACE_ID));
 
   /* Optimize common cases where we can use the default face.  */
   if (noverlays == 0
       && NILP (prop)
       && !(pos >= region_beg && pos < region_end))
-    return DEFAULT_FACE_ID;
+    return default_face->id;
 
   /* Begin with attributes from the default face.  */
   bcopy (default_face->lface, attrs, sizeof attrs);
@@ -8264,6 +8412,43 @@
 ignore.  */);
   Vface_ignored_fonts = Qnil;
 
+  DEFVAR_LISP ("face-remapping-alist", &Vface_remapping_alist,
+	       doc: /* Alist of face remappings.
+Each element is of the form:
+
+   (FACE REPLACEMENT...),
+
+which causes display of the face FACE to use REPLACEMENT... instead.
+REPLACEMENT... is interpreted the same way the value of a `face' text
+property is: it may be (1) A face name, (2) A list of face names, (3) A
+property-list of face attribute/value pairs, or (4) A list of face names
+intermixed with lists containing face attribute/value pairs.
+
+Multiple entries in REPLACEMENT... are merged together to form the final
+result, with faces or attributes earlier in the list taking precedence
+over those that are later.
+
+Face-name remapping cycles are suppressed; recursive references use the
+underlying face instead of the remapped face.  So a remapping of the form:
+
+   (FACE EXTRA-FACE... FACE)
+
+or:
+
+   (FACE (FACE-ATTR VAL ...) FACE)
+
+will cause EXTRA-FACE... or (FACE-ATTR VAL ...) to be _merged_ with the
+existing definition of FACE.  Note that for the default face, this isn't
+necessary, as every face inherits from the default face.
+
+Making this variable buffer-local is a good way to allow buffer-specific
+face definitions.  For instance, the mode my-mode could define a face
+`my-mode-default', and then in the mode setup function, do:
+
+   (set (make-local-variable 'face-remapping-alist)
+        '((default my-mode-default)))).  */);
+  Vface_remapping_alist = Qnil;
+
   DEFVAR_LISP ("face-font-rescale-alist", &Vface_font_rescale_alist,
 	       doc: /* Alist of fonts vs the rescaling factors.
 Each element is a cons (FONT-NAME-PATTERN . RESCALE-RATIO), where
*** lisp/term/mac-win.el	23 Apr 2008 08:56:55 -0000	1.88.2.11
--- lisp/term/mac-win.el	30 Sep 2008 20:06:01 -0000
***************
*** 1816,1827 ****
--- 1839,1865 ----
  ;;; Font panel
  (when (fboundp 'mac-set-font-panel-visible-p)
  
+ (defvar mac-font-panel-target-face 'default)
+ (defvar mac-font-panel-target-frame nil)
+ 
  (define-minor-mode mac-font-panel-mode
    "Toggle use of the font panel.
  With numeric ARG, display the font panel if and only if ARG is positive."
    :init-value nil
    :global t
    :group 'mac
+   (when mac-font-panel-mode
+     (setq mac-font-panel-target-face 'default)
+ 
+     (when (and (boundp 'face-remapping-alist)
+ 	     (assq mac-font-panel-target-face face-remapping-alist))
+       (setq mac-font-panel-target-face 
+ 	    (let ((face (cdr (assq mac-font-panel-target-face
+ 				   face-remapping-alist))))
+ 	      (if (get face 'theme-face)
+ 		  face
+ 		(or (face-attribute face :inherit)
+ 		    mac-font-panel-target-face))))))
    (mac-set-font-panel-visible-p mac-font-panel-mode))
  
  (defun mac-handle-font-panel-closed (event)
***************
*** 1834,1839 ****
--- 1860,1866 ----
    "Change default face attributes according to font selection EVENT."
    (interactive "e")
    (let* ((ae (mac-event-ae event))
+ 	 (face (or mac-font-panel-target-face 'default))
  	 (fm-font-size (mac-ae-number ae "fmsz"))
  	 (atsu-font-id (mac-ae-number ae "auid"))
  	 (attribute-values (and atsu-font-id
***************
*** 1841,1847 ****
      (if fm-font-size
  	(setq attribute-values
  	      `(:height ,(* 10 fm-font-size) ,@attribute-values)))
!     (apply 'set-face-attribute 'default (selected-frame) attribute-values)))
  
  ;; kEventClassFont/kEventFontPanelClosed
  (define-key mac-apple-event-map [font panel-closed]
--- 1868,1883 ----
      (if fm-font-size
  	(setq attribute-values
  	      `(:height ,(* 10 fm-font-size) ,@attribute-values)))
!     
!     (apply 'set-face-attribute face
! 	   mac-font-panel-target-frame attribute-values)
!     ;; ensure this is saved as a customization
!     (let ((value 
! 	   (list (list t (custom-face-attributes-get 
! 			  face nil)))))
!       (put face 'saved-face value)
!       (custom-push-theme 'theme-face face 'user 'set value))
!     (message "Font set for %s face." face)))
  
  ;; kEventClassFont/kEventFontPanelClosed
  (define-key mac-apple-event-map [font panel-closed]
*** src/mactoolbox.c	20 Aug 2008 09:05:31 -0000	1.1.2.6
--- src/mactoolbox.c	30 Sep 2008 20:12:55 -0000
***************
*** 3249,3255 ****
  	  struct face *face;
  
  	  face_id = FACE_FOR_CHAR (f, FACE_FROM_ID (f, face_id), c);
! 	  face = FACE_FROM_ID (f, face_id);
  	  font = face->font;
  	}
      }
--- 3296,3306 ----
  	  struct face *face;
  
  	  face_id = FACE_FOR_CHAR (f, FACE_FROM_ID (f, face_id), c);
! 	  if (NILP (Vface_remapping_alist))
! 	    face = FACE_FROM_ID (f, face_id);
! 	  else
! 	    face = FACE_FROM_ID (f, lookup_basic_face (f, face_id));
! 
  	  font = face->font;
  	}
      }
*** src/xdisp.c	5 Jun 2008 03:57:09 -0000	1.1217
--- src/xdisp.c	6 Jun 2008 23:07:50 -0000	1.1218
***************
*** 20980,20993 ****
  	}
        else if (it->char_to_display == '\t')
  	{
! 	  int tab_width = it->tab_width * FRAME_SPACE_WIDTH (it->f);
  	  int x = it->current_x + it->continuation_lines_width;
  	  int next_tab_x = ((1 + x + tab_width - 1) / tab_width) * tab_width;
  
  	  /* If the distance from the current position to the next tab
  	     stop is less than a space character width, use the
  	     tab stop after that.  */
! 	  if (next_tab_x - x < FRAME_SPACE_WIDTH (it->f))
  	    next_tab_x += tab_width;
  
  	  it->pixel_width = next_tab_x - x;
--- 20980,20993 ----
  	}
        else if (it->char_to_display == '\t')
  	{
! 	  int tab_width = it->tab_width * font_info->space_width;
  	  int x = it->current_x + it->continuation_lines_width;
  	  int next_tab_x = ((1 + x + tab_width - 1) / tab_width) * tab_width;
  
  	  /* If the distance from the current position to the next tab
  	     stop is less than a space character width, use the
  	     tab stop after that.  */
! 	  if (next_tab_x - x < font_info->space_width)
  	    next_tab_x += tab_width;
  
  	  it->pixel_width = next_tab_x - x;
*** src/fringe.c	07 Sep 2008 16:16:36 -0400	1.44.2.5
--- src/fringe.c	23 Dec 2008 10:03:37 -0500	
***************
*** 559,571 ****
--- 559,581 ----
    struct frame *f = XFRAME (WINDOW_FRAME (w));
    struct draw_fringe_bitmap_params p;
    struct fringe_bitmap *fb;
+   struct buffer *old_buffer = NULL;
+ 
    int period;
    int face_id = DEFAULT_FACE_ID;
+   int remapped_face;
  
    p.cursor_p = 0;
    p.overlay_p = (overlay & 1) == 1;
    p.cursor_p = (overlay & 2) == 2;
  
+   /* face selection may depend on the buffer */
+   if (current_buffer && XBUFFER (w->buffer) != current_buffer)
+     {
+       old_buffer = current_buffer;
+       set_buffer_internal_1 (XBUFFER (w->buffer));
+     }
+   
    if (which != NO_FRINGE_BITMAP)
      {
      }
***************
*** 590,595 ****
--- 600,616 ----
  	face_id = FRINGE_FACE_ID;
      }
  
+   /* Perhaps remap BASE_FACE_ID to a user-specified alternative.  */
+   if (face_id == FRINGE_FACE_ID || face_id == DEFAULT_FACE_ID)
+     { remapped_face = lookup_basic_face (XFRAME (w->frame), face_id);
+       if (remapped_face)
+ 	face_id = remapped_face;
+     }
+ 
+   if (old_buffer)
+     set_buffer_internal_1 (old_buffer);
+   
+ 
    fb = fringe_bitmaps[which];
    if (fb == NULL)
      fb = &standard_bitmaps[which < MAX_STANDARD_FRINGE_BITMAPS
***************
*** 885,895 ****
    if (row->visible_height <= 0)
      return;
  
!   if (WINDOW_LEFT_FRINGE_WIDTH (w) != 0)
      draw_fringe_bitmap (w, row, 1);
  
!   if (WINDOW_RIGHT_FRINGE_WIDTH (w) != 0)
!     draw_fringe_bitmap (w, row, 0);
  }
  
  /* Draw the fringes of window W.  Only fringes for rows marked for
--- 910,924 ----
    if (row->visible_height <= 0)
      return;
  
!   /* if (WINDOW_LEFT_FRINGE_WIDTH (w) != 0) */
      draw_fringe_bitmap (w, row, 1);
  
!   /* always draw the fringe, even if it is turned off:
!      this will fill an otherwise empty (background) between
!      window and scrollbar */
!   /*  if (WINDOW_RIGHT_FRINGE_WIDTH (w) != 0) */
! 
!   draw_fringe_bitmap (w, row, 0);
  }
  
  /* Draw the fringes of window W.  Only fringes for rows marked for
***************
*** 1128,1134 ****
        else
  	right = NO_FRINGE_BITMAP;
  
!       if (row->y != cur->y
  	  || row->visible_height != cur->visible_height
  	  || row->ends_at_zv_p != cur->ends_at_zv_p
  	  || left != cur->left_fringe_bitmap
--- 1153,1160 ----
        else
  	right = NO_FRINGE_BITMAP;
  
!       if (windows_or_buffers_changed  /* because face_remapping_alist may remap fringe face */
! 	  || row->y != cur->y
  	  || row->visible_height != cur->visible_height
  	  || row->ends_at_zv_p != cur->ends_at_zv_p
  	  || left != cur->left_fringe_bitmap
*** src/dispnew.c	05 May 2008 18:29:44 -0400	1.392.2.3
--- src/dispnew.c	23 Dec 2008 15:56:08 -0500	
***************
*** 4417,4426 ****
    /* Let functions in xterm.c know what area subsequent X positions
       will be relative to.  */
    updated_area = TEXT_AREA;
- 
    /* If rows are at different X or Y, or rows have different height,
       or the current row is marked invalid, write the entire line.  */
!   if (!current_row->enabled_p
        || desired_row->y != current_row->y
        || desired_row->ascent != current_row->ascent
        || desired_row->phys_ascent != current_row->phys_ascent
--- 4418,4429 ----
    /* Let functions in xterm.c know what area subsequent X positions
       will be relative to.  */
    updated_area = TEXT_AREA;
    /* If rows are at different X or Y, or rows have different height,
       or the current row is marked invalid, write the entire line.  */
!   if (!desired_row->displays_text_p   
! 	    /* window background needs to be drawn using    
! 	     clear_end_of_line, under the visible buffer text.   */
!       ||  !current_row->enabled_p
        || desired_row->y != current_row->y
        || desired_row->ascent != current_row->ascent
        || desired_row->phys_ascent != current_row->phys_ascent
Index: xdisp.c
The following stuff adapts the window background color to match 
the bg color of the default face used in the buffer.
===================================================================
RCS file: /sources/emacs/emacs/src/xdisp.c,v
retrieving revision 1.1149.2.33
diff -c -r1.1149.2.33 xdisp.c
*** src/xdisp.c	26 Aug 2008 11:11:46 -0000	1.1149.2.33
--- src/xdisp.c	22 Dec 2008 00:03:30 -0000
***************
*** 15759,15765 ****
  	  it->len = 1;
  
  	  if (default_face_p)
! 	    it->face_id = DEFAULT_FACE_ID;
  	  else if (it->face_before_selective_p)
  	    it->face_id = it->saved_face_id;
  	  face = FACE_FROM_ID (it->f, it->face_id);
--- 15920,15926 ----
  	  it->len = 1;
  
  	  if (default_face_p)
! 	    it->face_id = lookup_basic_face (it->f, DEFAULT_FACE_ID); 
  	  else if (it->face_before_selective_p)
  	    it->face_id = it->saved_face_id;
  	  face = FACE_FROM_ID (it->f, it->face_id);
Index: macterm.c
===================================================================
RCS file: /sources/emacs/emacs/src/Attic/macterm.c,v
retrieving revision 1.214.2.31
diff -c -r1.214.2.31 macterm.c
*** src/macterm.c	2 Sep 2008 08:19:06 -0000	1.214.2.31
--- src/macterm.c	22 Dec 2008 00:05:21 -0000
***************
*** 469,485 ****
  
  
  static void
! mac_erase_rectangle (f, gc, x, y, width, height)
       struct frame *f;
       GC gc;
       int x, y;
       unsigned int width, height;
  {
  #if USE_CG_DRAWING
    CGContextRef context;
  
    context = mac_begin_cg_clip (f, gc);
!   CG_SET_FILL_COLOR_WITH_GC_BACKGROUND (context, gc);
    CGContextFillRect (context, mac_rect_make (f, x, y, width, height));
    mac_end_cg_clip (f);
  #else
--- 509,550 ----
  
  
  static void
! mac_erase_rectangle_with_color (f, gc, x, y, width, height, color)
       struct frame *f;
       GC gc;
       int x, y;
       unsigned int width, height;
+      unsigned long color;
  {
  #if USE_CG_DRAWING
    CGContextRef context;
+   context = mac_begin_cg_clip (f, gc);
+   CG_SET_FILL_COLOR (context, color); 
+   CGContextFillRect (context, mac_rect_make (f, x, y, width, height));
+   mac_end_cg_clip (f);
+ #else
+   Rect r;
+ 
+   mac_begin_clip (f, gc);
+   RGBBackColor (color);
+   SetRect (&r, x, y, x + width, y + height);
+   EraseRect (&r);
+   RGBBackColor (GC_BACK_COLOR (FRAME_NORMAL_GC (f)));
+   mac_end_clip (f, gc);
+ #endif
+ }
  
+ static void
+ mac_erase_rectangle (f, gc, x, y, width, height)
+      struct frame *f;
+      GC gc;
+      int x, y;
+      unsigned int width, height;
+ {
+ #if USE_CG_DRAWING
+   CGContextRef context;
    context = mac_begin_cg_clip (f, gc);
!   CG_SET_FILL_COLOR_WITH_GC_BACKGROUND (context, gc); 
    CGContextFillRect (context, mac_rect_make (f, x, y, width, height));
    mac_end_cg_clip (f);
  #else
***************
*** 5258,5264 ****
       struct frame *f;
       int x, y, width, height;
  {
!   mac_clear_area (f, x, y, width, height);
  }
  
  
--- 5478,5513 ----
       struct frame *f;
       int x, y, width, height;
  {
!   struct buffer *old_buffer = NULL;
!   struct buffer *b;
!   unsigned long color = FRAME_NORMAL_GC (f)->xgcv.background;
! 
!   struct face *face = NULL; //  FRAME_DEFAULT_FACE (f);
! 
!   //   struct window *w = updated_window;
!   // is the current buffer correct?
!   if (updated_window)
!     {
!       if (current_buffer && XBUFFER (updated_window->buffer) != current_buffer)
! 	{
! 	  old_buffer = current_buffer;
! 	  set_buffer_internal_1 (XBUFFER (updated_window->buffer));
! 	}
!     
!   
!   int remapped_face = lookup_basic_face (f, DEFAULT_FACE_ID);
!   if (remapped_face)
!     face = FACE_FROM_ID (f, remapped_face);
! 
!   if (old_buffer)
!     set_buffer_internal_1 (old_buffer);
!   }
! 
!   if (face) {
!     mac_erase_rectangle_with_color (f, FRAME_NORMAL_GC (f), x, y, width, height, face->background);
!   } else
!     {
!       mac_clear_area (f, x, y, width, height);}
  }
  
  
