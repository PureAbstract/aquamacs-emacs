--- ../emacs.orig/lisp/frame.el	2007-01-22 12:09:12.000000000 +0900
+++ lisp/frame.el	2007-02-18 16:41:32.000000000 +0900
@@ -931,6 +931,16 @@
   (modify-frame-parameters (selected-frame)
 			   (list (cons 'border-color color-name))))
 
+  (defun set-alpha (alpha &optional frame)
+    "Set the opacity of FRAME to ALPHA.  First argument ALPHA 
+should range from 0 (invisible) to 100 (completely opaque).
+When called interactively, prompt for the value of the opacity to set.
+FRAME defaults to the selected frame.  To get the frame's current
+alpha value state, use `frame-parameters'."
+    (interactive "XWindow Opacity (0-100) : ")
+    (modify-frame-parameters frame
+                             (list (cons 'alpha alpha))))
+
 (defun auto-raise-mode (arg)
   "Toggle whether or not the selected frame should auto-raise.
 With arg, turn auto-raise mode on if and only if arg is positive.
--- ../emacs.orig/src/frame.c	2007-02-17 13:09:37.000000000 +0900
+++ src/frame.c	2007-02-18 16:41:32.000000000 +0900
@@ -105,6 +105,7 @@
 Lisp_Object Qleft_fringe, Qright_fringe;
 Lisp_Object Qbuffer_predicate, Qbuffer_list;
 Lisp_Object Qtty_color_mode;
+Lisp_Object Qalpha;
 
 Lisp_Object Qfullscreen, Qfullwidth, Qfullheight, Qfullboth;
 
@@ -2580,6 +2581,7 @@
   {"right-fringe",		&Qright_fringe},
   {"wait-for-wm",		&Qwait_for_wm},
   {"fullscreen",                &Qfullscreen},
+  {"alpha",			 &Qalpha},
 };
 
 #ifdef HAVE_WINDOW_SYSTEM
--- ../emacs.orig/src/frame.h	2007-01-22 12:10:21.000000000 +0900
+++ src/frame.h	2007-02-18 16:41:32.000000000 +0900
@@ -453,6 +453,9 @@
   /* Additional space to put between text lines on this frame.  */
   int extra_line_spacing;
 
+  /* Opacity of the Frame  */
+  int alpha[2];
+
   /* Set to non-zero in change_frame_size when size of frame changed
      Clear the frame in clear_garbaged_frames if set.  */
   unsigned resized_p : 1;
@@ -985,6 +988,14 @@
   (FRAME_PIXEL_Y_TO_LINE (f, ((height) \
 			      - FRAME_INTERNAL_BORDER_WIDTH (f))))
 
+/***********************************************************************
+				Transparency
+ ***********************************************************************/
+
+#define CHECK_ALPHA_RANGE(alpha) if (alpha < 0 || alpha > 100)	\
+    args_out_of_range (make_number (0), make_number (100));
+
+#define NUM_OF_ALPHAS 2
 
 /***********************************************************************
 				Frame Parameters
@@ -1009,6 +1020,7 @@
 extern Lisp_Object Qline_spacing;
 extern Lisp_Object Qwait_for_wm;
 extern Lisp_Object Qfullscreen;
+extern Lisp_Object Qalpha;
 
 extern Lisp_Object Qleft_fringe, Qright_fringe;
 extern Lisp_Object Qheight, Qwidth;
--- ../emacs.orig/src/macfns.c	2007-02-14 13:09:24.000000000 +0900
+++ src/macfns.c	2007-02-18 16:41:32.000000000 +0900
@@ -56,6 +56,7 @@
 /* Carbon version info */
 
 static Lisp_Object Vmac_carbon_version_string;
+static int frame_alpha_lower_limit;
 
 #endif	/* TARGET_API_MAC_CARBON */
 
@@ -223,6 +224,8 @@
 
 
 
+extern void x_set_frame_alpha P_ ((struct frame *));
+
 /* Store the screen positions of frame F into XPTR and YPTR.
    These are the positions of the containing window manager window,
    not Emacs's own window.  */
@@ -1909,6 +1912,79 @@
 #endif /* not MAC_OSX */
 }
 
+/* Change the opacity of frame F to ALPHA.
+   ALPHA must be an integer between 0 and 100.  */
+
+#define CHECK_ALPHA_RANGE(alpha) if (alpha < 0 || alpha > 100)	\
+    args_out_of_range (make_number (0), make_number (100));
+#define NUM_OF_ALPHAS 2
+
+static void
+x_set_alpha (f, arg, oldval)
+     struct frame *f;
+     Lisp_Object arg, oldval;
+{
+  int newalpha[NUM_OF_ALPHAS];
+  int i, tmp;
+  Lisp_Object obj;
+
+  if (NILP (arg)
+      || (CONSP (arg) && NILP (CAR (arg))))
+    tmp = -1;
+  else if (NUMBERP (arg))
+    {
+      tmp = XINT (arg);
+      CHECK_ALPHA_RANGE (tmp);
+    }
+  else if (CONSP (arg) && NUMBERP (CAR (arg)))
+    {
+      tmp = XINT (CAR (arg));
+      CHECK_ALPHA_RANGE (tmp);
+    }
+  else
+    wrong_type_argument (Qnumberp, (arg));
+
+  for (i = 0 ; i < NUM_OF_ALPHAS ; i++)
+    newalpha[i] = tmp;
+
+  if (CONSP (arg))
+    {
+      obj = CDR (arg);
+      for (i = 1 ;
+	   i < NUM_OF_ALPHAS && CONSP (obj) ;
+	   i++, obj = CDR (obj))
+	{
+	  if (NILP (CAR (obj)))
+	    tmp = -1;
+	  else if (NUMBERP (CAR (obj)))
+	    {
+	      tmp = XINT (CAR (obj));
+	      CHECK_ALPHA_RANGE (tmp);
+	    }
+	  else
+	    wrong_type_argument (Qnumberp, (CAR (obj)));
+
+	  newalpha[i] = tmp;
+	}
+    }
+
+  for (i = 0 ; i < NUM_OF_ALPHAS ; i++)
+    {
+      /* Apply lower limit silently */
+      if (newalpha[i] != -1 && newalpha[i] < frame_alpha_lower_limit)
+      newalpha[i] = frame_alpha_lower_limit;
+      f->alpha[i] = newalpha[i];
+    }
+
+#if TARGET_API_MAC_CARBON
+  BLOCK_INPUT;
+  x_set_frame_alpha (f);
+  UNBLOCK_INPUT;
+#endif
+
+  return;
+}
+
 void
 mac_set_scroll_bar_width (f, arg, oldval)
      struct frame *f;
@@ -2778,6 +2854,8 @@
   x_default_parameter (f, parms, Qscroll_bar_width, Qnil,
 		       "scrollBarWidth", "ScrollBarWidth",
 		       RES_TYPE_NUMBER);
+  x_default_parameter (f, parms, Qalpha, Qnil,
+		       "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via change_frame_size.
      Change will not be effected unless different from the current
@@ -4691,6 +4769,7 @@
   x_set_fringe_width,
   0, /* x_set_wait_for_wm, */
   x_set_fullscreen,
+  x_set_alpha,
 };
 
 void
@@ -4821,6 +4900,12 @@
   }
 #endif	/* TARGET_API_MAC_CARBON */
 
+#if TARGET_API_MAC_CARBON
+  DEFVAR_INT ("frame-alpha-lower-limit", &frame_alpha_lower_limit,
+    doc: /* Lower limit of alpha value of frame. */);
+  frame_alpha_lower_limit = 20;
+#endif	/* TARGET_API_MAC_CARBON */
+
   /* X window properties.  */
   defsubr (&Sx_change_window_property);
   defsubr (&Sx_delete_window_property);
--- ../emacs.orig/src/macterm.c	2007-02-14 13:09:24.000000000 +0900
+++ src/macterm.c	2007-02-18 16:41:32.000000000 +0900
@@ -2541,6 +2541,29 @@
   return FONT_TYPE_UNKNOWN;
 }
 
+void
+x_set_frame_alpha (f)
+     struct frame *f;
+{
+  struct mac_display_info *dpyinfo = FRAME_MAC_DISPLAY_INFO (f);
+  SInt32 response;
+  OSErr err;
+  double alpha = 1.0;
+
+  BLOCK_INPUT;
+  err = Gestalt (gestaltSystemVersion, &response);
+  UNBLOCK_INPUT;
+
+  if (dpyinfo->x_highlight_frame == f)
+    alpha = f->alpha[0] / 100.0;
+  else
+    alpha = f->alpha[1] / 100.0;
+  if (alpha < 0.0) alpha = 1.0;
+
+  if ((err == noErr) && (response >= 0x1020)) {
+    SetWindowAlpha (FRAME_MAC_WINDOW(f), alpha );
+  }
+}
 
 
 /***********************************************************************
@@ -4261,6 +4284,7 @@
     ActivateControl (root_control);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 static void
@@ -4276,6 +4300,7 @@
     DeactivateControl (root_control);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 /* The focus has changed.  Update the frames as necessary to reflect
--- ../emacs.orig/src/xfns.c	2007-01-22 12:10:27.000000000 +0900
+++ src/xfns.c	2007-02-18 16:41:32.000000000 +0900
@@ -94,6 +94,8 @@
 #include <Xm/FileSB.h>
 #endif
 
+static int frame_alpha_lower_limit;
+
 /* Do the EDITRES protocol if running X11R5
    Exception: HP-UX (at least version A.09.05) has X11R5 without EditRes */
 
@@ -565,6 +567,8 @@
 							     Lisp_Object,
 							     char *, char *,
 							     int));
+extern void x_set_frame_alpha P_ ((struct frame *));
+
 
 
 /* Store the screen positions of frame F into XPTR and YPTR.
@@ -1801,6 +1805,73 @@
 #endif
 }
 
+/* Change the opacity of frame F to ALPHA.
+   ALPHA must be an integer between 0 and 100.  */
+
+static void
+x_set_alpha (f, arg, oldval)
+     struct frame *f;
+     Lisp_Object arg, oldval;
+{
+  int newalpha[NUM_OF_ALPHAS];
+  int i, tmp;
+  Lisp_Object obj;
+
+  if (NILP (arg)
+      || (CONSP (arg) && NILP (CAR (arg))))
+    tmp = -1;
+  else if (NUMBERP (arg))
+    {
+      tmp = XINT (arg);
+      CHECK_ALPHA_RANGE (tmp);
+    }
+  else if (CONSP (arg) && NUMBERP (CAR (arg)))
+    {
+      tmp = XINT (CAR (arg));
+      CHECK_ALPHA_RANGE (tmp);
+    }
+  else
+    wrong_type_argument (Qnumberp, (arg));
+
+  for (i = 0 ; i < NUM_OF_ALPHAS ; i++)
+    newalpha[i] = tmp;
+
+  if (CONSP (arg))
+    {
+      obj = CDR (arg);
+      for (i = 1 ;
+	   i < NUM_OF_ALPHAS && CONSP (obj) ;
+	   i++, obj = CDR (obj))
+	{
+	  if (NILP (CAR (obj)))
+	    tmp = -1;
+	  else if (NUMBERP (CAR (obj)))
+	    {
+	      tmp = XINT (CAR (obj));
+	      CHECK_ALPHA_RANGE (tmp);
+	    }
+	  else
+	    wrong_type_argument (Qnumberp, (CAR (obj)));
+
+	  newalpha[i] = tmp;
+	}
+    }
+
+  for (i = 0 ; i < NUM_OF_ALPHAS ; i++)
+    {
+      /* Apply lower limit silently */
+      if (newalpha[i] != -1 && newalpha[i] < frame_alpha_lower_limit)
+      newalpha[i] = frame_alpha_lower_limit;
+      f->alpha[i] = newalpha[i];
+    }
+
+  BLOCK_INPUT;
+  x_set_frame_alpha (f);
+  UNBLOCK_INPUT;
+
+  return;
+}
+
 
 /* Record in frame F the specified or default value according to ALIST
    of the parameter named PROP (a Lisp symbol).  If no value is
@@ -3356,6 +3427,8 @@
   x_default_parameter (f, parms, Qscroll_bar_width, Qnil,
 		       "scrollBarWidth", "ScrollBarWidth",
 		       RES_TYPE_NUMBER);
+  x_default_parameter (f, parms, Qalpha, Qnil,
+		       "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via change_frame_size.
      Change will not be effected unless different from the current
@@ -5737,6 +5810,7 @@
   x_set_fringe_width,
   x_set_wait_for_wm,
   x_set_fullscreen,
+  x_set_alpha,
 };
 
 void
@@ -5905,6 +5979,10 @@
   }
 #endif /* USE_GTK */
 
+  DEFVAR_INT ("frame-alpha-lower-limit", &frame_alpha_lower_limit,
+    doc: /* Lower limit of alpha value of frame. */);
+  frame_alpha_lower_limit = 20;
+
   /* X window properties.  */
   defsubr (&Sx_change_window_property);
   defsubr (&Sx_delete_window_property);
--- ../emacs.orig/src/xterm.c	2007-02-15 13:10:24.000000000 +0900
+++ src/xterm.c	2007-02-18 16:41:32.000000000 +0900
@@ -951,6 +951,58 @@
   return FONT_TYPE_UNKNOWN;
 }
 
+#define OPAQUE  0xffffffff
+#define OPACITY "_NET_WM_WINDOW_OPACITY"
+
+void
+x_set_frame_alpha (f)
+     struct frame *f;
+{
+  struct x_display_info *dpyinfo = FRAME_X_DISPLAY_INFO (f);
+  Display *dpy = FRAME_X_DISPLAY (f);
+  Window win = FRAME_OUTER_WINDOW (f);
+  if (FRAME_X_DISPLAY_INFO (f)->root_window != FRAME_X_OUTPUT (f)->parent_desc)
+    /* Since the WM decoration lies under the FRAME_OUTER_WINDOW,
+       we must treat the former instead of the latter. */
+    win = FRAME_X_OUTPUT(f)->parent_desc;
+
+  unsigned int opac = (unsigned int)(alpha * OPAQUE);
+  double alpha = 1.0;
+
+  if (dpyinfo->x_highlight_frame == f)
+    alpha = f->alpha[0] / 100.0;
+  else
+    alpha = f->alpha[1] / 100.0;
+  if (alpha < 0.0) alpha = 1.0;
+
+  /* Courtesy of Nakayama-san [Macemacsjp-users 1211] */
+  {
+    unsigned char *data;
+    Atom actual;
+    int format;
+    unsigned long n, left;
+
+    XGetWindowProperty(dpy, win, XInternAtom(dpy, OPACITY, False),
+		       0L, 1L, False, XA_CARDINAL, &actual, &format, &n, &left,
+		       (unsigned char **) &data);
+    if (data != None)
+      if (*(unsigned int *)data == opac)
+	{
+	  XFree ((void *) data);
+	  return;
+	}
+      else
+       {
+	  XFree ((void *) data);
+       }
+  }
+  /****/
+
+  XChangeProperty (dpy, win, XInternAtom (dpy, OPACITY, False),
+		   XA_CARDINAL, 32, PropModeReplace,
+		   (unsigned char *) &opac, 1L);
+  XSync (dpy, False);
+}
 
 
 /***********************************************************************
@@ -3152,6 +3204,7 @@
 		    f->output_data.x->border_pixel);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 static void
@@ -3167,6 +3220,7 @@
 			  f->output_data.x->border_tile);
   UNBLOCK_INPUT;
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 /* The focus has changed.  Update the frames as necessary to reflect
--- ../emacs.orig/src/w32fns.c	2007-01-22 12:10:26.000000000 +0900
+++ src/w32fns.c	2007-02-18 16:41:32.000000000 +0900
@@ -56,6 +56,8 @@
 #include <dlgs.h>
 #define FILE_NAME_TEXT_FIELD edt1
 
+static int frame_alpha_lower_limit;
+
 void syms_of_w32fns ();
 void globals_of_w32fns ();
 
@@ -70,6 +72,8 @@
 
 extern char *lispy_function_keys[];
 
+extern void x_set_frame_alpha P_ ((struct frame *));
+
 /* The gray bitmap `bitmaps/gray'.  This is done because w32term.c uses
    it, and including `bitmaps/gray' more than once is a problem when
    config.h defines `static' as an empty replacement string.  */
@@ -262,6 +266,7 @@
 TrackMouseEvent_Proc track_mouse_event_fn = NULL;
 ClipboardSequence_Proc clipboard_sequence_fn = NULL;
 extern AppendMenuW_Proc unicode_append_menu;
+extern SetLayeredWindowAttributes_Proc set_layered_window_attributes_fn;
 
 /* W95 mousewheel handler */
 unsigned int msh_mousewheel = 0;
@@ -1978,6 +1983,72 @@
 				      wid - 1) / wid;
 }
 
+/* Change the opacity of frame F to ALPHA.
+   ALPHA must be an integer between 0 and 100.  */
+
+static void
+x_set_alpha (f, arg, oldval)
+     struct frame *f;
+     Lisp_Object arg, oldval;
+{
+  int newalpha[NUM_OF_ALPHAS];
+  int i, tmp;
+  Lisp_Object obj;
+
+  if (NILP (arg)
+      || (CONSP (arg) && NILP (CAR (arg))))
+    tmp = -1;
+  else if (NUMBERP (arg))
+    {
+      tmp = XINT (arg);
+      CHECK_ALPHA_RANGE (tmp);
+    }
+  else if (CONSP (arg) && NUMBERP (CAR (arg)))
+    {
+      tmp = XINT (CAR (arg));
+      CHECK_ALPHA_RANGE (tmp);
+    }
+  else
+    wrong_type_argument (Qnumberp, (arg));
+
+  for (i = 0 ; i < NUM_OF_ALPHAS ; i++)
+    newalpha[i] = tmp;
+
+  if (CONSP (arg))
+    {
+      obj = CDR (arg);
+      for (i = 1 ;
+	   i < NUM_OF_ALPHAS && CONSP (obj) ;
+	   i++, obj = CDR (obj))
+	{
+	  if (NILP (CAR (obj)))
+	    tmp = -1;
+	  else if (NUMBERP (CAR (obj)))
+	    {
+	      tmp = XINT (CAR (obj));
+	      CHECK_ALPHA_RANGE (tmp);
+	    }
+	  else
+	    wrong_type_argument (Qnumberp, (CAR (obj)));
+
+	  newalpha[i] = tmp;
+	}
+    }
+
+  for (i = 0 ; i < NUM_OF_ALPHAS ; i++)
+    {
+      /* Apply lower limit silently */
+      if (newalpha[i] != -1 && newalpha[i] < frame_alpha_lower_limit)
+      newalpha[i] = frame_alpha_lower_limit;
+      f->alpha[i] = newalpha[i];
+    }
+
+  BLOCK_INPUT;
+  x_set_frame_alpha (f);
+  UNBLOCK_INPUT;
+
+  return;
+}
 
 /* Subroutines of creating a frame.  */
 
@@ -4380,6 +4451,8 @@
 		       "cursorType", "CursorType", RES_TYPE_SYMBOL);
   x_default_parameter (f, parameters, Qscroll_bar_width, Qnil,
 		       "scrollBarWidth", "ScrollBarWidth", RES_TYPE_NUMBER);
+  x_default_parameter (f, parameters, Qalpha, Qnil,
+		       "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via change_frame_size.
      Change will not be effected unless different from the current
@@ -8579,6 +8652,7 @@
   x_set_fringe_width,
   0, /* x_set_wait_for_wm, */
   x_set_fullscreen,
+  x_set_alpha,
 };
 
 void
@@ -8942,6 +9016,10 @@
   }
 #endif
 
+  DEFVAR_INT ("frame-alpha-lower-limit", &frame_alpha_lower_limit,
+    doc: /* Lower limit of alpha value of frame. */);
+  frame_alpha_lower_limit = 20;
+
 #if 0 /* TODO: Port to W32 */
   defsubr (&Sx_change_window_property);
   defsubr (&Sx_delete_window_property);
@@ -9041,6 +9119,9 @@
   /* ditto for GetClipboardSequenceNumber.  */
   clipboard_sequence_fn = (ClipboardSequence_Proc)
     GetProcAddress (user32_lib, "GetClipboardSequenceNumber");
+  /* ditto for SetLayeredWindowAttributes.  */
+  set_layered_window_attributes_fn = (SetLayeredWindowAttributes_Proc)
+    GetProcAddress (user32_lib, "SetLayeredWindowAttributes");
 
   DEFVAR_INT ("w32-ansi-code-page",
 	      &w32_ansi_code_page,
--- ../emacs.orig/src/w32term.c	2007-01-22 12:10:26.000000000 +0900
+++ src/w32term.c	2007-02-18 16:41:32.000000000 +0900
@@ -259,6 +259,8 @@
 
 static Lisp_Object Qvendor_specific_keysyms;
 
+SetLayeredWindowAttributes_Proc set_layered_window_attributes_fn = NULL;
+
 
 /***********************************************************************
 			      Debugging
@@ -1190,6 +1192,30 @@
     return ANSI_FONT;
 }
 
+void
+x_set_frame_alpha (f)
+     struct frame *f;
+{
+  struct w32_display_info *dpyinfo = FRAME_W32_DISPLAY_INFO (f);
+  Window window = FRAME_W32_WINDOW (f);
+
+  double alpha = 1.0;
+
+  if (dpyinfo->x_highlight_frame == f)
+    alpha = f->alpha[0] / 100.0;
+  else
+    alpha = f->alpha[1] / 100.0;
+  if (alpha < 0.0) alpha = 1.0;
+
+  if (set_layered_window_attributes_fn != NULL) {
+    SetWindowLong (window, GWL_EXSTYLE,
+                   GetWindowLong (window, GWL_EXSTYLE)|WS_EX_LAYERED);
+    set_layered_window_attributes_fn (FRAME_W32_WINDOW (f),
+                                      RGB(255, 255, 255),
+                                      (int)(alpha * 255.0),
+                                      LWA_ALPHA);
+  }
+}
 
 
 /***********************************************************************
@@ -2819,6 +2845,7 @@
      struct frame *f;
 {
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 static void
@@ -2826,6 +2853,7 @@
      struct frame *f;
 {
   x_update_cursor (f, 1);
+  x_set_frame_alpha (f);
 }
 
 /* The focus has changed.  Update the frames as necessary to reflect
--- ../emacs.orig/src/w32term.h	2007-01-22 12:10:26.000000000 +0900
+++ src/w32term.h	2007-02-18 16:41:32.000000000 +0900
@@ -641,6 +641,14 @@
 
 #define WND_EXTRA_BYTES     (WND_LAST_INDEX)
 
+/* for transparency functions */
+#ifndef LWA_ALPHA
+#define LWA_ALPHA 2
+#endif
+#ifndef WS_EX_LAYERED
+#define WS_EX_LAYERED 0x80000   /* w2k */
+#endif
+
 extern DWORD dwWindowsThreadId;
 extern HANDLE hWindowsThread;
 extern DWORD dwMainThreadId;
@@ -753,6 +761,8 @@
       ? BDF_1D_FONT : BDF_2D_FONT))
 
 typedef DWORD (WINAPI * ClipboardSequence_Proc) ();
+typedef DWORD (WINAPI * SetLayeredWindowAttributes_Proc)
+  (HWND, DWORD, BYTE, DWORD);
 typedef BOOL (WINAPI * AppendMenuW_Proc) (
     IN HMENU,
     IN UINT,
