Index: macfns.c
===================================================================
RCS file: /cvsroot/emacs/emacs/src/macfns.c,v
retrieving revision 1.63
diff -c -r1.63 macfns.c
*** macfns.c	4 Jul 2005 16:06:33 -0000	1.63
--- macfns.c	10 Jul 2005 11:52:18 -0000
***************
*** 4406,4411 ****
--- 4406,4656 ----
  {
  }
  #endif
+  
+ 
+ #ifdef MAC_OSX
+ 
+ 
+ /* The code for FSBumpDate and FSChangeCreatorType is taken from 
+    MoreFilesX.c (Apple Sample Code), authored by Jim Luther / Apple 
+    and released for free use. The code has been modified.
+ 
+    To do: test on MacOS.
+ */
+ 
+ OSErr
+ FSBumpDate(
+ 	const FSRef *ref)
+ {
+ 	OSStatus		result;
+ 	FSCatalogInfo	        catalogInfo;
+ 	UTCDateTime		oldDateTime;
+ #ifdef MAC_OSX
+ 	FSRef			parentRef;
+ 	Boolean			notifyParent;
+ #endif
+ 
+ #ifdef MAC_OSX
+ 	/* Get the node flags, the content modification date and time, and the parent ref */
+ 	result = FSGetCatalogInfo(ref, kFSCatInfoNodeFlags + kFSCatInfoContentMod, &catalogInfo, NULL, NULL, &parentRef);
+ 	require_noerr(result, FSGetCatalogInfo);
+ 	
+ 	/* Notify the parent if this is a file */
+ 	notifyParent = (0 == (catalogInfo.nodeFlags & kFSNodeIsDirectoryMask));
+ #else
+ 	/* Get the content modification date and time */
+ 	result = FSGetCatalogInfo(ref, kFSCatInfoContentMod, &catalogInfo, NULL, NULL, NULL);
+ 	require_noerr(result, FSGetCatalogInfo);
+ #endif
+ 	
+ 	oldDateTime = catalogInfo.contentModDate;
+ 
+ 	/* Get the current date and time */
+ 	result = GetUTCDateTime(&catalogInfo.contentModDate, kUTCDefaultOptions);
+ 	require_noerr(result, GetUTCDateTime);
+ 	
+ 	/* if the old date and time is the the same as the current, bump the seconds by one */
+ 	if ( (catalogInfo.contentModDate.fraction == oldDateTime.fraction) &&
+ 		 (catalogInfo.contentModDate.lowSeconds == oldDateTime.lowSeconds) &&
+ 		 (catalogInfo.contentModDate.highSeconds == oldDateTime.highSeconds) )
+ 	{
+ 		++catalogInfo.contentModDate.lowSeconds;
+ 		if ( 0 == catalogInfo.contentModDate.lowSeconds )
+ 		{
+ 			++catalogInfo.contentModDate.highSeconds;
+ 		}
+ 	}
+ 	
+ 	/* Bump the content modification date and time */
+ 	result = FSSetCatalogInfo(ref, kFSCatInfoContentMod, &catalogInfo);
+ 	require_noerr(result, FSSetCatalogInfo);
+ 
+ #if MAC_OSX
+ 	/*
+ 	 * The problem with FNNotify is that it is not available under Mac OS 9
+ 	 * and there's no way to test for that except for looking for the symbol
+ 	 * or something. So, I'll just conditionalize this for those who care
+ 	 * to send a notification.
+ 	 */
+ 	
+ 	/* Send a notification for the parent of the file, or for the directory */
+ 	result = FNNotify(notifyParent ? &parentRef : ref, kFNDirectoryModifiedMessage, kNilOptions);
+ 	require_noerr(result, FNNotify);
+ #endif
+ 
+ 	/* ignore errors from FSSetCatalogInfo (volume might be write protected) and FNNotify */
+ FNNotify:
+ FSSetCatalogInfo:
+ 	
+ 	return ( noErr );
+ 	
+ 	/**********************/
+ 	
+ GetUTCDateTime:
+ FSGetCatalogInfo:
+ 
+ 	return ( result );
+ }
+ 
+ 
+ OSErr
+ FSChangeCreatorType(
+ 	const FSRef *ref,
+ 	OSType fileCreator,
+ 	OSType fileType)
+ {
+ 	OSErr			result;
+ 	FSCatalogInfo    	catalogInfo;
+ 	FSRef			parentRef;
+ 	
+ 	/* get nodeFlags, finder info, and parent FSRef */
+ 	result = FSGetCatalogInfo(ref, kFSCatInfoNodeFlags + 
+ 				  kFSCatInfoFinderInfo, &catalogInfo , 
+ 				  NULL, NULL, &parentRef);
+ 	require_noerr(result, FSGetCatalogInfo);
+ 	
+ 	/* make sure FSRef was to a file */
+ 	require_action(0 == (catalogInfo.nodeFlags & kFSNodeIsDirectoryMask),
+ 		       FSRefNotFile, result = notAFileErr);
+ 	
+ 	
+ 	/* If creator not 0x00000000, change creator */
+ 	if (fileCreator && fileCreator != (OSType)0x00000000 )
+ 	{
+ 	  ((FileInfo *)&catalogInfo.finderInfo)->fileCreator = fileCreator;
+ 	}
+ 	/* If type not 0x00000000, change type */
+ 	if (fileType && fileType != (OSType)0x00000000 )
+ 	{
+ 	  ((FileInfo *)&catalogInfo.finderInfo)->fileType = fileType;
+ 	}
+ 	
+ 	/* now, save the new information back to disk */
+ 	result = FSSetCatalogInfo(ref, kFSCatInfoFinderInfo, &catalogInfo);
+ 	require_noerr(result, FSSetCatalogInfo);
+ 	
+ 	/* and attempt to bump the parent directory's mod date to wake up */
+ 	/* the Finder to the change we just made (ignore errors from this) */
+ 	verify_noerr(FSBumpDate(&parentRef));
+ 	
+ FSSetCatalogInfo:
+ FSRefNotFile:
+ FSGetCatalogInfo:
+ 
+ 	return ( result );
+ }
+ 
+ 
+ DEFUN ("mac-set-file-creator", Fmac_set_file_creator, Smac_set_file_creator, 1, 2, 0,
+        doc: /* Set creator code of file FILENAME to CODE.
+ If non-nil, CODE must be a 4-character string. Otherwise,
+ 'EMAx' is assumed. Return non-nil if successful.
+    */)
+   (filename, code)
+      Lisp_Object filename;
+      Lisp_Object code;
+ {
+ 
+ 
+ 
+ 
+   CHECK_STRING (filename);
+   OSErr	status;
+   FSRef defLoc;
+   OSType cCode;
+ 
+   if (NILP(code))
+     {
+       cCode = 'EMAx';
+     } 
+   else
+     {
+       /* check type string */
+       CHECK_STRING(code);
+       if (strlen(SDATA(code)) != 4)
+ 	{
+ 	  error ("Wrong argument: need string of length 4 for CODE");
+ 	}
+       cCode = (OSType) *((int *) SDATA(code));
+     }
+   BLOCK_INPUT;
+   filename = Fexpand_file_name (filename, Qnil);
+   status = FSPathMakeRef(SDATA(ENCODE_FILE(filename)), &defLoc, NULL);
+   
+ 
+   if (status == noErr)
+     {
+       status = FSChangeCreatorType(&defLoc, cCode, (OSType) 0);
+       UNBLOCK_INPUT;
+ 
+ 	if (status == noErr)
+ 	  {
+ 	    return Qt;
+ 	  }
+ 	else
+ 	  error ("Error while setting creator information.");
+     }	
+   else
+     {
+       UNBLOCK_INPUT;
+       error ("Error while accessing file.");
+     }
+ }
+  
+ 
+ DEFUN ("mac-set-file-type", Fmac_set_file_type, Smac_set_file_type, 2, 2, 0,
+        doc: /* Set type of file FILENAME to TYPE.
+ TYPE must be a 4-character string. 
+ Return non-nil if successful.
+    */)
+   (filename,type)
+      Lisp_Object filename;
+      Lisp_Object type;
+ {
+   OSErr	status;
+   FSRef defLoc;
+ 
+   CHECK_STRING (filename);
+ 
+   /* check type string */
+   CHECK_STRING(type);
+   if (strlen(SDATA(type)) != 4)
+     {
+       error ("Wrong argument: need string of length 4 for CODE");
+     }
+ 
+   BLOCK_INPUT;
+   filename = Fexpand_file_name (filename, Qnil);
+   status = FSPathMakeRef(SDATA(ENCODE_FILE(filename)), &defLoc, NULL);
+ 
+   if (status == noErr)
+     {
+       /* warning: the string-to-OSType conversion here might not be safe
+ 	 when using Intel type endians... */
+ 
+       status = FSChangeCreatorType(&defLoc, 
+ 				   (OSType) 0, 
+ 				   (OSType) *((int *) SDATA(type)));
+       UNBLOCK_INPUT;
+       if (status == noErr)
+ 	{
+ 	  return Qt;
+ 	}
+       else
+ 	error ("Error while setting creator information.");
+     }	
+   else
+     {
+       UNBLOCK_INPUT;
+       error ("Error while accessing file.");
+     }
+ }
+  
+ 
+ #endif
+ 
+ 
+ 
  
  /***********************************************************************
  			    Initialization
***************
*** 4616,4621 ****
--- 4861,4870 ----
  
  #if TARGET_API_MAC_CARBON
    defsubr (&Sx_file_dialog);
+ #endif
+ #if MAC_OSX
+   defsubr (&Smac_set_file_creator);
+   defsubr (&Smac_set_file_type);
  #endif
  }
  
