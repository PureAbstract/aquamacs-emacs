This code is written by J. Stanley, V. Ljosa, and D. Reitter.
It provides the full-screen functionality (the frame parameter 'fullscreen)
for the Carbon port of GNU Emacs 22.2.50.
diff -Naur -x '*.orig' -x '*.elc' -x emacs -x info ../emacs.orig/src/macterm.c ./src/macterm.c
first part of patch fixes bugs in original patch, particularly:
mac_fullscreen_hook: only add menu bar if on main screen
x_set_offset: do not allow x_calc_absolute_position to screw up the coordinates and 
  move the window off a secondary display (with negative coords) 
Index: src/macterm.c
===================================================================
RCS file: /sources/emacs/emacs/src/Attic/macterm.c,v
retrieving revision 1.214.2.31
diff -c -r1.214.2.31 macterm.c
*** src/macterm.c	2 Sep 2008 08:19:06 -0000	1.214.2.31
--- src/macterm.c	27 Dec 2008 23:32:38 -0000
***************
*** 83,88 ****
--- 83,90 ----
  
  
  
+ int mac_autohide_menubar_on_fullscreen;
+ 
  /* Non-nil means Emacs uses toolkit scroll bars.  */
  
  Lisp_Object Vx_toolkit_scroll_bars;
***************
*** 237,242 ****
--- 239,245 ----
  static void x_update_window_begin P_ ((struct window *));
  static void x_after_update_window_line P_ ((struct glyph_row *));
  
+ static CGDirectDisplayID mac_display_id P_ ((WindowRef));
  static XCharStruct *mac_per_char_metric P_ ((XFontStruct *, XChar2b *, int));
  static void XSetFont P_ ((Display *, GC, XFontStruct *));
  
***************
*** 4300,4305 ****
--- 4303,4321 ----
      }
  
    x_frame_rehighlight (dpyinfo);
+ 
+   if (frame)
+     {
+       CGDirectDisplayID display = mac_display_id (FRAME_MAC_WINDOW(frame));
+       CGDirectDisplayID main_display = CGMainDisplayID ();
+       if (display == main_display)
+         {
+           if (frame->want_fullscreen == FULLSCREEN_BOTH)
+             SetSystemUIMode(kUIModeAllHidden, kUIOptionAutoShowMenuBar);
+           else
+             SetSystemUIMode(kUIModeNormal, 0);
+         }
+     }
  }
  
  /* Handle FocusIn and FocusOut state changes for FRAME.
***************
*** 5593,5598 ****
--- 5609,5621 ----
       register int xoff, yoff;
       int change_gravity;
  {
+   int xoff_preserve, yoff_preserve;
+   /* Refuse to change one or both offsets if in full-screen mode. */
+   if (f->want_fullscreen & FULLSCREEN_HEIGHT)
+     yoff_preserve = f->top_pos;
+   if (f->want_fullscreen & FULLSCREEN_WIDTH)
+     xoff_preserve = f->left_pos;
+ 
    if (change_gravity > 0)
      {
        f->top_pos = yoff;
***************
*** 5606,5623 ****
--- 5629,5655 ----
      }
    x_calc_absolute_position (f);
  
+   /* workaround */
+   if (f->want_fullscreen & FULLSCREEN_HEIGHT)
+     f->top_pos = yoff_preserve;
+   if (f->want_fullscreen & FULLSCREEN_WIDTH)
+     f->left_pos = xoff_preserve;
+ 
    BLOCK_INPUT;
    x_wm_set_size_hint (f, (long) 0, 0);
  
  #if TARGET_API_MAC_CARBON
+ 
    mac_move_window_structure (FRAME_MAC_WINDOW (f), f->left_pos, f->top_pos);
    /* If the title bar is completely outside the screen, adjust the
       position. */
+ #if !USE_APPKIT
    ConstrainWindowToScreen (FRAME_MAC_WINDOW (f), kWindowTitleBarRgn,
  			   kWindowConstrainMoveRegardlessOfFit
  			   | kWindowConstrainAllowPartial, NULL, NULL);
    if (!NILP (tip_frame) && XFRAME (tip_frame) == f)
      mac_handle_origin_change (f);
+ #endif	/* !USE_APPKIT */
  #else
    {
      Rect inner, outer, screen_rect, dummy;
***************
*** 5626,5631 ****
--- 5658,5664 ----
      mac_get_window_bounds (f, &inner, &outer);
      f->x_pixels_diff = inner.left - outer.left;
      f->y_pixels_diff = inner.top - outer.top;
+ 
      MoveWindow (FRAME_MAC_WINDOW (f), f->left_pos + f->x_pixels_diff,
  		f->top_pos + f->y_pixels_diff, false);
  
***************
*** 5653,5659 ****
  	  f->top_pos = screen_rect.top;
  	else if (inner.top >= screen_rect.bottom)
  	  f->top_pos = screen_rect.bottom - (outer.bottom - outer.top);
- 
  	MoveWindow (FRAME_MAC_WINDOW (f), f->left_pos + f->x_pixels_diff,
  		    f->top_pos + f->y_pixels_diff, false);
        }
--- 5686,5691 ----
***************
*** 5679,5684 ****
--- 5711,5717 ----
    BLOCK_INPUT;
  
    check_frame_size (f, &rows, &cols);
+ 
    f->scroll_bar_actual_width
      = FRAME_SCROLL_BAR_COLS (f) * FRAME_COLUMN_WIDTH (f);
  
***************
*** 5690,5695 ****
--- 5723,5739 ----
    f->win_gravity = NorthWestGravity;
    x_wm_set_size_hint (f, (long) 0, 0);
  
+   /* Refuse to change height, width, or both if in full-screen mode. */
+   Rect b;
+   OSStatus st = GetWindowBounds(FRAME_MAC_WINDOW (f), kWindowContentRgn, &b);
+   if (st == noErr)
+     {
+       if (f->want_fullscreen & FULLSCREEN_HEIGHT)
+         pixelheight = b.bottom - b.top;
+       if (f->want_fullscreen & FULLSCREEN_WIDTH)
+         pixelwidth = b.right - b.left;
+     }
+ 
    mac_size_window (FRAME_MAC_WINDOW (f), pixelwidth, pixelheight, 0);
  
  #if TARGET_API_MAC_CARBON
***************
*** 8186,8191 ****
--- 8230,8237 ----
  /* Contains the string "reverse", which is a constant for mouse button emu.*/
  Lisp_Object Qreverse;
  
+ Lisp_Object Qfullscreen_saved_state;
+ 
  
  /* Modifier associated with the control key, or nil to ignore. */
  Lisp_Object Vmac_control_modifier;
***************
*** 9434,9439 ****
--- 9480,9700 ----
        bzero (dpyinfo, sizeof (*dpyinfo));
      }
  }
+ 
+ /* Full-screen mode */
+ 
+ static CGDirectDisplayID mac_display_id (wnd)
+      WindowRef wnd;
+ {
+   OSStatus s;
+   CGDirectDisplayID display_id;
+     
+ #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
+   s = HIWindowGetGreatestAreaDisplay (wnd, kWindowContentRgn,
+                                       kHICoordSpaceScreenPixel, &display_id, 
+                                       NULL);
+   if (s != noErr)
+     return NULL;
+ #else
+   GDHandle devh;
+   DisplayIDType id;
+ 
+   s = GetWindowGreatestAreaDevice (wnd, kWindowContentRgn, &devh, NULL);
+   if (s != noErr)
+     return NULL;
+   OSErr e = DMGetDisplayIDByGDevice (devh, &id, true);
+   if (e != noErr)
+     return NULL;
+   display_id = (CGDirectDisplayID)id;
+ #endif
+   return display_id;
+ }
+ 
+ #define FNS_kWindowNoTitleBarAttribute 512
+ 
+ extern Lisp_Object Qfullwidth, Qfullheight, Qfullboth;
+ 
+ struct fullscreen_state {
+   int mode, top, bottom, left, right;
+ };
+ 
+ static int fullscreen_mode_as_int (symbol)
+      Lisp_Object symbol;
+ {
+   CHECK_SYMBOL (symbol);
+   if (EQ (symbol, Qfullwidth))
+     return FULLSCREEN_WIDTH;
+   if (EQ (symbol, Qfullheight))
+     return FULLSCREEN_HEIGHT;
+   if (EQ (symbol, Qfullboth))
+     return FULLSCREEN_BOTH;
+   return FULLSCREEN_NONE;
+ }
+ 
+ static Lisp_Object fullscreen_mode_as_symbol (i)
+      int i;
+ {
+   Lisp_Object mode = Qnil;
+   switch (i) {
+   case FULLSCREEN_WIDTH: mode = Qfullwidth; break;
+   case FULLSCREEN_HEIGHT: mode = Qfullheight; break;
+   case FULLSCREEN_BOTH: mode = Qfullboth; break;
+   }
+   return mode;
+ }
+ 
+ static struct fullscreen_state *
+ get_fullscreen_state (f)
+      FRAME_PTR f;
+ {
+   struct fullscreen_state *s = xmalloc (sizeof (struct fullscreen_state));
+   s->mode = FULLSCREEN_NONE;
+   s->top = s->left = s->bottom = s->right = INT_MAX;
+   Lisp_Object frame;
+   XSETFRAME (frame, f);
+   Lisp_Object list = Fframe_parameter (frame, Qfullscreen_saved_state);
+   if (Qnil != list)
+     {
+       CHECK_CONS (list);
+       s->mode = fullscreen_mode_as_int (Fcar (list)); 
+       list = Fcdr (list);
+ #define POP_NUMBER_OR_NIL(dest, list) do { CHECK_CONS (list); if (Qnil == Fcar (list)) dest = INT_MAX; else { CHECK_NUMBER (Fcar (list)); dest = XINT (Fcar (list)); } list = Fcdr (list); } while (0)
+       POP_NUMBER_OR_NIL (s->top, list);
+       POP_NUMBER_OR_NIL (s->left, list);
+       POP_NUMBER_OR_NIL (s->bottom, list);
+       POP_NUMBER_OR_NIL (s->right, list);
+ #undef POP_NUMBER
+     }
+   return s;
+ }
+ 
+ static void
+ save_fullscreen_state (f, s)
+      FRAME_PTR f;
+      const struct fullscreen_state *s;
+ {
+   if (s->mode == FULLSCREEN_NONE)
+     store_frame_param (f, Qfullscreen_saved_state, Qnil);
+   else
+ #define NUM(n) n == INT_MAX ? Qnil : make_number (n)
+       store_frame_param (f, Qfullscreen_saved_state, 
+                          list5 (fullscreen_mode_as_symbol (s->mode), 
+                                 NUM (s->top), NUM (s->left), NUM (s->bottom),
+                                 NUM (s->right)));
+ #undef NUM
+ }
+ 
+ static pascal void mac_handle_display_reconfiguration (dispID, flags, userInfo)
+      CGDirectDisplayID dispID;
+      CGDisplayChangeSummaryFlags flags;
+      void* userInfo;
+ {
+   /* Leave full-screen mode when the display is reconfigured (e.g., a
+      display is added or removed, or the resolution is changed)
+      because it is not obvious whether resizing the window is always
+      the right thing to do. */
+   Lisp_Object frame;
+   XSETFRAME (frame, (FRAME_PTR)userInfo);
+   Fmodify_frame_parameters (frame, list1 (Fcons (Qfullscreen, Qnil)));
+ }
+ 
+ static void
+ mac_fullscreen_hook (f)
+      FRAME_PTR f;
+ {
+   Rect b;
+   OSStatus st;
+      
+   if (f->async_visible)
+     {
+       /* May signal errors, so do before blocking input. */
+       struct fullscreen_state *s = get_fullscreen_state (f);
+ 
+       BLOCK_INPUT;
+ 
+       /* Must get the current bounds _before_ removing the title bar,
+          otherwise the window will be too short when restored. */
+       st = GetWindowBounds (FRAME_MAC_WINDOW (f), kWindowStructureRgn, &b);
+       if (st != noErr)
+         {
+           UNBLOCK_INPUT;
+           error ("Failed to get current window bounds.");
+         }
+ 
+       CGDirectDisplayID display = mac_display_id (FRAME_MAC_WINDOW(f));
+       if (!display)
+         {
+           UNBLOCK_INPUT;
+           error ("Failed to get display ID.");
+         }
+       CGDirectDisplayID main_display = CGMainDisplayID ();
+       if ((f->want_fullscreen & FULLSCREEN_BOTH) == FULLSCREEN_BOTH)
+         {
+           ChangeWindowAttributes (FRAME_MAC_WINDOW (f), 
+                                   FNS_kWindowNoTitleBarAttribute,
+                                   kWindowResizableAttribute);
+           if (mac_autohide_menubar_on_fullscreen && display == main_display)
+             SetSystemUIMode (kUIModeAllHidden, kUIOptionAutoShowMenuBar);
+         }
+       else
+         {
+           ChangeWindowAttributes (FRAME_MAC_WINDOW (f), 
+                                   kWindowResizableAttribute, 
+                                   FNS_kWindowNoTitleBarAttribute);
+           if (f->want_fullscreen & FULLSCREEN_BOTH)
+             ChangeWindowAttributes (FRAME_MAC_WINDOW (f),
+                                     0, kWindowResizableAttribute);
+           SetSystemUIMode (kUIModeNormal, 0);
+         }
+ 
+       /* Update the saved state. */
+       int tmp;
+ #define SWAP(a, b) tmp = a, a = b, b = tmp
+       if ((f->want_fullscreen ^ s->mode) & FULLSCREEN_WIDTH)
+         SWAP (b.left, s->left), SWAP (b.right, s->right);
+       if ((f->want_fullscreen ^ s->mode) & FULLSCREEN_HEIGHT)
+         SWAP (b.top, s->top), SWAP (b.bottom, s->bottom);
+ #undef SWAP
+       s->mode = f->want_fullscreen;
+       save_fullscreen_state (f, s);
+       xfree (s);
+ 
+       CGRect screen_bounds = CGDisplayBounds (display);
+       if (f->want_fullscreen & FULLSCREEN_HEIGHT)
+         {
+            b.top = (short)screen_bounds.origin.y;
+            b.bottom = b.top + (short)screen_bounds.size.height;
+ 	   if (display == main_display)
+ 	     b.top += GetMBarHeight();
+         }
+       if (f->want_fullscreen & FULLSCREEN_WIDTH)
+         {
+            b.left = (short)screen_bounds.origin.x;
+            b.right = b.left + (short)screen_bounds.size.width;
+         }
+ 
+       SetWindowBounds(FRAME_MAC_WINDOW (f), kWindowStructureRgn, &b);
+ 
+       /* Necessary because x_set_offset and x_set_window_size refuse
+          to change the offset and size of a full-screen frame. */
+       st = GetWindowBounds(FRAME_MAC_WINDOW (f), kWindowContentRgn, &b);
+       if (st == noErr)
+         {
+           mac_handle_size_change (f, b.right - b.left, b.bottom - b.top);
+           mac_handle_origin_change (f);
+         }
+ 
+       if (f->want_fullscreen & FULLSCREEN_BOTH)
+            CGDisplayRegisterReconfigurationCallback 
+                 (mac_handle_display_reconfiguration, f);
+       else
+            CGDisplayRemoveReconfigurationCallback
+                 (mac_handle_display_reconfiguration, f);
+ 
+       UNBLOCK_INPUT;
+       do_pending_window_change(0);
+     }
+ }
  
  
  /* Set up use of X before we make the first connection.  */
***************
*** 9504,9509 ****
--- 9765,9771 ----
    condemn_scroll_bars_hook = XTcondemn_scroll_bars;
    redeem_scroll_bar_hook = XTredeem_scroll_bar;
    judge_scroll_bars_hook = XTjudge_scroll_bars;
+   fullscreen_hook = mac_fullscreen_hook;
  
    scroll_region_ok = 1;         /* we'll scroll partial frames */
    char_ins_del_ok = 1;
***************
*** 9606,9611 ****
--- 9868,9876 ----
    staticpro (&Qreverse);
    Qreverse = intern ("reverse");
  
+   staticpro (&Qfullscreen_saved_state);
+   Qfullscreen_saved_state = intern ("fullscreen-saved-state");
+ 
    staticpro (&x_display_name_list);
    x_display_name_list = Qnil;
  
***************
*** 9744,9749 ****
--- 10009,10019 ----
      Fcons (list3 (build_string ("mac-roman"),
  		  make_number (smRoman), Qnil), Qnil);
  
+   DEFVAR_BOOL ("mac-autohide-menubar-on-fullscreen", &mac_autohide_menubar_on_fullscreen,
+ 	       doc: /* Non-nil means auto-hide the menubar when a frame's fullscreen parameter is 'fullboth. */);
+   mac_autohide_menubar_on_fullscreen = 1;
+ 
+ 
  #if USE_MAC_TSM
    DEFVAR_LISP ("mac-ts-active-input-overlay", &Vmac_ts_active_input_overlay,
      doc: /* Overlay used to display Mac TSM active input area.  */);
--- ../emacs.orig/src/frame.c	2008-01-07 23:30:09.000000000 -0500
+++ ./src/frame.c	2008-07-16 06:46:05.000000000 -0400
@@ -3136,6 +3136,9 @@
   else
     abort ();
 
+  if (fullscreen_hook != NULL) 
+    fullscreen_hook (f);
+
   do_pending_window_change (0);
 
   /* Don't call `face-set-after-frame-default' when faces haven't been
